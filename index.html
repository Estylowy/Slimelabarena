<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SLIME ARENA LAB ‚Äî Idle Merge Battle</title>
<meta name="description" content="Merge mutant blobs, build your army and survive 20 waves. Idle merge auto-battle game. Play free in browser.">
<meta property="og:title" content="SLIME ARENA LAB">
<meta name="author" content="Estel IT">
<meta name="copyright" content="¬© 2025 Estel IT. All rights reserved.">
<meta name="generator" content="SAL-build-dd7571a30620">
<meta name="company" content="Estel IT">
<meta name="tax-id" content="NIP: 6322038951 | REGON: 540300095">
<!--
  ¬© 2025 Estel IT
  NIP: 6322038951 | REGON: 540300095
  Slime Arena Lab ‚Äî Build dd7571a30620
  Unauthorized copying or distribution is strictly prohibited.
-->
<meta property="og:description" content="Merge mutant blobs ‚Üí auto battle ‚Üí prestige. Free idle game in your browser.">
<meta property="og:type" content="website">
<meta property="og:image" content="https://slime-arena-lab.netlify.app/og.png">
<meta name="theme-color" content="#0a0a0f">
<meta name="twitter:card" content="summary_large_image">
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700;800;900&display=swap');

  :root {
    --bg:        #2d1b69;
    --bg2:       #1a0f42;
    --panel:     #3d2b85;
    --panel2:    #2a1d5e;
    --border:    rgba(255,255,255,0.12);
    --shadow:    rgba(0,0,0,0.4);

    /* Kid-friendly palette */
    --green:   #4cd964;
    --green2:  #34a849;
    --blue:    #5ac8fa;
    --blue2:   #0a84ff;
    --pink:    #ff6b9d;
    --pink2:   #c9174a;
    --yellow:  #ffd60a;
    --yellow2: #c89300;
    --purple:  #bf5af2;
    --purple2: #8a2be2;
    --orange:  #ff9f0a;
    --orange2: #c76000;
    --red:     #ff453a;
    --teal:    #32ade6;

    --text:    #ffffff;
    --text2:   rgba(255,255,255,0.7);
    --dim:     rgba(255,255,255,0.35);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    background-image:
      radial-gradient(ellipse 60% 50% at 15% 15%, rgba(191,90,242,0.22) 0%, transparent 55%),
      radial-gradient(ellipse 50% 60% at 85% 85%, rgba(90,200,250,0.18) 0%, transparent 55%),
      radial-gradient(ellipse 40% 35% at 75% 20%, rgba(76,217,100,0.08) 0%, transparent 50%),
      radial-gradient(ellipse 35% 40% at 25% 80%, rgba(255,107,157,0.07) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 50%, rgba(45,27,105,1) 0%, rgba(18,10,50,1) 100%);
    color: var(--text);
    font-family: 'Nunito', sans-serif;
    min-height: 100vh;
    height: 100vh;        /* needed so flex children can use flex:1 */
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* Floating stars */
  body::before {
    content: '';
    position: fixed; inset: 0;
    background-image:
      radial-gradient(1.5px 1.5px at  8% 12%, rgba(255,255,255,0.85) 0%, transparent 100%),
      radial-gradient(1px   1px   at 18% 42%, rgba(200,220,255,0.60) 0%, transparent 100%),
      radial-gradient(1px   1px   at 27%  8%, rgba(255,255,255,0.70) 0%, transparent 100%),
      radial-gradient(2px   2px   at 38% 68%, rgba(180,200,255,0.50) 0%, transparent 100%),
      radial-gradient(1px   1px   at 48% 18%, rgba(255,255,255,0.65) 0%, transparent 100%),
      radial-gradient(1.5px 1.5px at 55% 82%, rgba(255,255,255,0.75) 0%, transparent 100%),
      radial-gradient(1px   1px   at 62% 35%, rgba(200,255,220,0.55) 0%, transparent 100%),
      radial-gradient(2px   2px   at 70% 55%, rgba(255,255,255,0.45) 0%, transparent 100%),
      radial-gradient(1px   1px   at 78% 22%, rgba(255,220,200,0.60) 0%, transparent 100%),
      radial-gradient(1px   1px   at 85% 75%, rgba(255,255,255,0.70) 0%, transparent 100%),
      radial-gradient(1.5px 1.5px at 92% 40%, rgba(200,220,255,0.65) 0%, transparent 100%),
      radial-gradient(1px   1px   at  5% 88%, rgba(255,255,255,0.55) 0%, transparent 100%),
      radial-gradient(1px   1px   at 33% 95%, rgba(220,200,255,0.50) 0%, transparent 100%),
      radial-gradient(2px   2px   at 50% 50%, rgba(255,255,255,0.35) 0%, transparent 100%);
    pointer-events: none; z-index: 0;
    animation: stars-twinkle 5s ease-in-out infinite alternate;
  }
  body::after {
    content: '';
    position: fixed; inset: 0;
    background-image:
      radial-gradient(1px 1px at 12% 30%, rgba(255,255,255,0.40) 0%, transparent 100%),
      radial-gradient(1px 1px at 25% 65%, rgba(200,255,240,0.35) 0%, transparent 100%),
      radial-gradient(1px 1px at 42% 48%, rgba(255,255,255,0.30) 0%, transparent 100%),
      radial-gradient(1px 1px at 65% 15%, rgba(255,230,200,0.40) 0%, transparent 100%),
      radial-gradient(1px 1px at 82% 88%, rgba(255,255,255,0.35) 0%, transparent 100%),
      radial-gradient(1px 1px at 95% 10%, rgba(200,220,255,0.40) 0%, transparent 100%);
    pointer-events: none; z-index: 0;
    animation: stars-twinkle 7s ease-in-out infinite alternate-reverse;
  }
  @keyframes stars-twinkle {
    from { opacity: 0.55; }
    to   { opacity: 1; }
  }

  /* ‚îÄ‚îÄ 3D BUTTON MIXIN ‚îÄ‚îÄ */
  .btn-3d {
    position: relative;
    border: none;
    border-radius: 14px;
    cursor: pointer;
    font-family: 'Fredoka One', sans-serif;
    font-size: 15px;
    letter-spacing: 0.5px;
    text-transform: uppercase;
    transition: transform 0.08s, box-shadow 0.08s;
    outline: none;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
  }
  .btn-3d::after {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: linear-gradient(180deg, rgba(255,255,255,0.25) 0%, transparent 50%);
    pointer-events: none;
  }
  .btn-3d:active { transform: translateY(3px) scale(0.97); }

  /* ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ */
  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 16px;
    background: rgba(0,0,0,0.3);
    backdrop-filter: blur(8px);
    border-bottom: 2px solid rgba(255,255,255,0.08);
    flex-shrink: 0;
    position: relative;
    z-index: 10;
  }

  .title {
    font-family: 'Fredoka One', sans-serif;
    font-size: 22px;
    letter-spacing: 2px;
    filter: drop-shadow(0 2px 8px rgba(255,214,10,0.4));
    display: flex; align-items: center; gap: 8px;
  }
  .version-badge {
    font-family: 'Nunito', sans-serif;
    font-size: 9px; font-weight: 900;
    letter-spacing: 1.5px;
    padding: 2px 7px; border-radius: 6px;
    background: rgba(255,214,10,0.12);
    border: 1px solid rgba(255,214,10,0.3);
    color: rgba(255,214,10,0.7);
    -webkit-text-fill-color: rgba(255,214,10,0.7);
    filter: none;
    vertical-align: middle;
    white-space: nowrap;
  }

  .currencies { display: flex; gap: 8px; font-size: 13px; flex-wrap: wrap; align-items: center; }

  /* ‚îÄ‚îÄ ACTIVE BUFF CHIPS ‚îÄ‚îÄ */
  .buff-chip {
    display: flex; align-items: center; gap: 4px;
    padding: 3px 7px; border-radius: 20px;
    font-family: 'Nunito', sans-serif; font-size: 10px; font-weight: 800;
    letter-spacing: 0.3px; white-space: nowrap;
    border: 1px solid; cursor: default;
    transition: transform 0.15s;
    position: relative;
  }
  .buff-chip:hover { transform: scale(1.05); }
  .buff-chip-icon { font-size: 11px; }
  .buff-chip-name { font-size: 9px; letter-spacing: 0.5px; }
  .buff-chip-waves {
    font-size: 9px; font-weight: 900;
    padding: 1px 5px; border-radius: 10px;
    background: rgba(0,0,0,0.3);
  }

  /* Global tooltip ‚Äî single div outside chips, JS-positioned */
  #buff-global-tooltip {
    position: fixed; z-index: 99999; pointer-events: none;
    background: rgba(10,8,22,0.97); border: 1px solid rgba(255,255,255,0.15);
    border-radius: 10px; padding: 8px 12px;
    font-family: 'Nunito', sans-serif; font-size: 10px; line-height: 1.6;
    color: rgba(255,255,255,0.8); text-align: center;
    width: 200px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
    opacity: 0; transition: opacity 0.12s;
  }
  #buff-global-tooltip.visible { opacity: 1; }
  #buff-global-tooltip strong { color: #fff; }

  /* Per-buff color themes */
  .buff-crit_aura   { background: rgba(251,191,36,0.12); border-color: rgba(251,191,36,0.4); color: #fbbf24; }
  .buff-overclock   { background: rgba(90,200,250,0.12); border-color: rgba(90,200,250,0.4); color: #5ac8fa; }
  .buff-toxic_field { background: rgba(74,222,128,0.12); border-color: rgba(74,222,128,0.4); color: #4ade80; }
  .buff-shield_wave { background: rgba(99,102,241,0.12); border-color: rgba(99,102,241,0.4); color: #818cf8; }
  .buff-meteor      { background: rgba(251,113,133,0.12); border-color: rgba(251,113,133,0.4); color: #fb7185; }

  /* No transform animation ‚Äî only fade, no conflict with hover scale */
  @keyframes buff-fade-in { from { opacity:0; } to { opacity:1; } }
  .buff-chip.new-buff { animation: buff-fade-in 0.2s ease both; }

  /* Event card duration badge */
  .event-duration {
    display: inline-block; margin-top: 8px;
    padding: 3px 9px; border-radius: 20px;
    font-size: 9px; font-weight: 900; letter-spacing: 0.6px;
  }
  .event-duration.waves   { background: rgba(90,200,250,0.15); border: 1px solid rgba(90,200,250,0.4); color: #5ac8fa; }
  .event-duration.instant { background: rgba(255,214,10,0.15); border: 1px solid rgba(255,214,10,0.4); color: #ffd60a; }

  /* ‚îÄ‚îÄ SLIME CURRENCY ‚îÄ‚îÄ */
  .currency.slime {
    background: linear-gradient(135deg, rgba(90,200,250,0.15), rgba(76,217,100,0.1));
    border-color: rgba(90,200,250,0.4);
    color: #5ac8fa; cursor: pointer;
  }
  .currency.slime:hover { border-color: rgba(90,200,250,0.7); background: rgba(90,200,250,0.2); }

  /* ‚îÄ‚îÄ SHOP TABS ‚îÄ‚îÄ */
  .shop-tabs {
    display: flex; gap: 0;
    border-bottom: 1px solid rgba(255,255,255,0.08);
    flex-shrink: 0;
  }
  .shop-tab-btn {
    flex: 1; padding: 10px 0; font-family: 'Fredoka One', sans-serif;
    font-size: 12px; letter-spacing: 1px; border: none; cursor: pointer;
    background: transparent; color: var(--dim);
    transition: all .15s; border-bottom: 2px solid transparent;
  }
  .shop-tab-btn.active { color: #fff; border-bottom-color: #bf5af2; background: rgba(191,90,242,0.06); }
  .shop-tab-btn:hover:not(.active) { color: var(--text2); background: rgba(255,255,255,0.03); }
  .shop-tab-pane { display: none; padding: 14px 16px; overflow-y: auto; flex: 1; min-height: 0; }
  .shop-tab-pane.active { display: block; }

  /* Slime Shop specifics */
  .slime-balance-bar {
    display: flex; align-items: center; gap: 8px;
    background: rgba(90,200,250,0.08); border: 1px solid rgba(90,200,250,0.2);
    border-radius: 10px; padding: 8px 12px; margin-bottom: 14px;
    font-family: 'Fredoka One', sans-serif; font-size: 13px; color: #5ac8fa;
  }
  .slime-pack-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;
  }
  .slime-pack {
    background: rgba(90,200,250,0.05); border: 1px solid rgba(90,200,250,0.15);
    border-radius: 14px; padding: 14px 12px; text-align: center;
    cursor: pointer; transition: all .15s; position: relative; overflow: hidden;
  }
  .slime-pack:hover { border-color: rgba(90,200,250,0.45); background: rgba(90,200,250,0.12); transform: translateY(-1px); }
  .slime-pack.popular { border-color: rgba(255,214,10,0.4); background: rgba(255,214,10,0.06); }
  .slime-pack.popular:hover { border-color: rgba(255,214,10,0.7); }
  .slime-pack-badge {
    position: absolute; top: 6px; right: 6px;
    font-size: 8px; font-family: 'Nunito', sans-serif; font-weight: 800;
    padding: 2px 6px; border-radius: 4px; letter-spacing: 0.5px; text-transform: uppercase;
  }
  .slime-pack-badge.best { background: rgba(255,214,10,0.25); color: var(--yellow); }
  .slime-pack-badge.popular-badge { background: rgba(255,107,107,0.25); color: #ff6b6b; }
  .slime-pack-icon { font-size: 28px; margin-bottom: 4px; }
  .slime-pack-name { font-family: 'Fredoka One', sans-serif; font-size: 12px; color: #fff; margin-bottom: 2px; }
  .slime-pack-amount { font-family: 'Fredoka One', sans-serif; font-size: 18px; color: #5ac8fa; margin-bottom: 6px; }
  .slime-pack-amount span { font-size: 10px; color: var(--dim); }
  .slime-pack-price {
    font-family: 'Fredoka One', sans-serif; font-size: 13px;
    background: linear-gradient(160deg, #5ac8fa, #2a9fd6);
    color: #fff; padding: 5px 16px; border-radius: 8px;
    display: inline-block; box-shadow: 0 3px 0 #1a6090;
  }
  .slime-pack.popular .slime-pack-price {
    background: linear-gradient(160deg, #f5a623, #e8820c);
    box-shadow: 0 3px 0 #8a4e00;
  }
  .slime-note { font-size: 9px; color: var(--dim); text-align: center; margin-top: 8px; line-height: 1.6; }

  /* Lab Store cant-afford */
  .btn-shop-buy.cant-afford {
    opacity: 0.45; filter: grayscale(0.5);
  }

  /* ‚îÄ‚îÄ SLIME CURRENCY ‚îÄ‚îÄ */
  .currency {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 5px 10px;
    border-radius: 20px;
    font-family: 'Fredoka One', sans-serif;
    font-size: 14px;
    font-weight: 400;
    transition: transform 0.2s;
  }
  .currency.gold   { background: linear-gradient(135deg,#ffd60a,#c89300); box-shadow: 0 3px 0 #8a6200, 0 4px 12px rgba(255,214,10,0.4); color: #3d2000; }
  .currency.bio    { background: linear-gradient(135deg,#4cd964,#34a849); box-shadow: 0 3px 0 #1e6e2a, 0 4px 12px rgba(76,217,100,0.4); color: #0a2a10; }
  .currency.research{ background: linear-gradient(135deg,#bf5af2,#8a2be2); box-shadow: 0 3px 0 #5a0fb5, 0 4px 12px rgba(191,90,242,0.4); color: #fff; }
  .currency-val { font-weight: 400; min-width: 52px; text-align: right; }
  .currency.pop { animation: currency-pop 0.3s ease-out; }

  @keyframes currency-pop {
    0%   { transform: scale(1); }
    50%  { transform: scale(1.2) translateY(-2px); }
    100% { transform: scale(1); }
  }

  .wave-info {
    font-family: 'Fredoka One', sans-serif;
    font-size: 14px;
    color: var(--blue);
    text-shadow: 0 0 10px rgba(90,200,250,0.5);
  }

  .main { display: flex; flex: 1; overflow: hidden; position: relative; z-index: 1; }

  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     MERGE PANEL ‚Äî "Living Lab" organism design
     Dark petri dish, glowing pods, animated life
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

  .panel-merge {
    width: 310px; flex-shrink: 0;
    border-right: 2px solid rgba(255,255,255,0.06);
    display: flex; flex-direction: column;
    position: relative; overflow: hidden;
    background:
      radial-gradient(ellipse 55% 35% at 20% 25%, rgba(76,217,100,0.08) 0%, transparent 65%),
      radial-gradient(ellipse 45% 55% at 78% 72%, rgba(191,90,242,0.07) 0%, transparent 65%),
      linear-gradient(175deg, #1a0f42 0%, #120b33 50%, #0f0828 100%);
  }

  /* Animated breathing colour blobs in background */
  .panel-merge::before {
    content: ''; position: absolute; inset: 0; z-index: 0; pointer-events: none;
    background:
    radial-gradient(ellipse 55% 35% at 20% 25%, rgba(76,217,100,0.08) 0%, transparent 65%),
    radial-gradient(ellipse 45% 55% at 78% 72%, rgba(191,90,242,0.07) 0%, transparent 65%),
    linear-gradient(175deg, #1a0f42 0%, #120b33 50%, #0f0828 100%);
    animation: lab-breathe 7s ease-in-out infinite alternate;
  }
  @keyframes lab-breathe {
    0%   { opacity:.7; transform:scale(1); }
    50%  { opacity:1;  transform:scale(1.06); }
    100% { opacity:.75;transform:scale(.97); }
  }

  /* Hex-grid micro-texture */
  .panel-merge::after {
    content: ''; position: absolute; inset: 0; z-index: 0; pointer-events: none;
    opacity: .035;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='56' height='100'%3E%3Cpath d='M28 66L0 50V16L28 0l28 16v34L28 66zm0 34L0 84V50l28-16 28 16v34L28 100z' fill='none' stroke='%2300ff88' stroke-width='1'/%3E%3C/svg%3E");
  }

  .panel-title {
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    letter-spacing: 3px; color: rgba(255,255,255,0.35);
    padding: 7px 12px; border-bottom: 1px solid rgba(255,255,255,0.05);
    text-transform: uppercase; position: relative; z-index: 1;
    display: flex; align-items: center; gap: 8px;
  }
  /* Pulsing live indicator */
  .panel-title::before {
    content: ''; display: inline-block; width: 6px; height: 6px;
    border-radius: 50%; background: var(--green);
    box-shadow: 0 0 8px var(--green);
    animation: dot-pulse 2.5s ease-in-out infinite;
    flex-shrink: 0;
  }
  @keyframes dot-pulse {
    0%,100% { opacity:1; transform:scale(1); }
    50%     { opacity:.3; transform:scale(.55); }
  }

  /* ‚îÄ‚îÄ GRID ‚Äî overridden below by row-group layout ‚îÄ‚îÄ */
  .merge-grid {
    flex: 1; min-height: 0; overflow-y: auto;
    position: relative; z-index: 1;
  }

  /* ‚îÄ‚îÄ CELL BASE ‚Äî empty slot ‚îÄ‚îÄ */
  .grid-cell {
    aspect-ratio: 1; border-radius: 14px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; position: relative;
    transition: transform .15s cubic-bezier(0.34,1.56,0.64,1), box-shadow .15s, border-color .15s, background .15s;
    background:
      linear-gradient(145deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0.005) 100%),
      rgba(0,0,0,0.25);
    border: 1.5px solid rgba(255,255,255,0.07);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.05), 0 2px 8px rgba(0,0,0,0.5);
    min-height: 62px; overflow: hidden;
  }
  .grid-cell::before {
    content: ''; position: absolute; inset: 0; border-radius: 13px;
    background: linear-gradient(135deg, rgba(255,255,255,0.04) 0%, transparent 50%);
    pointer-events: none; z-index: 0;
  }
  /* Empty: faint "+" hint */
  .grid-cell:not(.occupied)::after {
    content: '+'; position: absolute;
    font-size: 20px; color: rgba(255,255,255,0.07);
    font-family: 'Fredoka One', sans-serif; pointer-events: none;
  }
  .grid-cell:not(.occupied):hover {
    border-color: rgba(255,255,255,0.16);
    background: rgba(255,255,255,0.04);
  }

  /* Occupied slot ‚Äî the organism pod */
  .grid-cell.occupied { cursor: grab; }
  .grid-cell.occupied:active { cursor: grabbing; transform: scale(.9); }
  .grid-cell.occupied:hover  {
    transform: scale(1.1);
    z-index: 10;
    box-shadow: 0 8px 30px rgba(0,0,0,0.5), 0 0 20px rgba(255,255,255,0.1), inset 0 1px 0 rgba(255,255,255,0.15);
  }

  /* Per-tier coloured aura */
  .grid-cell.t1-cell  { border-color:rgba(76,217,100,.55);  background:radial-gradient(ellipse at 40% 35%, rgba(76,217,100,.10) 0%, rgba(76,217,100,.03) 100%);  box-shadow:0 0 18px rgba(76,217,100,.22),  0 0 6px rgba(76,217,100,.12),  inset 0 0 12px rgba(76,217,100,.08),  inset 0 1px 0 rgba(255,255,255,.08); }
  .grid-cell.t2-cell  { border-color:rgba(90,200,250,.55);  background:radial-gradient(ellipse at 40% 35%, rgba(90,200,250,.10) 0%, rgba(90,200,250,.03) 100%);  box-shadow:0 0 18px rgba(90,200,250,.22),  0 0 6px rgba(90,200,250,.12),  inset 0 0 12px rgba(90,200,250,.08),  inset 0 1px 0 rgba(255,255,255,.08); }
  .grid-cell.t3-cell  { border-color:rgba(255,107,157,.55); background:radial-gradient(ellipse at 40% 35%, rgba(255,107,157,.10) 0%, rgba(255,107,157,.03) 100%); box-shadow:0 0 18px rgba(255,107,157,.22), 0 0 6px rgba(255,107,157,.12), inset 0 0 12px rgba(255,107,157,.08), inset 0 1px 0 rgba(255,255,255,.08); }
  .grid-cell.t4-cell  { border-color:rgba(255,159,10,.55);  background:radial-gradient(ellipse at 40% 35%, rgba(255,159,10,.10) 0%,  rgba(255,159,10,.03) 100%);  box-shadow:0 0 18px rgba(255,159,10,.22),  0 0 6px rgba(255,159,10,.12),  inset 0 0 12px rgba(255,159,10,.08),  inset 0 1px 0 rgba(255,255,255,.08); }
  .grid-cell.t5-cell  { border-color:rgba(191,90,242,.55);  background:radial-gradient(ellipse at 40% 35%, rgba(191,90,242,.12) 0%,  rgba(191,90,242,.04) 100%);  box-shadow:0 0 22px rgba(191,90,242,.28),  0 0 8px rgba(191,90,242,.15),  inset 0 0 14px rgba(191,90,242,.10), inset 0 1px 0 rgba(255,255,255,.08); }
  .grid-cell.t6-cell {
    border-color: rgba(255,255,255,.65);
    background: rgba(255,255,255,.05);
    animation: t6-pod 1.6s ease-in-out infinite alternate;
  }
  @keyframes t6-pod {
    from { box-shadow: 0 0 22px rgba(255,255,255,.3), inset 0 0 18px rgba(191,90,242,.1); }
    to   { box-shadow: 0 0 44px rgba(255,255,255,.55), 0 0 70px rgba(255,0,110,.18), inset 0 0 30px rgba(191,90,242,.18); }
  }

  /* Drag & select */
  .grid-cell.drag-over {
    border-color: var(--blue)   !important; background: rgba(90,200,250,.1)  !important;
    box-shadow: 0 0 22px rgba(90,200,250,.5), inset 0 0 14px rgba(90,200,250,.08) !important;
    transform: scale(1.06);
  }
  .grid-cell.selected {
    border-color: var(--yellow) !important;
    box-shadow: 0 0 22px rgba(255,214,10,.6) !important;
    transform: scale(1.06);
    animation: selected-pulse 0.8s ease-in-out infinite alternate;
  }
  @keyframes selected-pulse {
    from { box-shadow: 0 0 16px rgba(255,214,10,.5); }
    to   { box-shadow: 0 0 32px rgba(255,214,10,.9); }
  }
  .grid-cell.merge-flash { animation: cell-flash .4s ease-out forwards; }
  /* Fortress relic: slots 12-19 locked */
  .grid-cell.fortress-locked {
    opacity: 0.28; cursor: not-allowed;
    background: repeating-linear-gradient(
      45deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 2px,
      transparent 2px, transparent 8px
    ) !important;
    border-color: rgba(255,80,80,0.2) !important;
  }
  .grid-cell.fortress-locked:not(.occupied)::before {
    content: 'üîí'; position: absolute; font-size: 14px; z-index: 10; opacity: 0.4;
  }
  .grid-cell.fortress-locked.occupied {
    opacity: 0.6; cursor: pointer; /* Allow selecting to move out */
    border-color: rgba(255,180,0,0.4) !important;
    box-shadow: 0 0 8px rgba(255,180,0,0.2) !important;
  }
  @keyframes cell-flash {
    0%  { background:rgba(255,255,255,.55); box-shadow:0 0 50px white; }
    100%{ background:rgba(76,217,100,.04); }
  }


  /* ‚îÄ‚îÄ BLOB SPAWN ANIMATION ‚îÄ‚îÄ */
  @keyframes blob-spawn {
    0%   { transform: scale(0) translateY(12px) rotate(-15deg); opacity: 0; filter: brightness(3); }
    40%  { transform: scale(1.22) translateY(-6px) rotate(6deg); opacity: 1; filter: brightness(1.8); }
    65%  { transform: scale(0.88) translateY(2px) rotate(-3deg); filter: brightness(1.2); }
    82%  { transform: scale(1.07) translateY(-2px) rotate(1deg); }
    100% { transform: scale(1) translateY(0) rotate(0deg); filter: brightness(1); }
  }
  @keyframes spawn-glow {
    0%   { box-shadow: 0 0 0px rgba(76,217,100,0); background: rgba(76,217,100,0.35); }
    35%  { box-shadow: 0 0 28px rgba(76,217,100,0.9), 0 0 55px rgba(76,217,100,0.4); background: rgba(76,217,100,0.2); }
    100% { box-shadow: 0 0 0px rgba(76,217,100,0); background: rgba(76,217,100,0.04); }
  }
  .grid-cell.blob-spawning {
    animation: blob-spawn 0.55s cubic-bezier(0.34,1.56,0.64,1) forwards,
               spawn-glow 0.55s ease-out forwards;
  }
  @keyframes gold-pop {
    0%   { opacity:1; transform: translateY(0) scale(1); }
    70%  { opacity:1; transform: translateY(-28px) scale(1.1); }
    100% { opacity:0; transform: translateY(-44px) scale(0.8); }
  }
  .buy-gold-pop {
    position: fixed; pointer-events: none; z-index: 9999;
    font-family: 'Fredoka One', sans-serif; font-size: 14px;
    color: #fbbf24; text-shadow: 0 0 8px rgba(251,191,36,0.8);
    animation: gold-pop 0.7s ease-out forwards;
  }

  /* Canvas blob */
  .blob-canvas { width:84%; height:84%; display:block; position:relative; z-index:2; }

  /* Mutant ‚Äî rainbow shimmer border */
  .grid-cell.mutant-cell {
    animation: mutant-pod 2.4s linear infinite !important;
    border-width: 2px !important;
  }
  @keyframes mutant-pod {
    0%  { border-color:var(--pink);   box-shadow:0 0 18px rgba(255,107,157,.5); }
    33% { border-color:var(--yellow); box-shadow:0 0 18px rgba(255,214,10,.5); }
    66% { border-color:var(--blue);   box-shadow:0 0 18px rgba(90,200,250,.5); }
    100%{ border-color:var(--pink);   box-shadow:0 0 18px rgba(255,107,157,.5); }
  }

  /* Elite ‚Äî golden sunburst glow */
  .grid-cell.elite-cell {
    border-color: var(--yellow) !important;
    animation: elite-pod .85s ease-in-out infinite alternate !important;
  }
  @keyframes elite-pod {
    from { box-shadow: 0 0 10px rgba(255,214,10,.5); }
    to   { box-shadow: 0 0 30px rgba(255,214,10,1), 0 0 55px rgba(255,214,10,.3); }
  }

  /* Tag badges */
  .tag-badge {
    position:absolute; bottom:3px; right:3px;
    font-size:7px; font-weight:900; font-family:'Nunito',sans-serif;
    padding:1px 4px; border-radius:5px; letter-spacing:.5px; z-index:4;
  }
  .tag-bio   { background:rgba(76,217,100,.28);  color:#4cd964; border:1px solid rgba(76,217,100,.5); }
  .tag-fire  { background:rgba(255,159,10,.28);  color:#ff9f0a; border:1px solid rgba(255,159,10,.5); }
  .tag-toxic { background:rgba(163,230,53,.28);  color:#a3e635; border:1px solid rgba(163,230,53,.5); }
  .tag-mech  { background:rgba(90,200,250,.28);  color:#5ac8fa; border:1px solid rgba(90,200,250,.5); }

  /* ‚îÄ‚îÄ BUY SECTION ‚îÄ‚îÄ */
  .buy-section {
    padding: 8px 10px; border-top: 1px solid rgba(255,255,255,.06);
    display: flex; gap: 8px; flex-shrink: 0;
    background: rgba(0,0,0,.35); position: relative; z-index: 1;
  }

  .btn {
    flex: 1; padding: 12px 8px;
    font-family: 'Fredoka One', sans-serif;
    font-size: 15px; letter-spacing: 0.5px;
    cursor: pointer; transition: all 0.1s;
    border-radius: 14px; border: none;
    position: relative; outline: none;
  }
  .btn::after {
    content: '';
    position: absolute; inset: 0;
    border-radius: inherit;
    background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 60%);
    pointer-events: none;
  }
  .btn:active { transform: translateY(3px); }

  .btn-buy {
    background: linear-gradient(160deg, #ffd60a, #ff9f0a);
    box-shadow: 0 5px 0 #8a5200, 0 6px 16px rgba(255,159,10,0.5);
    color: #3d1a00;
  }
  .btn-buy:hover { background: linear-gradient(160deg, #ffe234, #ffb224); }
  .btn-buy:active { box-shadow: 0 2px 0 #8a5200; }
  .btn-buy:disabled { background: rgba(255,255,255,0.1); box-shadow: none; color: rgba(255,255,255,0.3); cursor: not-allowed; }

  .btn-automerge {
    background: rgba(255,255,255,0.1);
    box-shadow: 0 4px 0 rgba(0,0,0,0.3);
    color: rgba(255,255,255,0.5);
    font-size: 12px;
    max-width: 90px;
  }
  .btn-automerge.active {
    background: linear-gradient(160deg, #4cd964, #26a843);
    box-shadow: 0 4px 0 #1a5e2a, 0 6px 16px rgba(76,217,100,0.4);
    color: #fff;
  }

  /* ‚îÄ‚îÄ SYNERGY BAR ‚îÄ‚îÄ */
  .synergy-bar {
    display: flex; gap: 5px;
    padding: 7px 10px;
    border-top: 1px solid var(--border);
    flex-wrap: wrap;
    background: rgba(0,0,0,0.15);
    min-height: 52px; /* sta≈Ça wysoko≈õƒá ‚Äî nie skacze layoutu */
    align-content: flex-start;
    overflow: hidden;
  }
  .syn-chip {
    display: flex; align-items: center; gap: 5px;
    padding: 4px 10px 4px 7px; border-radius: 20px;
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    background: rgba(255,255,255,0.04);
    border: 1.5px solid rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.3); transition: all 0.25s; cursor: default;
    position: relative; overflow: hidden;
  }
  .syn-chip.syn-active {
    background: rgba(0,0,0,0.3);
    border-color: var(--syn-color, var(--green));
    color: #fff;
    box-shadow: 0 0 12px color-mix(in srgb, var(--syn-color, #fff) 35%, transparent),
                inset 0 0 20px color-mix(in srgb, var(--syn-color, #fff) 8%, transparent);
  }
  .syn-chip.syn-active::before {
    content: '';
    position: absolute; inset: 0;
    background: linear-gradient(90deg, color-mix(in srgb, var(--syn-color,#fff) 12%, transparent), transparent);
    pointer-events: none;
  }
  .syn-chip.syn-pulse {
    animation: syn-pop 0.5s cubic-bezier(0.34,1.56,0.64,1);
  }
  @keyframes syn-pop {
    0%   { transform: scale(1); }
    40%  { transform: scale(1.18); }
    100% { transform: scale(1); }
  }
  .syn-icon { font-size: 13px; line-height: 1; }
  .syn-tag  { font-size: 9px; letter-spacing: 1px; opacity: 0.8; }
  .syn-count{ font-size: 13px; font-weight: 700; min-width: 12px; text-align: center; }
  .syn-bonus { font-size: 10px; letter-spacing: 0.3px; opacity: 0.9; }
  .syn-track {
    display: flex; align-items: center; gap: 2px; margin-left: 2px;
  }
  .syn-pip  { display: inline-block; width: 4px; height: 10px; border-radius: 2px;
              background: rgba(255,255,255,0.12); transition: all 0.2s; }
  .syn-pip.syn-pip-on {
    background: var(--syn-color, var(--green));
    box-shadow: 0 0 5px var(--syn-color, #fff);
  }

  /* ‚îÄ‚îÄ SYNERGY POP-UP ‚îÄ‚îÄ */
  #synergy-popup {
    position: fixed; bottom: 130px; left: 50%; transform: translateX(-50%) scale(0.8);
    z-index: 600; pointer-events: none; opacity: 0;
    transition: opacity 0.2s, transform 0.25s cubic-bezier(0.34,1.56,0.64,1);
    min-width: 240px; max-width: 300px;
    background: rgba(12,8,30,0.96);
    border: 1.5px solid var(--syn-popup-color, var(--green));
    border-radius: 14px; padding: 12px 16px;
    box-shadow: 0 0 30px color-mix(in srgb, var(--syn-popup-color, var(--green)) 40%, transparent),
                0 8px 32px rgba(0,0,0,0.6);
    text-align: center;
    font-family: 'Fredoka One', sans-serif;
  }
  #synergy-popup.visible {
    opacity: 1; transform: translateX(-50%) scale(1);
  }
  .syn-popup-tag {
    font-size: 11px; letter-spacing: 2px;
    color: var(--syn-popup-color, var(--green));
    margin-bottom: 3px;
  }
  .syn-popup-name {
    font-size: 18px; color: #fff;
    margin-bottom: 6px;
  }
  .syn-popup-bonus {
    font-size: 22px; font-weight: 700;
    color: var(--syn-popup-color, var(--green));
    filter: drop-shadow(0 0 8px var(--syn-popup-color, var(--green)));
    margin-bottom: 4px;
  }
  .syn-popup-desc {
    font-size: 11px; color: rgba(255,255,255,0.6);
    font-family: 'Nunito', sans-serif; font-weight: 600;
    line-height: 1.4;
  }

  /* ‚îÄ‚îÄ CENTER: ARENA ‚îÄ‚îÄ */
  .panel-arena {
    flex: 1; display: flex; flex-direction: column;
    background:
      radial-gradient(ellipse 70% 50% at 80% 20%, rgba(90,200,250,0.06) 0%, transparent 55%),
      radial-gradient(ellipse 50% 60% at 20% 80%, rgba(191,90,242,0.05) 0%, transparent 55%),
      rgba(0,0,0,0.5);
    position: relative;
  }

  .arena-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 14px; border-bottom: 1px solid rgba(255,255,255,0.07);
    flex-shrink: 0; font-family: 'Fredoka One', sans-serif; font-size: 13px;
    background: linear-gradient(180deg, rgba(255,255,255,0.04) 0%, rgba(0,0,0,0.2) 100%);
    backdrop-filter: blur(4px);
  }

  #arena-canvas { width: 100%; display: block; }

  /* canvas wrapper must not overflow ‚Äî min-height:0 is the key */
  .canvas-wrap {
    flex: 1;
    min-height: 0;
    position: relative;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* All bottom sections must NOT shrink away */
  .stat-pills    { flex-shrink: 0; }
  .battle-log    { flex-shrink: 0; }
  .reward-bar    { flex-shrink: 0; }
  .arena-footer  { flex-shrink: 0; }
  .arena-header  { flex-shrink: 0; }

  .arena-footer {
    padding: 10px 14px; border-top: 1px solid var(--border);
    display: flex; gap: 8px; flex-shrink: 0;
    background: linear-gradient(180deg, rgba(20,10,50,0.95) 0%, rgba(10,5,30,0.98) 100%);
  }

  /* ‚îÄ‚îÄ START WAVE BUTTON ‚îÄ‚îÄ */
  .btn-start {
    flex: 1; padding: 14px;
    background: linear-gradient(160deg, #4cd964, #26a843);
    box-shadow: 0 6px 0 #1a5e2a, 0 8px 24px rgba(76,217,100,0.4);
    color: #fff; font-family: 'Fredoka One', sans-serif;
    font-size: 18px; letter-spacing: 1px; text-transform: uppercase;
    border: none; border-radius: 16px; cursor: pointer;
    transition: all 0.1s; outline: none; position: relative;
  }
  .btn-start::after {
    content: ''; position: absolute; inset: 0; border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.25) 0%, transparent 50%);
    pointer-events: none;
  }
  .btn-start:hover { background: linear-gradient(160deg, #60ff7a, #34c856); }
  .btn-start:active { transform: translateY(4px); box-shadow: 0 2px 0 #1a5e2a; }
  .btn-start:disabled {
    background: rgba(255,255,255,0.1); box-shadow: none;
    color: rgba(255,255,255,0.3); cursor: not-allowed;
  }
  .btn-start.fighting {
    background: linear-gradient(160deg, #ff6b9d, #c9174a);
    box-shadow: 0 6px 0 #8a0030, 0 8px 24px rgba(255,107,157,0.4);
    animation: pulse-fight 1s infinite;
  }
  .btn-start.boss-wave {
    background: linear-gradient(160deg, var(--orange), #d46000);
    box-shadow: 0 6px 0 #8a3800, 0 8px 24px rgba(255,159,10,0.5);
    animation: pulse-boss 0.6s infinite;
  }
  @keyframes pulse-fight {
    0%,100% { box-shadow: 0 6px 0 #8a0030, 0 8px 24px rgba(255,107,157,0.4); }
    50%      { box-shadow: 0 6px 0 #8a0030, 0 8px 40px rgba(255,107,157,0.8); }
  }
  @keyframes pulse-boss {
    0%,100% { box-shadow: 0 6px 0 #8a3800, 0 8px 24px rgba(255,159,10,0.5); }
    50%      { box-shadow: 0 6px 0 #8a3800, 0 8px 50px rgba(255,159,10,1); }
  }

  /* ‚îÄ‚îÄ SPEED BUTTON ‚îÄ‚îÄ */
  .btn-speed {
    padding: 8px 16px;
    background: rgba(255,255,255,0.1);
    box-shadow: 0 3px 0 rgba(0,0,0,0.3);
    color: rgba(255,255,255,0.6);
    font-family: 'Fredoka One', sans-serif; font-size: 14px;
    border: none; border-radius: 12px; cursor: pointer;
    transition: all 0.1s; outline: none;
  }
  .btn-speed.fast {
    background: linear-gradient(160deg, #ffd60a, #c89300);
    box-shadow: 0 3px 0 #8a6200, 0 4px 12px rgba(255,214,10,0.4);
    color: #3d2000;
    animation: speed-pulse 0.4s infinite alternate;
  }
  .btn-speed.ultra {
    background: linear-gradient(160deg, #ff6b9d, #c9174a);
    box-shadow: 0 3px 0 #8a0030, 0 4px 16px rgba(255,107,157,0.6);
    color: #fff;
    animation: speed-pulse 0.25s infinite alternate;
  }
  @keyframes speed-pulse {
    from { transform: scale(1); }
    to   { transform: scale(1.04) translateY(-1px); }
  }

  /* ‚îÄ‚îÄ STAT PILLS ‚îÄ‚îÄ */
  .stat-pill {
    padding: 4px 12px; border-radius: 20px;
    font-family: 'Fredoka One', sans-serif; font-size: 12px;
    background: rgba(255,255,255,0.1); color: var(--text2);
    border: 1px solid rgba(255,255,255,0.12);
    transition: all 0.2s;
  }
  .stat-pill.boss-pill {
    background: linear-gradient(135deg, rgba(255,159,10,0.3), rgba(255,107,157,0.3));
    color: var(--orange); border-color: var(--orange);
    animation: boss-pill-pulse 0.5s infinite alternate;
  }
  @keyframes boss-pill-pulse { from { opacity: 1; } to { opacity: 0.6; } }

  /* ‚îÄ‚îÄ BOSS BANNER ‚îÄ‚îÄ */
  .boss-banner {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Fredoka One', sans-serif;
    font-size: 42px; color: var(--orange);
    text-shadow: 0 4px 0 var(--orange2), 0 0 40px rgba(255,159,10,0.8);
    letter-spacing: 4px; pointer-events: none; z-index: 200;
    animation: boss-banner-anim 2.5s ease-out forwards; white-space: nowrap;
  }
  @keyframes boss-banner-anim {
    0%   { opacity: 0; transform: translate(-50%,-50%) scale(0.3); }
    20%  { opacity: 1; transform: translate(-50%,-50%) scale(1.15); }
    70%  { opacity: 1; transform: translate(-50%,-50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%,-50%) scale(0.85); }
  }

  /* ‚îÄ‚îÄ RIGHT PANEL: UPGRADES ‚îÄ‚îÄ */
  /* Upgrade item with icon */
  .upgrade-item { display: flex !important; align-items: flex-start !important; gap: 10px !important; }
  .upgrade-icon { font-size: 20px; flex-shrink: 0; width: 28px; text-align: center; margin-top: 2px; }
  .upgrade-body { flex: 1; min-width: 0; }
  .upgrade-item.locked { opacity: 0.55; }
  .upgrade-item.tier-locked { opacity: 0.35; }
  .cost-gold.cant, .cost-bio.cant, .cost-research.cant { opacity: 0.5; text-decoration: line-through; }

  /* Research active bar */
  .research-active-bar {
    background: linear-gradient(135deg, rgba(191,90,242,0.12), rgba(90,200,250,0.08));
    border: 1px solid rgba(191,90,242,0.35); border-radius: 12px;
    padding: 10px 12px; margin-bottom: 8px;
  }
  .research-active-label {
    display: flex; align-items: center; justify-content: space-between;
    font-size: 11px; color: #fff; margin-bottom: 6px;
  }
  .research-timer {
    font-family: 'Fredoka One', sans-serif; font-size: 14px;
    color: #bf5af2; letter-spacing: 1px;
  }
  .research-progress-track {
    height: 6px; background: rgba(255,255,255,0.08); border-radius: 3px; overflow: hidden;
  }
  .research-progress-fill {
    height: 100%; border-radius: 3px;
    background: linear-gradient(90deg, #bf5af2, #5ac8fa);
    transition: width 1s linear;
    box-shadow: 0 0 8px rgba(191,90,242,0.6);
  }
  .research-queue-label {
    font-size: 9px; color: var(--dim); letter-spacing: 1px;
    padding: 4px 6px; margin-bottom: 6px;
  }
  /* Research item states */
  .research-item.research-active-item {
    border-color: rgba(191,90,242,0.4) !important;
    background: rgba(191,90,242,0.07) !important;
  }
  .research-item.research-queued {
    border-color: rgba(90,200,250,0.25) !important;
    opacity: 0.7;
  }
  .res-badge {
    display: inline-block; font-size: 9px; padding: 2px 7px; border-radius: 5px;
    font-family: 'Nunito', sans-serif; font-weight: 700; letter-spacing: 0.5px;
  }
  .res-badge.res-done    { background: rgba(76,217,100,0.2); color: var(--green); }
  .res-badge.res-running { background: rgba(191,90,242,0.2); color: #bf5af2; }
  .res-badge.res-queued  { background: rgba(90,200,250,0.2); color: #5ac8fa; }

  /* ‚îÄ‚îÄ RIGHT PANEL: UPGRADES ‚îÄ‚îÄ */
  .panel-upgrades {
    width: 270px; flex-shrink: 0;
    border-left: 2px solid rgba(255,255,255,0.08);
    display: flex; flex-direction: column;
    background: rgba(0,0,0,0.25);
    backdrop-filter: blur(4px);
    overflow: hidden; /* tab-content scrolls internally */
  }
  .panel-upgrades::-webkit-scrollbar { width: 4px; }
  .panel-upgrades::-webkit-scrollbar-track { background: transparent; }
  .panel-upgrades::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }

  .upgrade-list { padding: 8px; display: flex; flex-direction: column; gap: 6px; }

  .upgrade-item {
    padding: 10px 12px; border-radius: 12px;
    cursor: pointer; transition: all 0.15s;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.08);
    position: relative; overflow: hidden;
  }
  .upgrade-item::before {
    content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 4px; border-radius: 4px 0 0 4px;
  }
  .upgrade-item:hover { background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.2); }
  .upgrade-item.can-buy { border-color: rgba(76,217,100,0.4); background: rgba(76,217,100,0.06); }
  .upgrade-item.can-buy::before { background: var(--green); }
  .upgrade-item.can-buy:hover { border-color: var(--green); box-shadow: 0 4px 16px rgba(76,217,100,0.2); }
  .upgrade-item.bought { opacity: 0.45; cursor: default; }
  .upgrade-item.bought::before { background: rgba(255,255,255,0.2); }

  .upgrade-name { font-family: 'Fredoka One', sans-serif; font-size: 13px; color: #fff; margin-bottom: 3px; }
  .upgrade-desc { font-size: 11px; color: var(--text2); margin-bottom: 5px; line-height: 1.4; }
  .upgrade-cost { font-family: 'Fredoka One', sans-serif; font-size: 12px; display: flex; gap: 8px; }
  .cost-gold    { color: var(--yellow); }
  .cost-bio     { color: var(--green); }
  .cost-research{ color: var(--purple); }

  /* ‚îÄ‚îÄ PRESTIGE SECTION ‚îÄ‚îÄ */
  .prestige-section { padding: 10px; border-top: 1px solid var(--border); margin-top: auto; }
  .prestige-bar-label { font-family: 'Fredoka One', sans-serif; font-size: 10px; color: var(--text2); text-align: center; margin-bottom: 5px; }
  .prestige-bar-wrap {
    margin: 6px 0; height: 8px;
    background: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden;
    border: 1px solid rgba(255,255,255,0.1);
  }
  .prestige-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--purple), var(--pink));
    border-radius: 10px; transition: width 0.5s ease;
    box-shadow: 0 0 8px var(--purple);
  }

  .btn-prestige {
    width: 100%; padding: 12px;
    background: linear-gradient(160deg, var(--purple), var(--purple2));
    box-shadow: 0 5px 0 #4a0090, 0 6px 20px rgba(191,90,242,0.4);
    color: #fff; font-family: 'Fredoka One', sans-serif;
    font-size: 14px; letter-spacing: 1px; text-transform: uppercase;
    border: none; border-radius: 14px; cursor: pointer;
    transition: all 0.1s; outline: none; position: relative;
  }
  .btn-prestige::after {
    content: ''; position: absolute; inset: 0; border-radius: 14px;
    background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 60%);
    pointer-events: none;
  }
  .btn-prestige:hover { background: linear-gradient(160deg, #d070ff, #9a3bf2); }
  .btn-prestige:active { transform: translateY(3px); box-shadow: 0 2px 0 #4a0090; }
  .btn-prestige:disabled { background: rgba(255,255,255,0.1); box-shadow: none; color: rgba(255,255,255,0.3); cursor: not-allowed; }

  /* ‚îÄ‚îÄ REWARD BUTTONS ‚îÄ‚îÄ */
  .btn-reward {
    flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 2px; padding: 8px 10px; border-radius: 14px; border: 1.5px solid rgba(255,255,255,0.08);
    background: rgba(255,255,255,0.03); cursor: pointer;
    transition: all .15s; min-height: 52px; position: relative; overflow: hidden;
  }
  .btn-reward::before {
    content: ''; position: absolute; inset: 0; opacity: 0;
    transition: opacity .15s; pointer-events: none;
  }
  .btn-reward:hover:not(:disabled)::before { opacity: 1; }
  .btn-reward:hover:not(:disabled) { transform: translateY(-1px); }
  .btn-reward:disabled { opacity: 0.4; cursor: default; transform: none; }
  .btn-reward:active:not(:disabled) { transform: translateY(1px); }

  /* Kolory per typ */
  .rwd-bio  { border-color: rgba(76,217,100,0.25) !important; }
  .rwd-bio::before  { background: linear-gradient(135deg, rgba(76,217,100,0.12), transparent); }
  .rwd-bio:hover:not(:disabled)  { border-color: rgba(76,217,100,0.55) !important; box-shadow: 0 0 18px rgba(76,217,100,0.2); }
  .rwd-gold { border-color: rgba(255,214,10,0.25) !important; }
  .rwd-gold::before { background: linear-gradient(135deg, rgba(255,214,10,0.12), transparent); }
  .rwd-gold:hover:not(:disabled) { border-color: rgba(255,214,10,0.55) !important; box-shadow: 0 0 18px rgba(255,214,10,0.2); }
  .rwd-res  { border-color: rgba(191,90,242,0.25) !important; }
  .rwd-res::before  { background: linear-gradient(135deg, rgba(191,90,242,0.12), transparent); }
  .rwd-res:hover:not(:disabled)  { border-color: rgba(191,90,242,0.55) !important; box-shadow: 0 0 18px rgba(191,90,242,0.2); }

  .rwd-icon  { font-size: 18px; line-height: 1; }
  .rwd-label { font-family: 'Fredoka One', sans-serif; font-size: 11px; letter-spacing: 1.5px; color: #fff; }
  .rwd-sub   { font-family: 'Nunito', sans-serif; font-size: 9px; color: var(--dim); letter-spacing: 0.5px; }
  .rwd-ad-note { font-family: 'Nunito', sans-serif; font-size: 8px; color: rgba(255,255,255,0.18); letter-spacing: 0.3px; margin-top: 1px; }
  .btn-reward:disabled .rwd-ad-note { display: none; }


  /* ‚îÄ‚îÄ LIVE DPS ‚îÄ‚îÄ */
  .live-dps {
    position: absolute; top: 8px; right: 10px;
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    color: var(--green); text-shadow: 0 0 10px rgba(76,217,100,0.6);
    pointer-events: none; z-index: 50; transition: color 0.3s;
  }
  .live-dps.critting { color: var(--yellow); text-shadow: 0 0 14px rgba(255,214,10,0.7); }
  .live-dps-val { font-size: 20px; display: block; }

  /* ‚îÄ‚îÄ X2 BANNER ‚îÄ‚îÄ */
  .x2-banner {
    display: none; position: absolute; top: 36px; right: 10px;
    font-family: 'Fredoka One', sans-serif; font-size: 10px;
    color: var(--yellow); background: rgba(255,214,10,0.12);
    border: 1px solid rgba(255,214,10,0.4); padding: 3px 10px;
    border-radius: 20px; pointer-events: none; z-index: 50;
    animation: x2-blink 1s infinite alternate;
  }
  .x2-banner.active { display: block; }
  @keyframes x2-blink { from { opacity: 1; } to { opacity: 0.4; } }

  /* ‚îÄ‚îÄ TOOLTIPS ‚îÄ‚îÄ */
  .tooltip-wrap { position: relative; }
  .tooltip {
    display: none; position: absolute;
    bottom: calc(100% + 8px); left: 50%;
    transform: translateX(-50%);
    background: rgba(20,10,50,0.97);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 10px;
    padding: 13px 15px; min-width: 190px; max-width: 260px;
    font-size: 13px; color: var(--text2); z-index: 300;
    pointer-events: none; white-space: normal;
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  }
  .tooltip-wrap:hover .tooltip { display: block; }
  .tt-name { font-family: 'Fredoka One', sans-serif; font-size: 17px; color: #fff; margin-bottom: 6px; }
  .tt-sep  { border: none; border-top: 1px solid rgba(255,255,255,0.15); margin: 5px 0; }
  .tt-dps  { color: var(--yellow); font-weight: 700; font-size: 14px; }
  .tt-trait{ color: var(--blue); margin-top: 3px; }

  /* ‚îÄ‚îÄ SHOP MODAL ‚Äî PREMIUM ‚îÄ‚îÄ */
  .shop-overlay {
    display: none; position: fixed; inset: 0;
    background: rgba(4,2,18,0.96); backdrop-filter: blur(12px);
    z-index: 850; align-items: center; justify-content: center;
  }
  .shop-overlay.open { display: flex; }
  .shop-modal {
    background: linear-gradient(160deg, #12093a 0%, #0d0620 100%);
    border: 1.5px solid rgba(191,90,242,0.35);
    border-radius: 24px;
    box-shadow: 0 0 0 1px rgba(191,90,242,0.08),
                0 0 60px rgba(191,90,242,0.25),
                0 0 120px rgba(90,32,200,0.15),
                0 30px 80px rgba(0,0,0,0.6);
    padding: 0; width: min(520px, 95vw); max-height: 90vh;
    overflow: clip; display: flex; flex-direction: column;
  }
  .shop-header {
    padding: 22px 24px 16px;
    background: linear-gradient(180deg, rgba(191,90,242,0.12) 0%, transparent 100%);
    border-bottom: 1px solid rgba(255,255,255,0.06);
    display: flex; align-items: center; gap: 12px;
    flex-shrink: 0;
  }
  .shop-header-icon { font-size: 32px; }
  .shop-header-text { flex: 1; }
  .shop-title {
    font-family: 'Fredoka One', sans-serif; font-size: 24px;
    color: #fff; letter-spacing: 2px; line-height: 1;
    margin-bottom: 3px;
  }
  .shop-subtitle { font-size: 12px; color: var(--dim); letter-spacing: 1.5px; text-transform: uppercase; }
  .shop-body { overflow-y: auto; padding: 18px; flex: 1; }
  .shop-section-label {
    font-size: 11px; letter-spacing: 2px; color: var(--dim);
    text-transform: uppercase; padding: 0 2px 7px;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    margin-bottom: 10px; margin-top: 14px;
  }
  .shop-section-label:first-child { margin-top: 0; }
  .shop-item {
    display: flex; align-items: center; gap: 14px;
    padding: 14px 16px; border-radius: 14px; margin-bottom: 8px;
    background: rgba(255,255,255,0.03);
    border: 1px solid rgba(255,255,255,0.07);
    transition: all 0.15s; position: relative; overflow: hidden;
  }
  .shop-item::before {
    content: ''; position: absolute; inset: 0; opacity: 0;
    transition: opacity .15s; pointer-events: none;
    background: linear-gradient(135deg, rgba(191,90,242,0.06), rgba(90,200,250,0.04));
  }
  .shop-item:hover::before { opacity: 1; }
  .shop-item:hover { border-color: rgba(191,90,242,0.3); }
  .shop-item.owned { opacity: 0.5; pointer-events: none; }
  .shop-item.featured {
    border-color: rgba(255,214,10,0.3);
    background: rgba(255,214,10,0.04);
  }
  .shop-item.featured::before {
    background: linear-gradient(135deg, rgba(255,214,10,0.07), rgba(255,159,10,0.04));
    pointer-events: none;
  }
  .shop-item.featured:hover { border-color: rgba(255,214,10,0.5); }
  .shop-item-icon { font-size: 30px; flex-shrink: 0; width: 40px; text-align: center; }
  .shop-item-info { flex: 1; min-width: 0; }
  .shop-item-name {
    font-family: 'Fredoka One', sans-serif; font-size: 16px;
    color: #fff; margin-bottom: 3px; display: flex; align-items: center; gap: 6px;
  }
  .shop-item-badge {
    font-size: 9px; padding: 2px 7px; border-radius: 4px;
    background: rgba(255,214,10,0.2); color: var(--yellow);
    font-family: 'Nunito', sans-serif; font-weight: 700;
    letter-spacing: 0.5px; text-transform: uppercase;
  }
  .shop-item-badge.hot { background: rgba(255,107,107,0.2); color: #ff6b6b; }
  .shop-item-badge.new { background: rgba(76,217,100,0.2); color: var(--green); }
  .shop-item-desc { font-size: 12px; color: var(--text2); line-height: 1.6; }
  .btn-shop-buy {
    flex-shrink: 0; padding: 11px 18px;
    background: linear-gradient(160deg, #bf5af2, #7c3aed);
    box-shadow: 0 4px 0 #4a0090, 0 0 20px rgba(191,90,242,0.3);
    color: #fff; font-family: 'Fredoka One', sans-serif; font-size: 15px;
    border: none; border-radius: 12px; cursor: pointer;
    transition: filter .1s, transform .1s; white-space: nowrap;
    position: relative; z-index: 2;
  }
  .btn-shop-buy:hover { filter: brightness(1.2); }
  .btn-shop-buy:active { transform: translateY(2px); box-shadow: 0 2px 0 #4a0090; }
  .btn-shop-buy.owned {
    background: rgba(76,217,100,0.15); box-shadow: none;
    color: var(--green); font-size: 13px; cursor: default;
    border: 1px solid rgba(76,217,100,0.3);
  }
  .btn-shop-buy.gold-btn {
    background: linear-gradient(160deg, #f5a623, #e8820c);
    box-shadow: 0 4px 0 #8a4e00, 0 0 20px rgba(245,166,35,0.3);
  }
  .btn-shop-buy.gold-btn:hover { filter: brightness(1.15); }
  .shop-footer {
    padding: 12px 16px;
    border-top: 1px solid rgba(255,255,255,0.06);
    flex-shrink: 0;
  }
  .btn-shop-close {
    width: 100%; padding: 11px;
    background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
    color: var(--dim); font-family: 'Fredoka One', sans-serif; font-size: 12px;
    cursor: pointer; transition: all .15s; border-radius: 12px; letter-spacing: 1px;
  }
  .btn-shop-close:hover { background: rgba(255,255,255,0.1); color: #fff; }
  .btn-shop-open {
    padding: 7px 14px;
    background: linear-gradient(160deg, rgba(191,90,242,0.3), rgba(138,43,226,0.3));
    border: 1px solid rgba(191,90,242,0.4);
    color: var(--purple); font-family: 'Fredoka One', sans-serif; font-size: 12px;
    border-radius: 12px; cursor: pointer; transition: all 0.15s;
  }
  .btn-shop-open:hover { background: rgba(191,90,242,0.25); }
  /* Store-locked grid slots */
  .grid-cell.store-locked {
    opacity: 0.55; cursor: pointer;
    background: repeating-linear-gradient(
      45deg, rgba(76,217,100,0.04) 0px, rgba(76,217,100,0.04) 2px,
      transparent 2px, transparent 8px) !important;
    border-color: rgba(76,217,100,0.25) !important;
  }
  .grid-cell.store-locked:hover {
    opacity: 0.85; border-color: rgba(76,217,100,0.7) !important;
    box-shadow: 0 0 16px rgba(76,217,100,0.3) !important;
  }
  /* Override the '+' pseudo-element for locked slots */
  .grid-cell.store-locked::after {
    content: 'üîí' !important;
    font-size: 22px !important;
    color: unset !important;
    filter: drop-shadow(0 0 8px rgba(76,217,100,0.9)) drop-shadow(0 0 16px rgba(76,217,100,0.5));
    position: absolute;
    font-family: unset !important;
  }

  /* ‚îÄ‚îÄ OVERLAYS (relic / event) ‚îÄ‚îÄ */
  .overlay-full {
    display: none; position: fixed; inset: 0;
    background: rgba(5,2,20,0.95); backdrop-filter: blur(10px);
    z-index: 820; align-items: center; justify-content: center; flex-direction: column;
  }
  .overlay-full.open { display: flex; }

  /* ‚îÄ‚îÄ CHEAT PANEL ‚îÄ‚îÄ */
  #cheat-panel {
    display: none; position: fixed; bottom: 12px; right: 12px;
    background: rgba(10,6,30,0.97); border: 1px solid rgba(255,214,10,0.35);
    border-radius: 14px; padding: 14px 16px; z-index: 9000;
    box-shadow: 0 0 30px rgba(255,214,10,0.15), 0 8px 32px rgba(0,0,0,0.6);
    min-width: 220px; font-family: 'Nunito', sans-serif;
  }
  #cheat-panel.open { display: block; }
  .cheat-title {
    font-size: 10px; letter-spacing: 2px; color: rgba(255,214,10,0.8);
    font-weight: 900; text-align: center; margin-bottom: 10px;
    position: relative;
  }
  .cheat-row { display: flex; gap: 8px; margin-bottom: 6px; align-items: center; }
  .cheat-row label { font-size: 10px; color: var(--dim); width: 110px; flex-shrink: 0; }
  .cheat-btns { display: flex; gap: 5px; flex: 1; justify-content: flex-end; }
  .cheat-btn.slime { background: rgba(90,200,250,0.25); border: 1px solid rgba(90,200,250,0.5); color: #5ac8fa; }
  .cheat-btn {
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    padding: 4px 10px; border-radius: 8px; cursor: pointer; border: none;
    transition: filter .15s, transform .1s;
  }
  .cheat-btn:hover { filter: brightness(1.2); transform: scale(1.05); }
  .cheat-btn:active { transform: scale(0.97); }
  .cheat-btn.gold  { background: linear-gradient(135deg,#fbbf24,#d97706); color:#000; }
  .cheat-btn.bio   { background: linear-gradient(135deg,#4ade80,#16a34a); color:#000; }
  .cheat-btn.res   { background: linear-gradient(135deg,#818cf8,#4338ca); color:#fff; }
  .cheat-btn.wave  { background: linear-gradient(135deg,#f472b6,#be185d); color:#fff; }
  .cheat-btn.fill  { background: linear-gradient(135deg,#60a5fa,#1d4ed8); color:#fff; }
  .cheat-sep { border: none; border-top: 1px solid rgba(255,255,255,0.07); margin: 8px 0; }
  .version-badge { cursor: pointer; }
  .version-badge:hover { opacity: 0.8; }

  /* ‚îÄ‚îÄ HEADER BUTTONS FLOAT ANIMATION ‚îÄ‚îÄ */
  @keyframes btn-float {
    0%, 100% { transform: translateY(0px); }
    50%       { transform: translateY(-3px); }
  }
  @keyframes btn-float-slow {
    0%, 100% { transform: translateY(0px); }
    50%       { transform: translateY(-2px); }
  }
  @keyframes title-bounce {
    0%, 100% { transform: translateY(0px); }
    40%       { transform: translateY(-4px); }
    60%       { transform: translateY(-2px); }
  }
  @keyframes letter-bounce {
    0%, 70%, 100% { transform: translateY(0px); }
    40%            { transform: translateY(-6px); }
    55%            { transform: translateY(-2px); }
  }
  .tl {
    display: inline-block;
    background: linear-gradient(135deg, #ffd60a, #ff9f0a, #ff6b9d);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: letter-bounce 2.4s ease-in-out infinite;
  }
  .title-text { white-space: nowrap; }
  @keyframes chip-bob {
    0%, 100% { transform: translateY(0px); }
    50%       { transform: translateY(-2px); }
  }

  /* BUY button */
  .btn-start:not(:disabled):not(.fighting) {
    animation: btn-float 2.6s ease-in-out infinite;
  }

  /* AUTO button */
  .btn-automerge {
    animation: btn-float-slow 3.0s ease-in-out infinite;
  }
  .btn-automerge.active {
    animation: btn-float-slow 1.8s ease-in-out infinite;
  }

  /* LAB button */
  .btn-lab {
    animation: btn-float-slow 3.5s ease-in-out infinite 0.4s;
  }

  /* Synergy chips */
  .syn-chip {
    animation: chip-bob 2.8s ease-in-out infinite;
  }
  .syn-chip:nth-child(2) { animation-delay: 0.4s; }
  .syn-chip:nth-child(3) { animation-delay: 0.8s; }
  .syn-chip:nth-child(4) { animation-delay: 1.2s; }
  .syn-chip:nth-child(5) { animation-delay: 1.6s; }

  .btn-shop-open {
    animation: btn-float 2.8s ease-in-out infinite;
  }
  .btn-sound[id="btn-ranks"] {
    animation: btn-float-slow 3.4s ease-in-out infinite;
    animation-delay: 0.6s;
  }
  .btn-sfx {
    animation: btn-float-slow 3.8s ease-in-out infinite;
    animation-delay: 1.1s;
  }
  .header-pill-group {
    animation: btn-float-slow 4.1s ease-in-out infinite;
    animation-delay: 0.3s;
  }
  /* Pause animation on hover */
  .btn-shop-open:hover,
  .btn-sound:hover,
  .btn-sfx:hover,
  .header-pill-group:hover {
    animation-play-state: paused;
  }

  /* ‚îÄ‚îÄ UPGRADE CAN-BUY PULSE ‚îÄ‚îÄ */
  @keyframes upgrade-pulse {
    0%, 100% { transform: translateY(0px); box-shadow: 0 0 0 rgba(76,217,100,0); }
    30%       { transform: translateY(-2px); box-shadow: 0 4px 16px rgba(76,217,100,0.25); }
    60%       { transform: translateY(0px); }
  }
  .upgrade-item.can-buy {
    animation: upgrade-pulse 2.2s ease-in-out infinite;
  }
  .upgrade-item.can-buy:hover {
    animation-play-state: paused;
  }

  .relic-modal  { max-width: 720px; width: 95%; text-align: center; }
  .relic-title  {
    font-family: 'Fredoka One', sans-serif; font-size: 28px;
    background: linear-gradient(135deg, var(--yellow), var(--orange));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    margin-bottom: 6px; filter: drop-shadow(0 2px 8px rgba(255,214,10,0.4));
  }
  .relic-sub   { font-size: 12px; color: var(--text2); margin-bottom: 20px; }
  .relic-cards { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
  .relic-card  {
    background: linear-gradient(160deg, rgba(61,43,133,0.9), rgba(42,29,94,0.9));
    border: 2px solid rgba(255,255,255,0.12); border-radius: 16px;
    padding: 22px 18px; width: 230px; cursor: pointer; transition: all 0.18s; text-align: left;
  }
  .relic-card:hover {
    border-color: var(--yellow);
    box-shadow: 0 8px 30px rgba(255,214,10,0.2);
    transform: translateY(-4px) scale(1.02);
  }
  .relic-card-name { font-family: 'Fredoka One', sans-serif; font-size: 17px; color: var(--yellow); margin-bottom: 10px; line-height: 1.4; }
  .relic-card-desc { font-size: 13px; color: var(--text2); line-height: 1.7; }

  .event-modal  { max-width: 700px; width: 95%; text-align: center; }
  .event-title  {
    font-family: 'Fredoka One', sans-serif; font-size: 28px;
    color: var(--yellow); letter-spacing: 2px; margin-bottom: 6px;
    text-shadow: 0 2px 8px rgba(255,214,10,0.5);
  }
  .event-sub   { font-size: 14px; color: var(--text2); margin-bottom: 18px; }
  .event-cards { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; margin-bottom: 14px; }

  /* Base card */
  .event-card  {
    background: linear-gradient(160deg, rgba(20,12,50,0.95), rgba(12,6,30,0.95));
    border: 2px solid rgba(255,255,255,0.12); border-radius: 16px;
    padding: 20px 16px; width: 210px; cursor: pointer;
    transition: all 0.20s ease; text-align: left;
    position: relative; overflow: hidden;
  }
  /* Sheen sweep on hover */
  .event-card::before {
    content: ''; position: absolute; inset: 0; border-radius: 14px;
    background: linear-gradient(130deg, rgba(255,255,255,0.08) 0%, transparent 60%);
    opacity: 0; transition: opacity 0.2s; pointer-events: none;
  }
  .event-card:hover::before { opacity: 1; }
  .event-card:hover { transform: translateY(-4px) scale(1.02); }

  /* Per-event accent colours */
  .event-card[data-id="shield_wave"] {
    border-color: rgba(148,163,184,0.5);
    background: linear-gradient(160deg, rgba(15,23,42,0.97), rgba(30,41,59,0.97));
  }
  .event-card[data-id="shield_wave"]:hover {
    border-color: #e2e8f0;
    box-shadow: 0 0 24px rgba(148,163,184,0.5), 0 8px 20px rgba(0,0,0,0.4);
  }
  .event-card[data-id="regen_pulse"] {
    border-color: rgba(74,222,128,0.45);
    background: linear-gradient(160deg, rgba(5,46,22,0.97), rgba(20,83,45,0.90));
  }
  .event-card[data-id="regen_pulse"]:hover {
    border-color: #4ade80;
    box-shadow: 0 0 24px rgba(74,222,128,0.5), 0 8px 20px rgba(0,0,0,0.4);
  }
  .event-card[data-id="gold_rain"] {
    border-color: rgba(250,204,21,0.45);
    background: linear-gradient(160deg, rgba(66,32,6,0.97), rgba(120,53,15,0.90));
  }
  .event-card[data-id="gold_rain"]:hover {
    border-color: #fbbf24;
    box-shadow: 0 0 24px rgba(251,191,36,0.5), 0 8px 20px rgba(0,0,0,0.4);
  }
  .event-card[data-id="crit_aura"] {
    border-color: rgba(251,113,133,0.45);
    background: linear-gradient(160deg, rgba(76,5,25,0.97), rgba(136,19,55,0.90));
  }
  .event-card[data-id="crit_aura"]:hover {
    border-color: #fb7185;
    box-shadow: 0 0 24px rgba(251,113,133,0.5), 0 8px 20px rgba(0,0,0,0.4);
  }
  .event-card[data-id="overclock"] {
    border-color: rgba(96,165,250,0.45);
    background: linear-gradient(160deg, rgba(7,21,68,0.97), rgba(29,78,216,0.80));
  }
  .event-card[data-id="overclock"]:hover {
    border-color: #60a5fa;
    box-shadow: 0 0 24px rgba(96,165,250,0.5), 0 8px 20px rgba(0,0,0,0.4);
  }
  .event-card[data-id="toxic_field"] {
    border-color: rgba(163,230,53,0.45);
    background: linear-gradient(160deg, rgba(26,46,5,0.97), rgba(54,83,20,0.90));
  }
  .event-card[data-id="toxic_field"]:hover {
    border-color: #a3e635;
    box-shadow: 0 0 24px rgba(163,230,53,0.5), 0 8px 20px rgba(0,0,0,0.4);
  }
  .event-card[data-id="elite"] {
    border-color: rgba(251,191,36,0.55);
    background: linear-gradient(160deg, rgba(55,32,0,0.97), rgba(100,60,0,0.90));
  }
  .event-card[data-id="elite"]:hover {
    border-color: #fbbf24;
    box-shadow: 0 0 28px rgba(251,191,36,0.7), 0 8px 20px rgba(0,0,0,0.4);
  }
  .event-card[data-id="meteor"] {
    border-color: rgba(249,115,22,0.45);
    background: linear-gradient(160deg, rgba(67,20,7,0.97), rgba(124,45,18,0.90));
  }
  .event-card[data-id="meteor"]:hover {
    border-color: #f97316;
    box-shadow: 0 0 24px rgba(249,115,22,0.5), 0 8px 20px rgba(0,0,0,0.4);
  }

  .event-card-name { font-family: 'Fredoka One', sans-serif; font-size: 18px; color: var(--yellow); margin-bottom: 10px; }
  .event-card-desc { font-size: 14px; color: var(--text2); line-height: 1.7; }
  .btn-event-skip {
    padding: 8px 24px; background: rgba(255,255,255,0.07);
    border: 1px solid rgba(255,255,255,0.15); color: var(--text2);
    font-family: 'Fredoka One', sans-serif; font-size: 12px;
    cursor: pointer; transition: all 0.15s; border-radius: 10px;
  }
  .btn-event-skip:hover { background: rgba(255,255,255,0.14); color: #fff; }

  /* ‚îÄ‚îÄ EVENT VFX OVERLAY ‚îÄ‚îÄ */
  #event-vfx {
    position: absolute; inset: 0;
    pointer-events: none; z-index: 50;
    border-radius: inherit;
  }

  /* ‚îÄ‚îÄ LOSE SCREEN ‚îÄ‚îÄ */
  .lose-screen {
    display: none; position: fixed; inset: 0; z-index: 800;
    background: rgba(10,3,30,0.96); backdrop-filter: blur(12px);
    align-items: center; justify-content: center; flex-direction: column; gap: 14px;
  }
  .lose-screen.visible { display: flex; }
  .lose-title {
    font-family: 'Fredoka One', sans-serif; font-size: 42px;
    color: var(--pink); letter-spacing: 3px;
    text-shadow: 0 4px 0 var(--pink2), 0 0 40px rgba(255,107,157,0.5);
    animation: lose-flicker 1.5s infinite;
  }
  @keyframes lose-flicker {
    0%,96%,100% { opacity: 1; }
    97%          { opacity: 0.4; }
    98%          { opacity: 1; }
    99%          { opacity: 0.2; }
  }
  .lose-stat { font-family: 'Fredoka One', sans-serif; font-size: 18px; color: var(--text2); }
  .btn-lose {
    padding: 14px 32px; font-family: 'Fredoka One', sans-serif;
    font-size: 17px; letter-spacing: 1px; border: none;
    border-radius: 16px; cursor: pointer; transition: all 0.1s;
    position: relative; outline: none;
  }
  .btn-lose::after {
    content: ''; position: absolute; inset: 0; border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 60%);
    pointer-events: none;
  }
  .btn-lose:active { transform: translateY(3px); }
  .btn-lose-retry {
    background: linear-gradient(160deg, var(--green), var(--green2));
    box-shadow: 0 5px 0 #1a5e2a, 0 6px 20px rgba(76,217,100,0.4); color: #fff;
  }
  .btn-lose-revive {
    background: linear-gradient(160deg, #5ac8fa, #2a7fa8);
    box-shadow: 0 5px 0 #1a5070, 0 0 30px rgba(90,200,250,0.4);
    color: #fff;
  }
  .btn-lose-revive:hover { filter: brightness(1.15); }
  .btn-lose-revive:disabled { opacity: 0.4; filter: grayscale(0.5); cursor: default; box-shadow: none; }

  /* ‚îÄ‚îÄ LIVES SYSTEM ‚îÄ‚îÄ */
  .lives-bar {
    display: flex; gap: 10px; align-items: center;
    padding: 4px 0;
  }
  .life-heart {
    font-size: 22px; transition: all 0.3s;
    filter: drop-shadow(0 0 6px rgba(255,107,157,0.8));
  }
  .life-heart.empty {
    filter: none; opacity: 0.25;
    position: relative;
  }
  .life-heart.regen {
    filter: drop-shadow(0 0 4px rgba(255,214,10,0.6));
    animation: heart-regen 1s ease-in-out infinite alternate;
  }
  @keyframes heart-regen {
    from { transform: scale(0.9); opacity: 0.5; }
    to   { transform: scale(1.0); opacity: 0.9; }
  }
  .life-regen-timer {
    font-family: 'Fredoka One', sans-serif; font-size: 10px;
    color: rgba(255,214,10,0.7); margin-top: 2px; text-align: center;
  }
  .lives-wrap { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .lose-no-lives {
    font-family: 'Fredoka One', sans-serif; font-size: 13px;
    color: rgba(255,107,157,0.7); letter-spacing: 0.5px; margin-top: -6px;
  }

  /* ‚îÄ‚îÄ WIN SCREEN ‚îÄ‚îÄ */
  .win-screen {
    display: none; position: fixed; inset: 0; z-index: 800;
    background: rgba(5,10,30,0.96); backdrop-filter: blur(12px);
    align-items: center; justify-content: center; flex-direction: column; gap: 14px;
  }
  .win-screen.visible { display: flex; }
  .win-title {
    font-family: 'Fredoka One', sans-serif; font-size: 46px;
    background: linear-gradient(135deg, var(--yellow), var(--orange), var(--pink));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    filter: drop-shadow(0 4px 16px rgba(255,214,10,0.5));
    animation: win-rainbow 2s infinite;
  }
  @keyframes win-rainbow {
    0%  { filter: drop-shadow(0 4px 16px rgba(255,214,10,0.6)); }
    50% { filter: drop-shadow(0 4px 24px rgba(255,107,157,0.8)); }
    100%{ filter: drop-shadow(0 4px 16px rgba(255,214,10,0.6)); }
  }
  .win-stat { font-family: 'Fredoka One', sans-serif; font-size: 18px; color: var(--text2); }
  .btn-win {
    padding: 14px 32px; font-family: 'Fredoka One', sans-serif;
    font-size: 17px; letter-spacing: 1px; border: none;
    border-radius: 16px; cursor: pointer; transition: all 0.1s; position: relative; outline: none;
  }
  .btn-win::after {
    content: ''; position: absolute; inset: 0; border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 60%);
    pointer-events: none;
  }
  .btn-win:active { transform: translateY(3px); }
  .btn-win-continue {
    background: linear-gradient(160deg, var(--blue), var(--blue2));
    box-shadow: 0 5px 0 #004aaa, 0 6px 20px rgba(90,200,250,0.4); color: #fff;
  }
  .btn-win-prestige {
    background: linear-gradient(160deg, var(--purple), var(--purple2));
    box-shadow: 0 5px 0 #4a0090, 0 6px 20px rgba(191,90,242,0.4); color: #fff;
  }

  /* ‚îÄ‚îÄ TUTORIAL OVERLAY ‚îÄ‚îÄ */
  /* ‚îÄ‚îÄ TUTORIAL ‚îÄ‚îÄ */

  /* ‚îÄ‚îÄ INTRO SCREEN CARDS ‚îÄ‚îÄ */
  .tut-intro-card {
    background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1);
    border-radius: 14px; padding: 14px 10px; text-align: center;
    transition: background 0.2s;
  }
  .tut-intro-icon { font-size: 24px; margin-bottom: 6px; }
  .tut-intro-label { font-family: 'Fredoka One', sans-serif; font-size: 11px; color: rgba(255,255,255,0.7); letter-spacing: 0.5px; }

  /* ‚îÄ‚îÄ INTERACTIVE TUTORIAL TOOLTIP ‚îÄ‚îÄ */
  #itut-box {
    filter: drop-shadow(0 8px 32px rgba(0,0,0,0.8));
  }
  #itut-inner {
    background: linear-gradient(145deg, rgba(18,12,30,0.98), rgba(10,8,22,0.98));
    border: 1.5px solid rgba(90,200,250,0.5);
    border-radius: 18px; padding: 18px 18px 14px;
    position: relative;
    box-shadow: 0 0 40px rgba(90,200,250,0.12), 0 0 0 1px rgba(90,200,250,0.08);
  }
  #itut-step-indicator {
    font-family: 'Nunito', sans-serif; font-size: 9px; font-weight: 900;
    color: rgba(90,200,250,0.6); letter-spacing: 2px; margin-bottom: 8px;
    text-transform: uppercase;
  }
  #itut-icon { font-size: 28px; margin-bottom: 8px; text-align: center; }
  #itut-title {
    font-family: 'Fredoka One', sans-serif; font-size: 16px; color: #fff;
    letter-spacing: 1px; margin-bottom: 8px; text-align: center;
  }
  #itut-desc {
    font-family: 'Nunito', sans-serif; font-size: 12px; line-height: 1.6;
    color: rgba(255,255,255,0.75); text-align: center; margin-bottom: 10px;
  }
  #itut-desc strong { color: #fff; }
  #itut-desc .hi { color: var(--blue); font-weight: 700; }
  #itut-action-hint {
    background: rgba(90,200,250,0.1); border: 1px solid rgba(90,200,250,0.25);
    border-radius: 10px; padding: 7px 12px;
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    color: var(--blue); text-align: center; letter-spacing: 0.5px;
    margin-bottom: 10px; min-height: 28px;
  }
  #itut-skip {
    display: block; margin: 0 auto; background: none; border: none;
    font-family: 'Nunito', sans-serif; font-size: 9px; font-weight: 700;
    color: rgba(255,255,255,0.2); cursor: pointer; letter-spacing: 1px;
    text-transform: uppercase; transition: color 0.2s; padding: 2px 0;
  }
  #itut-skip:hover { color: rgba(255,255,255,0.5); }

  /* Arrow pointing at target */
  #itut-arrow {
    position: absolute; width: 14px; height: 14px;
    background: rgba(18,12,30,0.98); border: 1.5px solid rgba(90,200,250,0.5);
    transform: rotate(45deg);
  }

  /* Highlight ring around target element */
  .itut-highlight {
    position: relative; z-index: 3999;
    box-shadow: 0 0 0 3px rgba(90,200,250,0.8), 0 0 0 6px rgba(90,200,250,0.25), 0 0 30px rgba(90,200,250,0.4) !important;
    border-radius: 12px;
    animation: itut-pulse 1.5s ease-in-out infinite;
  }
  @keyframes itut-pulse {
    0%, 100% { box-shadow: 0 0 0 3px rgba(90,200,250,0.8), 0 0 0 6px rgba(90,200,250,0.2), 0 0 20px rgba(90,200,250,0.3); }
    50%       { box-shadow: 0 0 0 3px rgba(90,200,250,1),   0 0 0 9px rgba(90,200,250,0.3), 0 0 40px rgba(90,200,250,0.5); }
  }

  /* Progress dots */
  .itut-dots { display: flex; justify-content: center; gap: 5px; margin-bottom: 10px; }
  .itut-dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: rgba(255,255,255,0.2); transition: all 0.3s;
  }
  .itut-dot.done  { background: rgba(90,200,250,0.5); }
  .itut-dot.active{ background: var(--blue); transform: scale(1.4); box-shadow: 0 0 6px var(--blue); }

  .tutorial-overlay {
    display: none; position: fixed; inset: 0;
    background: rgba(4,1,18,0.97); backdrop-filter: blur(14px);
    z-index: 900; align-items: center; justify-content: center;
    padding: 12px;
  }
  .tutorial-overlay.visible { display: flex; }

  .tutorial-box {
    background: linear-gradient(160deg, #1c0a42 0%, #110620 70%, #0a0318 100%);
    border: 1.5px solid rgba(255,255,255,0.13);
    border-radius: 24px;
    padding: 30px 26px 22px;
    max-width: 580px; width: 100%;
    max-height: 92vh; overflow-y: auto;
    box-shadow: 0 0 80px rgba(191,90,242,0.2), 0 24px 80px rgba(0,0,0,0.7);
  }

  .tutorial-header {
    text-align: center; margin-bottom: 22px;
  }
  .tutorial-title {
    font-family: 'Fredoka One', sans-serif; font-size: 30px;
    background: linear-gradient(135deg, #ffd700, #ff9500);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
    letter-spacing: 2px; margin-bottom: 6px;
  }
  .tutorial-subtitle {
    font-family: 'Nunito', sans-serif; font-size: 14px;
    color: rgba(255,255,255,0.45); line-height: 1.5;
  }

  /* Step cards */
  .tutorial-steps { display: flex; flex-direction: column; gap: 10px; margin-bottom: 18px; }
  .tutorial-step {
    display: flex; align-items: flex-start; gap: 14px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 14px; padding: 14px 16px;
    transition: border-color .2s, background .2s;
    text-align: left;
  }
  .tutorial-step:hover {
    border-color: rgba(255,214,10,0.25);
    background: rgba(255,214,10,0.03);
  }
  .tutorial-step-icon {
    font-size: 24px; flex-shrink: 0;
    width: 48px; height: 48px; border-radius: 12px;
    display: flex; align-items: center; justify-content: center;
    background: rgba(255,255,255,0.06);
  }
  .tutorial-step-body { flex: 1; }
  .tutorial-step-title {
    font-family: 'Fredoka One', sans-serif;
    font-size: 17px; color: var(--yellow);
    margin-bottom: 4px; letter-spacing: 0.3px;
  }
  .tutorial-step-desc {
    font-family: 'Nunito', sans-serif;
    font-size: 13px; color: rgba(255,255,255,0.55); line-height: 1.65;
  }
  .tutorial-step-desc strong { color: #fff; font-weight: 700; }
  .tutorial-step-desc .tag { 
    display: inline-block; background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 6px; padding: 1px 6px; font-size: 11px;
    font-family: 'Fredoka One', sans-serif; letter-spacing: 0.5px;
  }

  /* Tips strip */
  .tutorial-tips-row {
    display: flex; flex-wrap: wrap; gap: 7px; margin-bottom: 20px;
  }
  .tutorial-tip-chip {
    background: rgba(90,200,250,0.07);
    border: 1px solid rgba(90,200,250,0.18);
    border-radius: 20px; padding: 6px 13px;
    font-family: 'Nunito', sans-serif;
    font-size: 12px; color: #7dd4fc; line-height: 1.4;
  }

  /* Start button */
  .btn-tutorial-start {
    width: 100%; padding: 17px;
    background: linear-gradient(160deg, #4cd964, #26a843);
    box-shadow: 0 6px 0 #1a5e2a, 0 8px 28px rgba(76,217,100,0.4);
    color: #fff; font-family: 'Fredoka One', sans-serif;
    font-size: 20px; letter-spacing: 1.5px;
    border: none; border-radius: 16px; cursor: pointer;
    transition: all .1s; position: relative; overflow: hidden;
  }
  .btn-tutorial-start::after {
    content: ''; position: absolute; inset: 0; border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.18) 0%, transparent 55%);
    pointer-events: none;
  }
  .btn-tutorial-start:hover  { filter: brightness(1.1); }
  .btn-tutorial-start:active { transform: translateY(4px); box-shadow: 0 2px 0 #1a5e2a; }

  /* ‚îÄ‚îÄ NOTIFICATIONS ‚îÄ‚îÄ */
  #notif-area {
    position: absolute; top: 8px; left: 8px;
    width: 200px;
    display: flex; flex-direction: column; gap: 5px;
    padding: 0;
    z-index: 700; pointer-events: none;
    box-sizing: border-box;
  }
  /* ‚îÄ‚îÄ WAVE CLEARED BANNER ‚îÄ‚îÄ */
  #wave-cleared-banner {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.7);
    z-index: 800;
    text-align: center;
    pointer-events: none;
  }
  #wave-cleared-banner.show {
    display: block;
    animation: wcb-in 0.35s cubic-bezier(0.34,1.56,0.64,1) forwards,
               wcb-out 0.4s ease-in 1.8s forwards;
  }
  @keyframes wcb-in {
    from { opacity:0; transform: translate(-50%,-50%) scale(0.5); }
    to   { opacity:1; transform: translate(-50%,-50%) scale(1); }
  }
  @keyframes wcb-out {
    from { opacity:1; transform: translate(-50%,-50%) scale(1); }
    to   { opacity:0; transform: translate(-50%,-50%) scale(1.1); }
  }
  .wcb-wave {
    font-family: 'Fredoka One', sans-serif;
    font-size: 22px; letter-spacing: 4px;
    color: rgba(255,255,255,0.7);
    text-transform: uppercase;
    margin-bottom: 4px;
  }
  .wcb-title {
    font-family: 'Fredoka One', sans-serif;
    font-size: 52px; letter-spacing: 2px;
    background: linear-gradient(135deg, #4ade80, #22c55e, #86efac);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.1;
    filter: drop-shadow(0 0 20px rgba(74,222,128,0.6));
  }
  .wcb-gold {
    font-family: 'Fredoka One', sans-serif;
    font-size: 30px;
    color: #fbbf24;
    margin-top: 8px;
    filter: drop-shadow(0 0 10px rgba(251,191,36,0.5));
  }

  .notif {
    padding: 8px 14px; border-radius: 14px;
    font-family: 'Fredoka One', sans-serif; font-size: 12px; font-weight: 400;
    color: #fff; backdrop-filter: blur(6px);
    animation: notif-in 0.25s ease-out, notif-out 0.3s ease-in 1.7s forwards;
    background: rgba(30,15,70,0.95);
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    text-align: center;
  }
  @keyframes notif-in  { from { opacity:0; transform:translateY(10px) scale(0.92); } to { opacity:1; transform:none; } }
  @keyframes notif-out { from { opacity:1; } to { opacity:0; transform:translateY(-6px); } }

  /* ‚îÄ‚îÄ COMBAT LOG ‚îÄ‚îÄ */
  .combat-log {
    flex: 1; overflow-y: auto; padding: 8px 10px;
    display: flex; flex-direction: column; gap: 2px;
    font-family: 'Fredoka One', sans-serif; font-size: 11px; letter-spacing: 0.4px;
  }
  .combat-log::-webkit-scrollbar { width: 3px; }
  .combat-log::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
  .log-entry { padding: 3px 0; color: var(--text2); line-height: 1.4; font-family: 'Fredoka One', sans-serif; }
  .log-entry.log-wave { color: var(--blue); }
  .log-entry.log-gold { color: var(--yellow); }
  .log-entry.log-merge{ color: var(--green); }
  .log-entry.log-dmg  { color: rgba(255,107,157,0.8); }
  .log-entry.log-boss { color: var(--orange); font-weight: 700; }
  .log-entry.log-mutant{ color: var(--pink); }

  /* ‚îÄ‚îÄ ECONOMY HINT ‚îÄ‚îÄ */
  .economy-hint {
    font-size: 10px; color: var(--text2); padding: 4px 10px;
    border-bottom: 1px solid var(--border);
    font-family: 'Fredoka One', sans-serif; letter-spacing: 0.5px;
  }

  /* ‚îÄ‚îÄ WAVE TIMER ‚îÄ‚îÄ */
  .wave-timer { font-family: 'Fredoka One', sans-serif; font-size: 15px; color: var(--text2); min-width: 40px; text-align: center; }
  .wave-timer.urgent { color: var(--pink); animation: timer-urgent 0.4s infinite alternate; }
  @keyframes timer-urgent { from { color: var(--pink); } to { color: var(--red); transform: scale(1.1); } }

  /* ‚îÄ‚îÄ WAVE LABEL ‚îÄ‚îÄ */
  #wave-label-full {
    font-family: 'Fredoka One', sans-serif; font-size: 14px;
    color: var(--blue);
  }

  /* ‚îÄ‚îÄ RESET BUTTON ‚îÄ‚îÄ */
  .btn-reset {
    padding: 3px 10px;
    background: transparent; border: 1px solid rgba(255,67,58,0.2);
    color: rgba(255,67,58,0.4); font-family: 'Nunito', sans-serif;
    font-size: 9px; font-weight: 700; letter-spacing: 1px;
    border-radius: 8px; cursor: pointer; transition: all 0.2s;
  }
  .btn-reset:hover { background: rgba(255,67,58,0.12); color: rgba(255,67,58,0.85); border-color: rgba(255,67,58,0.5); }

  /* ‚îÄ‚îÄ SOUND TOGGLE ‚îÄ‚îÄ */
  .btn-sound {
    padding: 6px 12px;
    background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
    color: rgba(255,255,255,0.5); font-family: 'Fredoka One', sans-serif; font-size: 11px;
    border-radius: 12px; cursor: pointer; transition: all 0.15s; white-space: nowrap;
  }
  .btn-sound:hover { background: rgba(255,255,255,0.12); color: #fff; }


  /* ‚îÄ‚îÄ VOLUME PANEL ‚îÄ‚îÄ */
  .sound-wrap { position: relative; display: inline-block; }
  .vol-panel {
    display: none; position: absolute; top: calc(100% + 8px); right: 0;
    background: rgba(18,18,28,0.97); border: 1px solid rgba(90,200,250,0.35);
    border-radius: 14px; padding: 14px 16px; width: 200px; z-index: 9999;
    box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 20px rgba(90,200,250,0.1);
    backdrop-filter: blur(12px);
  }
  .vol-panel.open { display: block; }
  .vol-panel::before {
    content: ''; position: absolute; top: -6px; right: 16px;
    width: 10px; height: 10px; background: rgba(18,18,28,0.97);
    border-left: 1px solid rgba(90,200,250,0.35);
    border-top: 1px solid rgba(90,200,250,0.35);
    transform: rotate(45deg);
  }
  .vol-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
  .vol-row:last-child { margin-bottom: 0; }
  .vol-label {
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    color: var(--text2); width: 40px; flex-shrink: 0; letter-spacing: 0.5px;
  }
  .vol-slider {
    flex: 1; -webkit-appearance: none; appearance: none;
    height: 4px; border-radius: 4px; outline: none; cursor: pointer;
    background: linear-gradient(to right, var(--blue) 0%, var(--blue) 50%, rgba(255,255,255,0.15) 50%);
  }
  .vol-slider::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    border-radius: 50%; background: #fff; cursor: pointer;
    box-shadow: 0 0 6px rgba(90,200,250,0.6);
  }
  .vol-slider::-moz-range-thumb {
    width: 14px; height: 14px; border-radius: 50%; background: #fff;
    cursor: pointer; border: none; box-shadow: 0 0 6px rgba(90,200,250,0.6);
  }
  .vol-val {
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    color: var(--blue); width: 28px; text-align: right; flex-shrink: 0;
  }




  /* ‚îÄ‚îÄ HEADER PILL BUTTONS ‚îÄ‚îÄ */
  .header-pill-group {
    display: flex; align-items: center;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px; overflow: hidden;
    flex-shrink: 0;
  }
    /* .lang-btn removed */
  .lang-btn-old {
    padding: 6px 10px;
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    cursor: pointer; border: none; border-right: 1px solid rgba(255,255,255,0.08);
    background: transparent; color: rgba(255,255,255,0.4);
    transition: all 0.15s; letter-spacing: 0.5px; white-space: nowrap;
  }
    /* .lang-btn removed */
  .lang-btn-old:last-child { border-right: none; }
    /* .lang-btn removed */
  .lang-btn-old:hover { background: rgba(255,255,255,0.1); color: #fff; }
    /* .lang-btn removed */
  .lang-btn-old.active { background: rgba(90,200,250,0.2); color: #5ac8fa; }

  .btn-sfx {
    display: flex; align-items: center; gap: 5px;
    padding: 6px 12px;
    background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px; color: rgba(255,255,255,0.5);
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    cursor: pointer; transition: all 0.15s; white-space: nowrap; flex-shrink: 0;
  }
  .btn-sfx:hover { background: rgba(255,255,255,0.12); color: #fff; border-color: rgba(255,255,255,0.25); }
  .btn-sfx.on { background: rgba(90,200,250,0.15); border-color: rgba(90,200,250,0.4); color: #5ac8fa; }

  /* ‚îÄ‚îÄ NIGHTMARE WAVE ‚îÄ‚îÄ */
  .nightmare-banner {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Fredoka One', sans-serif;
    font-size: 36px; color: #ff2060;
    text-shadow: 0 0 30px #ff2060, 0 0 60px rgba(255,32,96,0.6), 0 4px 0 #7a0020;
    letter-spacing: 3px; pointer-events: none; z-index: 200; text-align: center;
    animation: nightmare-anim 3s ease-out forwards; white-space: nowrap;
  }
  .nightmare-banner span { display:block; font-size:16px; color:#ff8aad; letter-spacing:2px; margin-top:4px; }
  @keyframes nightmare-anim {
    0%   { opacity:0; transform:translate(-50%,-50%) scale(0.2) rotate(-5deg); filter:blur(8px); }
    15%  { opacity:1; transform:translate(-50%,-50%) scale(1.2) rotate(1deg); filter:blur(0); }
    70%  { opacity:1; transform:translate(-50%,-50%) scale(1); }
    100% { opacity:0; transform:translate(-50%,-50%) scale(0.9); }
  }
  .btn-start.nightmare-wave {
    background: linear-gradient(160deg, #ff2060, #7a0020) !important;
    box-shadow: 0 6px 0 #3d0010, 0 0 30px rgba(255,32,96,0.5) !important;
    animation: nightmare-pulse 0.8s ease-in-out infinite alternate !important;
  }
  @keyframes nightmare-pulse {
    from { box-shadow: 0 6px 0 #3d0010, 0 0 20px rgba(255,32,96,0.4); }
    to   { box-shadow: 0 6px 0 #3d0010, 0 0 50px rgba(255,32,96,0.9), 0 0 80px rgba(255,32,96,0.3); }
  }
  .nightmare-debuff-bar {
    position: absolute; bottom: 6px; left: 8px; right: 8px;
    background: rgba(255,32,96,0.12); border: 1px solid rgba(255,32,96,0.3);
    border-radius: 6px; padding: 4px 8px; font-size: 10px;
    font-family: 'Fredoka One', sans-serif; color: #ff8aad;
    display: none; z-index: 10;
  }
  .nightmare-debuff-bar.active { display: block; }

  /* ‚îÄ‚îÄ LEADERBOARD MODAL ‚îÄ‚îÄ */
    .lb-overlay {
    display:none; position:fixed; inset:0; z-index:10000;
    background:rgba(0,0,0,0.8); backdrop-filter:blur(6px);
    align-items:center; justify-content:center;
  }
  .lb-overlay.open { display:flex; }
  .lb-modal {
    background:linear-gradient(160deg,rgba(22,14,32,0.98),rgba(12,8,20,0.98));
    border:1px solid rgba(255,32,96,0.35);
    border-radius:20px; padding:24px 22px 18px;
    width:min(440px,92vw); max-height:85vh;
    box-shadow:0 0 60px rgba(255,32,96,0.15), 0 20px 60px rgba(0,0,0,0.6);
    display:flex; flex-direction:column; gap:0;
  }
  .lb-title {
    font-family:'Fredoka One',sans-serif; font-size:22px;
    color:#fff; text-align:center; letter-spacing:2px;
    text-shadow:0 0 20px rgba(255,32,96,0.6);
  }
  .lb-subtitle {
    font-family:'Nunito',sans-serif; font-size:10px;
    color:rgba(255,32,96,0.6); text-align:center; letter-spacing:3px;
    margin-bottom:14px; margin-top:2px;
  }
  .lb-entry-form { display:flex; gap:8px; margin-bottom:8px; }
  .lb-nick-input {
    flex:1; padding:8px 12px;
    background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.15);
    border-radius:10px; color:#fff; font-family:'Nunito',sans-serif; font-size:13px;
    outline:none; pointer-events:auto; user-select:text; -webkit-user-select:text;
    cursor:text;
  }
  .lb-nick-input:focus { border-color:rgba(255,32,96,0.5); box-shadow:0 0 0 2px rgba(255,32,96,0.2); }
  .lb-submit-btn {
    padding:8px 14px; background:linear-gradient(135deg,#ff2060,#7c3aed);
    border:none; border-radius:10px; color:#fff;
    font-family:'Fredoka One',sans-serif; font-size:12px;
    cursor:pointer; letter-spacing:1px; white-space:nowrap;
  }
  .lb-submit-btn:hover { filter:brightness(1.2); }
  .lb-submit-btn:disabled { opacity:0.4; cursor:not-allowed; }
  .lb-modal {
    background: linear-gradient(160deg, #0f1020, #1a1030);
    border: 2px solid rgba(255,32,96,0.4);
    border-radius: 20px; padding: 28px 24px; width: 420px; max-width: 95vw;
    max-height: 90vh; overflow-y: auto;
    box-shadow: 0 0 60px rgba(255,32,96,0.2), 0 0 120px rgba(90,32,200,0.15);
  }
  .lb-title {
    font-family: 'Fredoka One', sans-serif; font-size: 26px; text-align: center;
    color: #ff2060; text-shadow: 0 0 20px rgba(255,32,96,0.6);
    letter-spacing: 3px; margin-bottom: 4px;
  }
  .lb-subtitle { text-align:center; font-size:11px; color:var(--dim); margin-bottom:20px; letter-spacing:1px; }
  .lb-entry-form { display:flex; gap:8px; margin-bottom:20px; }
  .lb-nick-input {
    flex:1; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.15);
    border-radius:10px; padding:8px 12px; color:#fff; font-family:'Fredoka One',sans-serif;
    font-size:14px; outline:none; pointer-events:auto; user-select:text; -webkit-user-select:text;
    cursor:text;
  }
  .lb-nick-input:focus { border-color:rgba(255,32,96,0.5); box-shadow:0 0 0 2px rgba(255,32,96,0.2); }
  .lb-submit-btn {
    padding:8px 16px; background:linear-gradient(135deg,#ff2060,#7a0020);
    border:none; border-radius:10px; color:#fff; font-family:'Fredoka One',sans-serif;
    font-size:13px; cursor:pointer; white-space:nowrap;
    box-shadow: 0 3px 0 #3d0010;
  }
  .lb-submit-btn:hover { filter:brightness(1.2); }
  .lb-submit-btn:disabled { opacity:0.4; cursor:not-allowed; }
  .lb-list { list-style:none; padding:0; margin:0; max-height:340px; overflow-y:auto; }
  .lb-list::-webkit-scrollbar { width:4px; }
  .lb-list::-webkit-scrollbar-thumb { background:rgba(255,32,96,0.4); border-radius:4px; }
  .lb-row {
    display:flex; align-items:center; gap:8px;
    padding:8px 10px; border-radius:10px; margin-bottom:4px;
    background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    transition: background 0.15s;
  }
  .lb-row:hover { background:rgba(255,255,255,0.08); }
  .lb-row.me { background:rgba(255,32,96,0.12); border-color:rgba(255,32,96,0.35); }
  .lb-rank { font-family:'Fredoka One',sans-serif; font-size:16px; width:28px; text-align:center; flex-shrink:0; }
  .lb-rank.gold   { color:#fbbf24; text-shadow:0 0 10px rgba(251,191,36,0.8); }
  .lb-rank.silver { color:#cbd5e1; text-shadow:0 0 8px rgba(203,213,225,0.6); }
  .lb-rank.bronze { color:#d97706; text-shadow:0 0 8px rgba(217,119,6,0.6); }
  .lb-name { flex:1; font-family:'Fredoka One',sans-serif; font-size:13px; color:#fff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .lb-score-col { text-align:right; flex-shrink:0; }
  .lb-score-main { font-family:'Fredoka One',sans-serif; font-size:14px; color:#ff2060; }
  .lb-score-sub  { font-size:9px; color:rgba(255,255,255,0.4); letter-spacing:0.5px; margin-top:1px; }
  .lb-loading, .lb-empty { padding:20px; text-align:center; color:rgba(255,255,255,0.4); font-size:12px; font-family:'Nunito',sans-serif; list-style:none; }
  .lb-close-btn {
    margin-top:12px; width:100%; padding:8px;
    background:rgba(255,32,96,0.15); border:1px solid rgba(255,32,96,0.35);
    color:#ff8aad; font-family:'Fredoka One',sans-serif; font-size:13px;
    border-radius:10px; cursor:pointer; transition:all 0.15s; letter-spacing:1px;
  }
  .lb-close-btn:hover { background:rgba(255,32,96,0.25); color:#fff; }
  .lb-row {
    display:flex; align-items:center; gap:10px;
    padding:9px 10px; border-radius:10px; margin-bottom:5px;
    background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    transition: background 0.2s;
  }
  .lb-row:hover { background:rgba(255,255,255,0.07); }
  .lb-row.me { background:rgba(255,32,96,0.1); border-color:rgba(255,32,96,0.3); }
  .lb-rank {
    font-family:'Fredoka One',sans-serif; font-size:14px; width:28px;
    text-align:center; color:var(--dim);
  }
  .lb-rank.gold   { color:#fbbf24; text-shadow:0 0 8px rgba(251,191,36,0.6); }
  .lb-rank.silver { color:#9ca3af; }
  .lb-rank.bronze { color:#cd8040; }
  .lb-name { font-family:'Fredoka One',sans-serif; font-size:14px; flex:1; color:#fff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .lb-score-col { text-align:right; }
  .lb-score-main { font-family:'Fredoka One',sans-serif; font-size:15px; color:#ff2060; }
  .lb-score-sub  { font-size:9px; color:var(--dim); }
  .lb-close-btn {
    display:block; margin:18px auto 0; padding:8px 28px;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.15);
    border-radius:12px; color:var(--text2); font-family:'Fredoka One',sans-serif;
    font-size:13px; cursor:pointer;
  }
  .lb-close-btn:hover { background:rgba(255,255,255,0.15); color:#fff; }
  .lb-loading { text-align:center; color:var(--dim); font-size:13px; padding:20px; }
  .lb-empty { text-align:center; color:var(--dim); font-size:12px; padding:16px; }

  /* ‚îÄ‚îÄ MERGE HINTS ‚îÄ‚îÄ */
  #merge-hints { min-height: 22px; padding: 4px 10px; font-size: 10px; color: var(--green); font-family: 'Fredoka One', sans-serif; letter-spacing: 0.5px; }

  /* ‚îÄ‚îÄ UPGRADE TABS ‚îÄ‚îÄ */
  .upgrade-tabs { display: flex; border-bottom: 1px solid var(--border); }
  .upgrade-tab {
    flex: 1; padding: 9px 4px; text-align: center;
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    color: var(--text2); cursor: pointer; border-bottom: 2px solid transparent;
    transition: all 0.15s; background: transparent; border-top: none; border-left: none; border-right: none;
  }
  .upgrade-tab.active { color: var(--yellow); border-bottom-color: var(--yellow); }
  .upgrade-tab:hover:not(.active) { color: #fff; }

  /* Skin selector */
  #skin-selector .skin-btn {
    background: rgba(255,255,255,0.04); border: 1.5px solid rgba(255,255,255,0.1);
    border-radius: 10px; padding: 7px 4px 5px; cursor: pointer; color: var(--dim);
    font-family: 'Fredoka One', sans-serif; font-size: 10px; letter-spacing: 1px;
    display: flex; flex-direction: column; align-items: center; gap: 4px;
    transition: all .15s; width: 100%;
  }
  #skin-selector .skin-btn:hover { border-color: rgba(255,255,255,0.3); color: #fff; background: rgba(255,255,255,0.08); }
  #skin-selector .skin-btn.active { border-color: #bf5af2; background: rgba(191,90,242,0.15); color: #fff; }
  .skin-dots { display: flex; gap: 3px; }
  .skin-dots span { width: 10px; height: 10px; border-radius: 50%; display: block; }
  #skin-selector button {
    padding: 6px 12px; font-family: 'Fredoka One', sans-serif; font-size: 11px;
    border: 2px solid rgba(255,255,255,0.15); border-radius: 10px;
    background: rgba(255,255,255,0.07); color: var(--text2); cursor: pointer; transition: all 0.15s;
  }
  #skin-selector button:hover { border-color: var(--yellow); color: #fff; }

  /* Skins */
  /* ‚îÄ‚îÄ SKIN: NEON ‚îÄ‚îÄ */
  body.skin-neon  { --skin-glow: #00ffea; }
  body.skin-neon  .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(0,255,234,0.14) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(255,0,255,0.10) 0%, transparent 70%) !important; }
  body.skin-neon  .panel-arena { box-shadow: inset 0 0 60px rgba(0,255,234,0.05); }

  /* ‚îÄ‚îÄ SKIN: VOID ‚îÄ‚îÄ */
  body.skin-void  { --skin-glow: #9060ff; }
  body.skin-void  .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(144,96,255,0.16) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(64,32,160,0.12) 0%, transparent 70%) !important; }

  /* ‚îÄ‚îÄ SKIN: TOXIC ‚îÄ‚îÄ */
  body.skin-toxic { --skin-glow: #aaff00; }
  body.skin-toxic .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(170,255,0,0.14) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(0,255,136,0.10) 0%, transparent 70%) !important; }

  /* ‚îÄ‚îÄ SKIN: BLOOD ‚îÄ‚îÄ */
  body.skin-blood { --skin-glow: #ff2020; }
  body.skin-blood .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(255,32,32,0.14) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(136,0,0,0.12) 0%, transparent 70%) !important; }
  body.skin-blood header { border-bottom-color: rgba(255,32,32,0.25) !important; }

  /* ‚îÄ‚îÄ SKIN: ICE ‚îÄ‚îÄ */
  body.skin-ice   { --skin-glow: #a0e8ff; }
  body.skin-ice   .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(160,232,255,0.14) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(192,240,255,0.10) 0%, transparent 70%) !important; }
  body.skin-ice   header { border-bottom-color: rgba(160,232,255,0.25) !important; }

  /* ‚îÄ‚îÄ SKIN: GOLD ‚îÄ‚îÄ */
  body.skin-gold  { --skin-glow: #ffd700; }
  body.skin-gold  .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(255,215,0,0.14) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(255,184,0,0.10) 0%, transparent 70%) !important; }
  body.skin-gold  header { border-bottom-color: rgba(255,215,0,0.25) !important; }
  body.skin-gold  .currency.gold { background: linear-gradient(135deg,#ffe040,#ffd700) !important; box-shadow: 0 3px 0 #a06000, 0 4px 18px rgba(255,215,0,0.6) !important; }

  /* ‚îÄ‚îÄ SKIN: SHADOW ‚îÄ‚îÄ */
  body.skin-shadow { --skin-glow: #9900ff; }
  body.skin-shadow .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(153,0,255,0.12) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(34,34,68,0.18) 0%, transparent 70%) !important; }
  body.skin-shadow header { border-bottom-color: rgba(153,0,255,0.25) !important; }

  /* ‚îÄ‚îÄ SKIN: CYBER ‚îÄ‚îÄ */
  body.skin-cyber { --skin-glow: #00ffcc; }
  body.skin-cyber .panel-merge::before { background: radial-gradient(ellipse 60% 40% at 30% 30%, rgba(0,255,204,0.14) 0%, transparent 70%), radial-gradient(ellipse 50% 60% at 70% 70%, rgba(255,0,170,0.10) 0%, transparent 70%) !important; }
  body.skin-cyber header { border-bottom-color: rgba(0,255,204,0.25) !important; }
  body.skin-cyber .panel-title::before { background: #00ffcc !important; box-shadow: 0 0 8px #00ffcc !important; }

  @keyframes speed-pulse {
    from { transform: scale(1); }
    to   { transform: scale(1.04) translateY(-1px); }
  }
  /* ‚îÄ‚îÄ STAT PILLS ROW ‚îÄ‚îÄ */
  .stat-pills {
    display: flex; gap: 6px; flex-wrap: wrap;
    padding: 6px 10px; border-top: 1px solid var(--border);
    flex-shrink: 0; background: rgba(0,0,0,0.15);
  }
  .stat-pill {
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    padding: 3px 10px; border-radius: 20px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1); color: var(--dim);
    transition: all 0.2s;
  }
  .stat-pill.active { border-color: var(--blue); color: var(--blue); background: rgba(90,200,250,0.08); }
  .stat-pill.boss-pill { border-color: var(--orange); color: var(--orange); animation: boss-pill-blink 0.4s infinite alternate; }
  @keyframes boss-pill-blink { from { opacity:1; } to { opacity:0.4; } }

  /* ‚îÄ‚îÄ BATTLE LOG ‚îÄ‚îÄ */
  .battle-log {
    height: 72px; overflow-y: auto;
    padding: 5px 10px; font-size: 11px;
    font-family: 'Nunito', sans-serif;
    color: var(--dim); border-top: 1px solid var(--border);
    flex-shrink: 0; background: rgba(0,0,0,0.2);
  }
  .battle-log::-webkit-scrollbar { width: 3px; }
  .battle-log::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 4px; }
  .battle-log div { margin-bottom: 1px; line-height: 1.4; }
  .log-dmg    { color: var(--pink); }
  .log-gold   { color: var(--yellow); }
  .log-merge  { color: var(--green); }
  .log-wave   { color: var(--blue); }
  .log-mutant { color: var(--pink); }
  .log-boss   { color: var(--orange); font-weight: 700; }

  /* ‚îÄ‚îÄ REWARD BAR ‚îÄ‚îÄ */
  .reward-bar {
    padding: 6px 8px; border-top: 1px solid var(--border);
    display: flex; gap: 5px; flex-shrink: 0;
    background: rgba(0,0,0,0.15);
  }
  .btn-reward {
    flex: 1; padding: 8px 4px; text-align: center;
    background: rgba(255,214,10,0.06);
    border: 1px solid rgba(255,214,10,0.35);
    color: var(--yellow);
    font-family: 'Fredoka One', sans-serif; font-size: 10px;
    border-radius: 10px; cursor: pointer; transition: all 0.15s;
    line-height: 1.5;
  }
  .btn-reward:not(:disabled):hover { background: rgba(255,214,10,0.15); box-shadow: 0 0 10px rgba(255,214,10,0.3); }
  .btn-reward:disabled { opacity: 0.25; cursor: not-allowed; }
  .btn-reward .rwd-cd { font-size: 9px; color: var(--dim); display: block; }

  /* ‚îÄ‚îÄ TABS (right panel header) ‚îÄ‚îÄ */
  .tabs {
    display: flex; flex-shrink: 0;
    background: rgba(0,0,0,0.3);
    padding: 6px 6px 0;
    gap: 4px;
    border-bottom: 2px solid rgba(255,255,255,0.07);
  }
  .tab {
    flex: 1; padding: 10px 4px 9px; text-align: center;
    font-family: 'Fredoka One', sans-serif; font-size: 12px;
    color: rgba(255,255,255,0.35); cursor: pointer;
    border: 1px solid transparent;
    border-bottom: none;
    border-radius: 10px 10px 0 0;
    background: transparent; transition: all 0.18s;
    text-transform: uppercase; letter-spacing: 1px;
  }
  .tab:hover:not(.active) {
    color: rgba(255,255,255,0.7);
    background: rgba(255,255,255,0.06);
    border-color: rgba(255,255,255,0.1);
  }
  .tab.active {
    color: #fff;
    background: linear-gradient(180deg, rgba(255,214,10,0.12) 0%, rgba(255,214,10,0.04) 100%);
    border-color: rgba(255,214,10,0.3);
    border-bottom: 2px solid #ffd60a;
    text-shadow: 0 0 12px rgba(255,214,10,0.5);
    box-shadow: 0 -2px 12px rgba(255,214,10,0.1) inset;
  }
  .tab-content { display: none; flex: 1; overflow-y: auto; flex-direction: column; }
  .tab-content.active { display: flex; }
  .tab-content::-webkit-scrollbar { width: 3px; }
  .tab-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 4px; }



  /* ‚îÄ‚îÄ IDLE BADGE ‚îÄ‚îÄ */
  .idle-badge {
    display: none; position: fixed;
    top: 50%; left: 50%;
    margin-top: 0;
    background: linear-gradient(160deg, rgba(61,43,133,0.97), rgba(42,29,94,0.97));
    border: 3px solid var(--yellow); border-radius: 32px;
    padding: 32px 56px; text-align: center; z-index: 600;
    box-shadow: 0 12px 50px rgba(255,214,10,0.4), 0 0 80px rgba(255,214,10,0.15);
    animation: idle-bounce 2s ease-in-out infinite;
    font-family: 'Fredoka One', sans-serif;
  }
  .idle-badge.visible { display: block; }
  @keyframes idle-bounce {
    0%,100% { transform: translate(-50%, -50%) translateY(0px); }
    50%      { transform: translate(-50%, -50%) translateY(-10px); }
  }
  .idle-badge .idle-title { font-size: 16px; color: var(--text2); letter-spacing: 3px; margin-bottom: 6px; }
  .idle-badge .idle-amount { font-size: 52px; color: var(--yellow); margin: 10px 0;
    text-shadow: 0 4px 16px rgba(255,214,10,0.6); line-height: 1; }
  .idle-badge .btn-collect {
    padding: 16px 52px; margin-top: 8px;
    background: linear-gradient(160deg, var(--yellow), var(--yellow2));
    box-shadow: 0 6px 0 #8a6200, 0 10px 24px rgba(255,214,10,0.5);
    color: #3d2000; font-family: 'Fredoka One', sans-serif; font-size: 22px;
    border: none; border-radius: 18px; cursor: pointer; transition: all 0.1s;
    letter-spacing: 1px;
  }
  .idle-badge .btn-collect:active { transform: translateY(4px); box-shadow: 0 2px 0 #8a6200; }


  /* ‚îÄ‚îÄ VOLUME PANEL ‚îÄ‚îÄ */
  .sound-wrap { position: relative; display: inline-block; }
  .vol-panel {
    display: none; position: absolute; top: calc(100% + 8px); right: 0;
    background: rgba(18,18,28,0.97); border: 1px solid rgba(90,200,250,0.35);
    border-radius: 14px; padding: 14px 16px; width: 200px; z-index: 9999;
    box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 20px rgba(90,200,250,0.1);
    backdrop-filter: blur(12px);
  }
  .vol-panel.open { display: block; }
  .vol-panel::before {
    content: ''; position: absolute; top: -6px; right: 16px;
    width: 10px; height: 10px; background: rgba(18,18,28,0.97);
    border-left: 1px solid rgba(90,200,250,0.35);
    border-top: 1px solid rgba(90,200,250,0.35);
    transform: rotate(45deg);
  }
  .vol-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
  .vol-row:last-child { margin-bottom: 0; }
  .vol-label {
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    color: var(--text2); width: 40px; flex-shrink: 0; letter-spacing: 0.5px;
  }
  .vol-slider {
    flex: 1; -webkit-appearance: none; appearance: none;
    height: 4px; border-radius: 4px; outline: none; cursor: pointer;
    background: linear-gradient(to right, var(--blue) 0%, var(--blue) 50%, rgba(255,255,255,0.15) 50%);
  }
  .vol-slider::-webkit-slider-thumb {
    -webkit-appearance: none; width: 14px; height: 14px;
    border-radius: 50%; background: #fff; cursor: pointer;
    box-shadow: 0 0 6px rgba(90,200,250,0.6);
  }
  .vol-slider::-moz-range-thumb {
    width: 14px; height: 14px; border-radius: 50%; background: #fff;
    cursor: pointer; border: none; box-shadow: 0 0 6px rgba(90,200,250,0.6);
  }
  .vol-val {
    font-family: 'Fredoka One', sans-serif; font-size: 11px;
    color: var(--blue); width: 28px; text-align: right; flex-shrink: 0;
  }
  .vol-toggle-row {
    display: flex; align-items: center; justify-content: space-between;
    margin-bottom: 12px; padding-bottom: 10px;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .vol-toggle-label {
    font-family: 'Fredoka One', sans-serif; font-size: 12px; color: var(--text2);
  }
  .vol-toggle-btn {
    padding: 3px 12px; border-radius: 8px; font-family: 'Fredoka One', sans-serif;
    font-size: 12px; cursor: pointer; border: 1px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.08); color: var(--text2); transition: all 0.15s;
  }
  .vol-toggle-btn:hover { background: rgba(255,255,255,0.15); }


  /* ‚îÄ‚îÄ NIGHTMARE WAVE ‚îÄ‚îÄ */
  .nightmare-banner {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Fredoka One', sans-serif;
    font-size: 36px; color: #ff2060;
    text-shadow: 0 0 30px #ff2060, 0 0 60px rgba(255,32,96,0.6), 0 4px 0 #7a0020;
    letter-spacing: 3px; pointer-events: none; z-index: 200; text-align: center;
    animation: nightmare-anim 3s ease-out forwards; white-space: nowrap;
  }
  .nightmare-banner span { display:block; font-size:16px; color:#ff8aad; letter-spacing:2px; margin-top:4px; }
  @keyframes nightmare-anim {
    0%   { opacity:0; transform:translate(-50%,-50%) scale(0.2) rotate(-5deg); filter:blur(8px); }
    15%  { opacity:1; transform:translate(-50%,-50%) scale(1.2) rotate(1deg); filter:blur(0); }
    70%  { opacity:1; transform:translate(-50%,-50%) scale(1); }
    100% { opacity:0; transform:translate(-50%,-50%) scale(0.9); }
  }
  .btn-start.nightmare-wave {
    background: linear-gradient(160deg, #ff2060, #7a0020) !important;
    box-shadow: 0 6px 0 #3d0010, 0 0 30px rgba(255,32,96,0.5) !important;
    animation: nightmare-pulse 0.8s ease-in-out infinite alternate !important;
  }
  @keyframes nightmare-pulse {
    from { box-shadow: 0 6px 0 #3d0010, 0 0 20px rgba(255,32,96,0.4); }
    to   { box-shadow: 0 6px 0 #3d0010, 0 0 50px rgba(255,32,96,0.9), 0 0 80px rgba(255,32,96,0.3); }
  }
  .nightmare-debuff-bar {
    position: absolute; bottom: 6px; left: 8px; right: 8px;
    background: rgba(255,32,96,0.12); border: 1px solid rgba(255,32,96,0.3);
    border-radius: 6px; padding: 4px 8px; font-size: 10px;
    font-family: 'Fredoka One', sans-serif; color: #ff8aad;
    display: none; z-index: 10;
  }
  .nightmare-debuff-bar.active { display: block; }

  /* ‚îÄ‚îÄ LEADERBOARD MODAL ‚îÄ‚îÄ */
    .lb-overlay {
    display:none; position:fixed; inset:0; z-index:10000;
    background:rgba(0,0,0,0.8); backdrop-filter:blur(6px);
    align-items:center; justify-content:center;
  }
  .lb-overlay.open { display:flex; }
  .lb-modal {
    background:linear-gradient(160deg,rgba(22,14,32,0.98),rgba(12,8,20,0.98));
    border:1px solid rgba(255,32,96,0.35);
    border-radius:20px; padding:24px 22px 18px;
    width:min(440px,92vw); max-height:85vh;
    box-shadow:0 0 60px rgba(255,32,96,0.15), 0 20px 60px rgba(0,0,0,0.6);
    display:flex; flex-direction:column; gap:0;
  }
  .lb-title {
    font-family:'Fredoka One',sans-serif; font-size:22px;
    color:#fff; text-align:center; letter-spacing:2px;
    text-shadow:0 0 20px rgba(255,32,96,0.6);
  }
  .lb-subtitle {
    font-family:'Nunito',sans-serif; font-size:10px;
    color:rgba(255,32,96,0.6); text-align:center; letter-spacing:3px;
    margin-bottom:14px; margin-top:2px;
  }
  .lb-entry-form { display:flex; gap:8px; margin-bottom:8px; }
  .lb-nick-input {
    flex:1; padding:8px 12px;
    background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.15);
    border-radius:10px; color:#fff; font-family:'Nunito',sans-serif; font-size:13px; outline:none;
  }
  .lb-nick-input:focus { border-color:rgba(255,32,96,0.5); }
  .lb-submit-btn {
    padding:8px 14px; background:linear-gradient(135deg,#ff2060,#7c3aed);
    border:none; border-radius:10px; color:#fff;
    font-family:'Fredoka One',sans-serif; font-size:12px;
    cursor:pointer; letter-spacing:1px; white-space:nowrap;
  }
  .lb-submit-btn:hover { filter:brightness(1.2); }
  .lb-submit-btn:disabled { opacity:0.4; cursor:not-allowed; }
  .lb-modal {
    background: linear-gradient(160deg, #0f1020, #1a1030);
    border: 2px solid rgba(255,32,96,0.4);
    border-radius: 20px; padding: 28px 24px; width: 420px; max-width: 95vw;
    max-height: 90vh; overflow-y: auto;
    box-shadow: 0 0 60px rgba(255,32,96,0.2), 0 0 120px rgba(90,32,200,0.15);
  }
  .lb-title {
    font-family: 'Fredoka One', sans-serif; font-size: 26px; text-align: center;
    color: #ff2060; text-shadow: 0 0 20px rgba(255,32,96,0.6);
    letter-spacing: 3px; margin-bottom: 4px;
  }
  .lb-subtitle { text-align:center; font-size:11px; color:var(--dim); margin-bottom:20px; letter-spacing:1px; }
  .lb-entry-form { display:flex; gap:8px; margin-bottom:20px; }
  .lb-nick-input {
    flex:1; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.15);
    border-radius:10px; padding:8px 12px; color:#fff; font-family:'Fredoka One',sans-serif;
    font-size:14px; outline:none; pointer-events:auto; user-select:text; -webkit-user-select:text;
    cursor:text;
  }
  .lb-nick-input:focus { border-color:rgba(255,32,96,0.5); box-shadow:0 0 0 2px rgba(255,32,96,0.2); }
  .lb-submit-btn {
    padding:8px 16px; background:linear-gradient(135deg,#ff2060,#7a0020);
    border:none; border-radius:10px; color:#fff; font-family:'Fredoka One',sans-serif;
    font-size:13px; cursor:pointer; white-space:nowrap;
    box-shadow: 0 3px 0 #3d0010;
  }
  .lb-submit-btn:hover { filter:brightness(1.2); }
  .lb-submit-btn:disabled { opacity:0.4; cursor:not-allowed; }
  .lb-list { list-style:none; padding:0; margin:0; max-height:340px; overflow-y:auto; }
  .lb-list::-webkit-scrollbar { width:4px; }
  .lb-list::-webkit-scrollbar-thumb { background:rgba(255,32,96,0.4); border-radius:4px; }
  .lb-row {
    display:flex; align-items:center; gap:8px;
    padding:8px 10px; border-radius:10px; margin-bottom:4px;
    background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    transition: background 0.15s;
  }
  .lb-row:hover { background:rgba(255,255,255,0.08); }
  .lb-row.me { background:rgba(255,32,96,0.12); border-color:rgba(255,32,96,0.35); }
  .lb-rank { font-family:'Fredoka One',sans-serif; font-size:16px; width:28px; text-align:center; flex-shrink:0; }
  .lb-rank.gold   { color:#fbbf24; text-shadow:0 0 10px rgba(251,191,36,0.8); }
  .lb-rank.silver { color:#cbd5e1; text-shadow:0 0 8px rgba(203,213,225,0.6); }
  .lb-rank.bronze { color:#d97706; text-shadow:0 0 8px rgba(217,119,6,0.6); }
  .lb-name { flex:1; font-family:'Fredoka One',sans-serif; font-size:13px; color:#fff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .lb-score-col { text-align:right; flex-shrink:0; }
  .lb-score-main { font-family:'Fredoka One',sans-serif; font-size:14px; color:#ff2060; }
  .lb-score-sub  { font-size:9px; color:rgba(255,255,255,0.4); letter-spacing:0.5px; margin-top:1px; }
  .lb-loading, .lb-empty { padding:20px; text-align:center; color:rgba(255,255,255,0.4); font-size:12px; font-family:'Nunito',sans-serif; list-style:none; }
  .lb-close-btn {
    margin-top:12px; width:100%; padding:8px;
    background:rgba(255,32,96,0.15); border:1px solid rgba(255,32,96,0.35);
    color:#ff8aad; font-family:'Fredoka One',sans-serif; font-size:13px;
    border-radius:10px; cursor:pointer; transition:all 0.15s; letter-spacing:1px;
  }
  .lb-close-btn:hover { background:rgba(255,32,96,0.25); color:#fff; }
  .lb-row {
    display:flex; align-items:center; gap:10px;
    padding:9px 10px; border-radius:10px; margin-bottom:5px;
    background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    transition: background 0.2s;
  }
  .lb-row:hover { background:rgba(255,255,255,0.07); }
  .lb-row.me { background:rgba(255,32,96,0.1); border-color:rgba(255,32,96,0.3); }
  .lb-rank {
    font-family:'Fredoka One',sans-serif; font-size:14px; width:28px;
    text-align:center; color:var(--dim);
  }
  .lb-rank.gold   { color:#fbbf24; text-shadow:0 0 8px rgba(251,191,36,0.6); }
  .lb-rank.silver { color:#9ca3af; }
  .lb-rank.bronze { color:#cd8040; }
  .lb-name { font-family:'Fredoka One',sans-serif; font-size:14px; flex:1; color:#fff; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .lb-score-col { text-align:right; }
  .lb-score-main { font-family:'Fredoka One',sans-serif; font-size:15px; color:#ff2060; }
  .lb-score-sub  { font-size:9px; color:var(--dim); }
  .lb-close-btn {
    display:block; margin:18px auto 0; padding:8px 28px;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.15);
    border-radius:12px; color:var(--text2); font-family:'Fredoka One',sans-serif;
    font-size:13px; cursor:pointer;
  }
  .lb-close-btn:hover { background:rgba(255,255,255,0.15); color:#fff; }
  .lb-loading { text-align:center; color:var(--dim); font-size:13px; padding:20px; }
  .lb-empty { text-align:center; color:var(--dim); font-size:12px; padding:16px; }

  /* ‚îÄ‚îÄ MERGE HINTS ‚îÄ‚îÄ */
  #merge-hints {
    min-height: 20px; padding: 3px 10px;
    font-family: 'Fredoka One', sans-serif; font-size: 10px; letter-spacing: 0.5px;
    color: var(--green); border-bottom: 1px solid var(--border);
  }

  /* ‚îÄ‚îÄ ECONOMY HINT ‚îÄ‚îÄ */
  .economy-hint {
    font-family: 'Fredoka One', sans-serif; font-size: 10px; letter-spacing: 0.5px;
    color: var(--text2); padding: 4px 10px;
    border-bottom: 1px solid var(--border);
  }

  /* ‚îÄ‚îÄ PANEL LOG (right side) ‚îÄ‚îÄ */
  .panel-log {
    height: 120px; border-top: 1px solid var(--border);
    overflow-y: auto; flex-shrink: 0;
    background: rgba(0,0,0,0.2);
  }
  .panel-log::-webkit-scrollbar { width: 3px; }
  .panel-log::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 4px; }

  /* ‚îÄ‚îÄ LOG COLLAPSIBLE ‚îÄ‚îÄ */
  .log-collapsible {
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    max-height: 120px;
    opacity: 1;
  }
  .log-collapsible.collapsed {
    max-height: 0;
    opacity: 0;
  }
  .log-toggle-btn {
    margin-left: auto; padding: 2px 8px; border-radius: 6px;
    background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.12);
    color: var(--dim); font-size: 9px; cursor: pointer;
    transition: all .15s; line-height: 1.6; flex-shrink: 0; letter-spacing: 0.5px;
  }
  .log-toggle-btn:hover { background: rgba(255,255,255,0.14); color: #fff; }
  #stat-pills-bar { display: flex; align-items: center; }

  /* ‚îÄ‚îÄ BTN-SOUND ON state ‚îÄ‚îÄ */
  .btn-sound.on { background: rgba(90,200,250,0.15); border-color: var(--blue); color: var(--blue); }

  /* ‚îÄ‚îÄ PRESTIGE NUM in header ‚îÄ‚îÄ */
  #prestige-num { color: var(--purple); font-family: 'Fredoka One', sans-serif; }

  /* ‚îÄ‚îÄ MOBILE ‚îÄ‚îÄ */
  .mobile-tabs { display: none; } /* ukryty na desktopie */
  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     TABLET (600px‚Äì1024px)
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
  @media (max-width: 1024px) {
    .panel-upgrades { width: 200px; }
    .panel-merge { width: 240px; }
  }

  @media (max-width: 600px) {
    body {
      height: 100dvh;
      overflow: hidden;
    }
    header {
      padding: 5px 8px; flex-wrap: wrap; gap: 3px; flex-shrink: 0;
    }
    .title { font-size: 12px; letter-spacing: 1px; }
    .version-badge { font-size: 7px; }
    .currencies { gap: 3px; flex-wrap: wrap; }
    .currency { font-size: 10px; padding: 3px 6px; }
    .currency-val { min-width: 28px; }
    .wave-info { font-size: 10px; }
    .btn-speed { font-size: 10px; padding: 3px 7px; }
    .btn-shop-open { font-size: 10px; padding: 3px 7px; }
    .btn-sound, #btn-ranks, .sound-wrap,
    #save-indicator, #active-buffs, #buff-global-tooltip { display: none !important; }

    .main { flex: 1; min-height: 0; position: relative; overflow: hidden; }

    .panel-merge, .panel-arena, .panel-upgrades {
      position: fixed;
      top: var(--header-h, 80px);
      left: 0; right: 0;
      bottom: 56px;
      width: 100%;
      border: none;
      box-sizing: border-box;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .panel-merge.mobile-active   { display: flex; flex-direction: column; overflow-y: auto; -webkit-overflow-scrolling: touch; }
    .panel-arena.mobile-active   { display: flex; flex-direction: column; }
    .panel-upgrades.mobile-active { display: flex; flex-direction: column; overflow-y: auto; -webkit-overflow-scrolling: touch; }

    .mobile-tabs {
      display: flex;
      position: fixed;
      bottom: 0; left: 0; right: 0;
      height: 56px;
      background: #070316;
      border-top: 2px solid rgba(191,90,242,0.4);
      z-index: 10000;
    }
    .mobile-tab {
      flex: 1; display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 2px;
      padding: 6px 4px 8px;
      font-family: 'Fredoka One', sans-serif; font-size: 9px;
      color: rgba(255,255,255,0.3); background: none; border: none;
      cursor: pointer; -webkit-tap-highlight-color: transparent;
    }
    .mobile-tab .tab-icon { font-size: 20px; line-height: 1; }
    .mobile-tab:nth-child(1).active { color: #4cd964; }
    .mobile-tab:nth-child(2).active { color: #5ac8fa; }
    .mobile-tab:nth-child(3).active { color: #bf5af2; }

    .canvas-wrap { flex: 1; min-height: 0; }
    .arena-header { flex-wrap: wrap; gap: 3px; padding: 4px 6px; }
    #arena-zoom-ctrl, #btn-follow-mouse { display: none; }
    .btn-start { font-size: 13px; padding: 10px; flex: 1; }
    #notif-area { top: 8px; left: 8px; width: 180px; }

    /* Zmniejsz k≈Ç√≥dkƒô na ma≈Çych ekranach */
    .grid-cell.store-locked::after { font-size: 15px !important; }

    /* Sklep ‚Äî trochƒô mniejszy tekst ≈ºeby siƒô mie≈õci≈Ç */
    .shop-item-name { font-size: 14px; }
    .shop-item-desc { font-size: 11px; }
    .btn-shop-buy   { font-size: 13px; padding: 9px 14px; }
    .relic-card     { width: 160px; padding: 14px 12px; }
    .relic-card-name { font-size: 14px; }
    .relic-card-desc { font-size: 11px; }
    .event-card     { width: 155px; padding: 14px 12px; }
    .event-card-name { font-size: 15px; }
    .event-card-desc { font-size: 12px; }
    .lose-title { font-size: 26px; }
    .lose-buttons { flex-direction: column; gap: 8px; align-items: center; }
    .btn-lose { font-size: 13px; padding: 11px 20px; }
    .shop-overlay { padding: 0; align-items: flex-end; }
    .shop-modal { width: 100%; max-width: 100%; height: 88dvh; border-radius: 18px 18px 0 0; }
  }
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     MISSING ANIMATION STYLES (NAPRAWA)
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

  .sparkle {
    position: fixed;       /* Important: floats above game, not at bottom */
    pointer-events: none;  /* Clicks pass through */
    z-index: 500;          /* Must be above board */
    font-weight: 900;
    font-family: sans-serif;
    opacity: 0;
    /* Animation uses --tx and --ty variables set by JS */
    animation: sparkle-fly linear forwards; 
  }

  @keyframes sparkle-fly {
    0%   { opacity: 1; transform: translate(0, 0) scale(0.5); }
    15%  { opacity: 1; transform: translate(0, 0) scale(1.2); }
    100% { opacity: 0; transform: translate(var(--tx), var(--ty)) scale(0); }
  }

  .merge-ring {
    position: fixed;
    border-radius: 50%;
    background: transparent;
    border: 2px solid #fff;
    box-shadow: 0 0 10px currentColor; /* Glows with border color */
    pointer-events: none;
    z-index: 450;
    opacity: 0;
    transform: scale(0.5);
    animation: ring-expand 0.6s ease-out forwards;
  }

  @keyframes ring-expand {
    0%   { opacity: 1; transform: scale(0.5); border-width: 5px; }
    100% { opacity: 0; transform: scale(3.0); border-width: 0px; }
  }

  @keyframes float-up {
    0%   { opacity: 0; transform: translateY(0) scale(0.5); }
    20%  { opacity: 1; transform: translateY(-15px) scale(1.2); }
    100% { opacity: 0; transform: translateY(-60px) scale(1); }
  }

  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     ROW BONUS SYSTEM
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
  .merge-grid {
    position: relative;
  }
  /* ‚ïê‚ïê ROW WRAPPER LAYOUT ‚ïê‚ïê
     merge-grid gets padding-left for label column,
     each row group wraps label + 4 cells            */

  .merge-grid {
    display: block !important;  /* override grid ‚Äî we build row groups */
    padding: 8px 8px 8px 0 !important;
    overflow-y: auto;
    flex: 1; min-height: 0;
    position: relative; z-index: 1;
  }

  /* One row = label sidebar + 4 cells */
  .row-group {
    display: flex;
    align-items: stretch;
    margin-bottom: 4px;
    position: relative;
  }
  .row-group:last-child { margin-bottom: 0; }

  /* Left label panel */
  .row-label-col {
    width: 46px;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 4px 2px;
    border-radius: 10px 0 0 10px;
    position: relative;
    z-index: 2;
    gap: 1px;
  }
  .row-label-icon {
    font-size: 13px;
    line-height: 1;
    margin-bottom: 1px;
  }
  .row-label-name {
    font-family: 'Fredoka One', sans-serif;
    font-size: 7.5px;
    letter-spacing: 0.8px;
    text-transform: uppercase;
    text-align: center;
    line-height: 1.1;
  }
  .row-label-bonus {
    font-family: 'Nunito', sans-serif;
    font-size: 8px;
    font-weight: 900;
    text-align: center;
    margin-top: 2px;
    padding: 1px 4px;
    border-radius: 4px;
    letter-spacing: 0.3px;
    line-height: 1.2;
  }

  /* 4-cell inner grid */
  .row-cells {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 5px;
    padding: 5px 5px 5px 4px;
    border-radius: 0 12px 12px 0;
    position: relative;
    z-index: 1;
  }

  /* Per-row color themes */
  .row-group.row-front .row-label-col {
    background: linear-gradient(180deg, rgba(255,69,58,0.25) 0%, rgba(255,69,58,0.12) 100%);
    border: 1px solid rgba(255,69,58,0.35);
    border-right: none;
    color: #ff6b5b;
  }
  .row-group.row-front .row-label-bonus {
    background: rgba(255,69,58,0.18);
    color: #ff453a;
    border: 1px solid rgba(255,69,58,0.3);
  }
  .row-group.row-front .row-cells {
    background: linear-gradient(135deg, rgba(255,69,58,0.07) 0%, rgba(255,69,58,0.02) 100%);
    border: 1px solid rgba(255,69,58,0.15);
    border-left: none;
  }

  .row-group.row-mid .row-label-col {
    background: linear-gradient(180deg, rgba(90,200,250,0.20) 0%, rgba(90,200,250,0.10) 100%);
    border: 1px solid rgba(90,200,250,0.30);
    border-right: none;
    color: #5ac8fa;
  }
  .row-group.row-mid .row-label-bonus {
    background: rgba(90,200,250,0.15);
    color: #5ac8fa;
    border: 1px solid rgba(90,200,250,0.3);
  }
  .row-group.row-mid .row-cells {
    background: linear-gradient(135deg, rgba(90,200,250,0.06) 0%, rgba(90,200,250,0.02) 100%);
    border: 1px solid rgba(90,200,250,0.12);
    border-left: none;
  }

  .row-group.row-back .row-label-col {
    background: linear-gradient(180deg, rgba(191,90,242,0.25) 0%, rgba(191,90,242,0.12) 100%);
    border: 1px solid rgba(191,90,242,0.35);
    border-right: none;
    color: #bf5af2;
  }
  .row-group.row-back .row-label-bonus {
    background: rgba(191,90,242,0.18);
    color: #d077f5;
    border: 1px solid rgba(191,90,242,0.3);
  }
  .row-group.row-back .row-cells {
    background: linear-gradient(135deg, rgba(191,90,242,0.08) 0%, rgba(191,90,242,0.02) 100%);
    border: 1px solid rgba(191,90,242,0.15);
    border-left: none;
  }

  .row-group.row-support .row-label-col {
    background: linear-gradient(180deg, rgba(76,217,100,0.22) 0%, rgba(76,217,100,0.10) 100%);
    border: 1px solid rgba(76,217,100,0.32);
    border-right: none;
    color: #4cd964;
  }
  .row-group.row-support .row-label-bonus {
    background: rgba(76,217,100,0.15);
    color: #4cd964;
    border: 1px solid rgba(76,217,100,0.3);
  }
  .row-group.row-support .row-cells {
    background: linear-gradient(135deg, rgba(76,217,100,0.07) 0%, rgba(76,217,100,0.02) 100%);
    border: 1px solid rgba(76,217,100,0.13);
    border-left: none;
  }

  /* Locked row (slots not unlocked yet) */
  .row-group.row-locked .row-label-col {
    background: rgba(0,0,0,0.2);
    border: 1px solid rgba(255,255,255,0.06);
    border-right: none;
    color: rgba(255,255,255,0.2);
  }
  .row-group.row-locked .row-label-bonus {
    background: transparent;
    color: rgba(255,255,255,0.2);
    border: 1px solid rgba(255,255,255,0.08);
  }
  .row-group.row-locked .row-cells {
    background: rgba(0,0,0,0.1);
    border: 1px solid rgba(255,255,255,0.05);
    border-left: none;
    opacity: 0.55;
  }

  /* Connecting seam between label and cells */
  .row-group .row-label-col::after {
    content: '';
    position: absolute;
    right: -1px; top: 6px; bottom: 6px;
    width: 2px;
    background: inherit;
    z-index: 3;
  }

  /* Cell tweaks inside rows ‚Äî remove extra border-radius on left edge */
  .row-cells .grid-cell {
    border-radius: 10px;
  }

  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     MERGE STREAK SYSTEM
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
  #merge-streak-bar {
    display: none;
    align-items: center;
    gap: 8px;
    padding: 5px 10px;
    background: rgba(0,0,0,0.2);
    border-top: 1px solid rgba(255,255,255,0.04);
    flex-shrink: 0;
    position: relative;
    z-index: 1;
    overflow: hidden;
  }
  #merge-streak-bar.visible { display: flex; }
  #merge-streak-bar::before {
    content: '';
    position: absolute; inset: 0;
    background: linear-gradient(90deg, transparent, rgba(191,90,242,0.06), transparent);
    animation: streak-sweep 1.5s linear infinite;
  }
  @keyframes streak-sweep {
    from { transform: translateX(-100%); }
    to   { transform: translateX(100%); }
  }
  .streak-icon {
    font-size: 14px;
    filter: drop-shadow(0 0 6px var(--purple));
    animation: streak-pulse 0.6s ease-in-out infinite alternate;
  }
  @keyframes streak-pulse {
    from { filter: drop-shadow(0 0 4px var(--purple)); transform: scale(1); }
    to   { filter: drop-shadow(0 0 12px var(--purple)); transform: scale(1.15); }
  }
  .streak-count {
    font-family: 'Fredoka One', sans-serif;
    font-size: 18px;
    color: var(--purple);
    text-shadow: 0 0 10px rgba(191,90,242,0.6);
    min-width: 30px;
  }
  .streak-label {
    font-family: 'Nunito', sans-serif;
    font-size: 10px;
    font-weight: 800;
    color: rgba(255,255,255,0.5);
    letter-spacing: 1px;
    flex: 1;
  }
  .streak-bonus {
    font-family: 'Fredoka One', sans-serif;
    font-size: 11px;
    color: var(--yellow);
    padding: 2px 7px;
    border-radius: 8px;
    background: rgba(255,214,10,0.12);
    border: 1px solid rgba(255,214,10,0.3);
  }
  .streak-pips {
    display: flex; gap: 3px; align-items: center;
  }
  .streak-pip {
    width: 8px; height: 8px; border-radius: 50%;
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.15);
    transition: all 0.15s;
  }
  .streak-pip.on {
    background: var(--purple);
    box-shadow: 0 0 6px rgba(191,90,242,0.8);
    border-color: transparent;
  }
  .streak-pip.bonus-pip.on {
    background: var(--yellow);
    box-shadow: 0 0 6px rgba(255,214,10,0.8);
  }

  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     MERGE LAB (CRAFTING RECIPES)
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
  #merge-lab-overlay {
    display: none;
    position: fixed; inset: 0; z-index: 2000;
    background: rgba(0,0,0,0.85);
    backdrop-filter: blur(12px);
    align-items: center; justify-content: center;
  }
  #merge-lab-overlay.open { display: flex; }
  .merge-lab-modal {
    background: linear-gradient(160deg, #0e0820, #120a2e);
    border: 1.5px solid rgba(191,90,242,0.4);
    border-radius: 22px;
    padding: 22px 24px;
    width: min(520px, 95vw);
    max-height: 88vh;
    overflow-y: auto;
    box-shadow: 0 0 60px rgba(191,90,242,0.2), 0 20px 60px rgba(0,0,0,0.6);
    position: relative;
  }
  .merge-lab-title {
    font-family: 'Fredoka One', sans-serif;
    font-size: 22px;
    color: #fff;
    letter-spacing: 2px;
    margin-bottom: 4px;
    background: linear-gradient(135deg, #bf5af2, #5ac8fa);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
  }
  .merge-lab-sub {
    font-family: 'Nunito', sans-serif; font-size: 11px;
    color: rgba(255,255,255,0.4); margin-bottom: 18px; letter-spacing: 1px;
  }
  .recipe-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 16px;
  }
  .recipe-card {
    background: rgba(255,255,255,0.03);
    border: 1.5px solid rgba(255,255,255,0.1);
    border-radius: 14px;
    padding: 12px 14px;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
    overflow: hidden;
  }
  .recipe-card::before {
    content: '';
    position: absolute; inset: 0;
    background: linear-gradient(135deg, var(--recipe-color, rgba(191,90,242,0.08)), transparent);
    pointer-events: none;
  }
  .recipe-card.can-craft {
    border-color: var(--recipe-color, rgba(191,90,242,0.5));
    box-shadow: 0 0 16px color-mix(in srgb, var(--recipe-color, #bf5af2) 25%, transparent);
    cursor: pointer;
  }
  .recipe-card.can-craft:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 24px color-mix(in srgb, var(--recipe-color, #bf5af2) 40%, transparent);
  }
  .recipe-card.discovered {
    border-color: rgba(255,255,255,0.12);
  }
  .recipe-card.undiscovered {
    border-color: rgba(255,255,255,0.06);
    filter: grayscale(0.7) brightness(0.6);
  }
  .recipe-status {
    position: absolute; top: 8px; right: 8px;
    font-size: 8px; font-weight: 900;
    padding: 2px 6px; border-radius: 5px;
    letter-spacing: 1px;
  }
  .recipe-status.can   { background: rgba(76,217,100,0.2); color: #4cd964; border: 1px solid rgba(76,217,100,0.4); }
  .recipe-status.need  { background: rgba(255,69,58,0.15); color: #ff453a; border: 1px solid rgba(255,69,58,0.3); }
  .recipe-status.unk   { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.3); border: 1px solid rgba(255,255,255,0.1); }
  .recipe-icon { font-size: 28px; margin-bottom: 4px; }
  .recipe-name {
    font-family: 'Fredoka One', sans-serif; font-size: 13px; color: #fff;
    margin-bottom: 4px; letter-spacing: 0.5px;
  }
  .recipe-name.unknown { color: rgba(255,255,255,0.3); font-size: 11px; letter-spacing: 2px; }
  .recipe-formula {
    font-family: 'Nunito', sans-serif; font-size: 10px; color: rgba(255,255,255,0.5);
    display: flex; align-items: center; gap: 4px; flex-wrap: wrap;
    margin-bottom: 5px;
  }
  .recipe-formula .tag {
    padding: 1px 5px; border-radius: 4px; font-weight: 800; font-size: 9px;
  }
  .recipe-desc {
    font-family: 'Nunito', sans-serif; font-size: 10px; color: rgba(255,255,255,0.45);
    line-height: 1.4;
  }
  .recipe-stats {
    display: flex; gap: 6px; margin-top: 6px; flex-wrap: wrap;
  }
  .recipe-stat {
    font-family: 'Fredoka One', sans-serif; font-size: 10px;
    padding: 2px 7px; border-radius: 6px; letter-spacing: 0.3px;
  }
  .recipe-craft-btn {
    display: block; width: 100%; margin-top: 8px;
    padding: 6px;
    font-family: 'Fredoka One', sans-serif; font-size: 12px;
    letter-spacing: 1px;
    border: none; border-radius: 8px; cursor: pointer;
    background: linear-gradient(135deg, var(--recipe-color, #bf5af2), rgba(0,0,0,0.3));
    color: #fff; transition: all 0.1s;
  }
  .recipe-craft-btn:hover { filter: brightness(1.2); }
  .recipe-craft-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .merge-lab-close {
    position: absolute; top: 14px; right: 14px;
    background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px; padding: 4px 10px;
    font-family: 'Fredoka One', sans-serif; font-size: 12px;
    color: rgba(255,255,255,0.6); cursor: pointer;
  }
  .merge-lab-close:hover { background: rgba(255,255,255,0.15); }
  /* Lab tab btn in buy section */
  .btn-lab {
    background: rgba(191,90,242,0.15);
    box-shadow: 0 4px 0 rgba(0,0,0,0.3);
    border: 1px solid rgba(191,90,242,0.3);
    color: rgba(191,90,242,0.9);
    font-size: 11px;
    max-width: 70px;
    flex-shrink: 0;
  }
  .btn-lab:hover { background: rgba(191,90,242,0.25); }
  /* Special unit badge on grid */
  .special-unit-badge {
    position: absolute; top: 3px; left: 3px;
    font-size: 10px; z-index: 6;
    filter: drop-shadow(0 0 4px rgba(255,214,10,0.8));
    animation: special-badge-pop 1.2s ease-in-out infinite alternate;
  }
  @keyframes special-badge-pop {
    from { transform: scale(1) rotate(-5deg); }
    to   { transform: scale(1.15) rotate(5deg); }
  }
  .grid-cell.special-cell {
    animation: special-pod 2s linear infinite !important;
    border-width: 2px !important;
  }
  @keyframes special-pod {
    0%  { border-color: #ffd60a; box-shadow: 0 0 18px rgba(255,214,10,0.5); }
    25% { border-color: #ff9f0a; box-shadow: 0 0 18px rgba(255,159,10,0.5); }
    50% { border-color: #ff453a; box-shadow: 0 0 18px rgba(255,69,58,0.5); }
    75% { border-color: #bf5af2; box-shadow: 0 0 18px rgba(191,90,242,0.5); }
    100%{ border-color: #ffd60a; box-shadow: 0 0 18px rgba(255,214,10,0.5); }
  }

  /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     LONG HOLD PREVIEW (press and hold slot)
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
  #hold-preview-tooltip {
    position: fixed; z-index: 5000; pointer-events: none;
    background: rgba(10,6,22,0.97);
    border: 1.5px solid rgba(191,90,242,0.45);
    border-radius: 14px; padding: 12px 14px;
    font-family: 'Nunito', sans-serif;
    width: 200px;
    box-shadow: 0 0 30px rgba(191,90,242,0.2), 0 8px 32px rgba(0,0,0,0.6);
    opacity: 0; transition: opacity 0.2s;
    display: none;
  }
  #hold-preview-tooltip.visible { opacity: 1; display: block; }
  .hold-preview-title {
    font-family: 'Fredoka One', sans-serif; font-size: 14px; color: #fff;
    margin-bottom: 6px;
  }
  .hold-preview-section {
    font-size: 10px; color: rgba(255,255,255,0.4);
    letter-spacing: 1px; margin: 8px 0 4px;
    font-weight: 900;
  }
  .hold-preview-recipe {
    display: flex; align-items: center; gap: 6px;
    padding: 5px 8px; border-radius: 8px;
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.08);
    margin-bottom: 4px; cursor: pointer;
    transition: all 0.1s;
  }
  .hold-preview-recipe:hover {
    border-color: rgba(191,90,242,0.3);
    background: rgba(191,90,242,0.08);
  }
  .hold-preview-recipe-icon { font-size: 16px; }
  .hold-preview-recipe-info { flex: 1; }
  .hold-preview-recipe-name { font-family: 'Fredoka One', sans-serif; font-size: 11px; color: #fff; }
  .hold-preview-recipe-req  { font-size: 9px; color: rgba(255,255,255,0.4); }
  .hold-preview-merge {
    display: flex; align-items: center; justify-content: center; gap: 6px;
    padding: 6px; border-radius: 8px;
    background: rgba(76,217,100,0.08); border: 1px solid rgba(76,217,100,0.2);
    margin-bottom: 4px;
  }
  .hold-preview-merge-txt {
    font-family: 'Fredoka One', sans-serif; font-size: 11px; color: #4cd964;
  }
  .hold-preview-empty {
    font-size: 10px; color: rgba(255,255,255,0.25); font-style: italic; padding: 4px 0;
  }
</style>
</head>
<body>

<header>
  <div class="title" style="position:relative; overflow:visible;">
    <canvas id="title-slime-canvas" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);pointer-events:none;z-index:0;" width="400" height="60"></canvas>
    <span class="title-text" style="position:relative;z-index:1;display:inline-flex;gap:0px;">
      <span class="tl" style="animation-delay:0.00s">S</span><span class="tl" style="animation-delay:0.07s">L</span><span class="tl" style="animation-delay:0.14s">I</span><span class="tl" style="animation-delay:0.21s">M</span><span class="tl" style="animation-delay:0.28s">E</span><span class="tl" style="animation-delay:0.42s"> </span><span class="tl" style="animation-delay:0.49s">A</span><span class="tl" style="animation-delay:0.56s">R</span><span class="tl" style="animation-delay:0.63s">E</span><span class="tl" style="animation-delay:0.70s">N</span><span class="tl" style="animation-delay:0.77s">A</span><span class="tl" style="animation-delay:0.91s"> </span><span class="tl" style="animation-delay:0.98s">L</span><span class="tl" style="animation-delay:1.05s">A</span><span class="tl" style="animation-delay:1.12s">B</span>
    </span>
    <span class="version-badge" onclick="_cheatClickCount()" title="???" style="position:relative;z-index:1;">PRE-ALFA 0.23</span>
  </div>
  <div class="currencies">
    <div class="currency gold">‚öó <span class="currency-val" id="gold-val">0</span> G</div>
    <div class="currency bio">üß¨ <span class="currency-val" id="bio-val">0</span> BIO</div>
    <div class="currency research">üî¨ <span class="currency-val" id="res-val">0</span> RES</div>
    <div class="currency slime" onclick="openShop('slime')" title="Slime ‚Äî premium currency. Click to buy more!">üß™ <span class="currency-val" id="slime-val">0</span> SLM</div>
    <div id="active-buffs" style="display:flex;gap:4px;align-items:center;flex-wrap:wrap"></div>
  <div id="buff-global-tooltip"></div>
  </div>
  <div style="display:flex;align-items:center;gap:8px">
    <div class="wave-info">WAVE <span id="wave-num">1</span> &nbsp;|&nbsp; PRESTIGE <span id="prestige-num">0</span>√ó <span id="save-indicator" style="font-size:9px;color:rgba(255,255,255,0.25);margin-left:6px"></span></div>
    <button class="btn-speed" id="btn-speed" onclick="toggleSpeed()">1√ó</button>
    <button class="btn-shop-open" id="btn-shop-open" onclick="openShop()">üõí SHOP</button>
    <button class="btn-sound" id="btn-ranks" onclick="openLeaderboard()" style="border-color:rgba(255,32,96,0.4);color:#ff8aad">üèÜ RANKS</button>
    <div class="sound-wrap" id="sound-wrap">
      
      <button class="btn-sound btn-sfx" id="btn-sound" onclick="openVolPanel(event)">üîä SFX</button>
      <div class="vol-panel" id="vol-panel">
        <div class="vol-toggle-row">
          <span class="vol-toggle-label" id="vol-audio-label">Audio</span>
          <button class="vol-toggle-btn" id="vol-toggle-btn" onclick="toggleSound()">OFF</button>
        </div>
        <div class="vol-row">
          <span class="vol-label" id="vol-music-label">üéµ MUS</span>
          <input class="vol-slider" id="slider-music" type="range" min="0" max="100" value="45"
            oninput="setMusicVol(this.value)">
          <span class="vol-val" id="val-music">45</span>
        </div>
        <div class="vol-row">
          <span class="vol-label" id="vol-sfx-label">üîä SFX</span>
          <input class="vol-slider" id="slider-sfx" type="range" min="0" max="100" value="70"
            oninput="setSfxVol(this.value)">
          <span class="vol-val" id="val-sfx">70</span>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="main">

  <!-- LEFT: Merge -->
  <div class="panel-merge">
    <div class="panel-title" id="panel-merge-title">‚¨° MERGE LAB</div>
    <div class="economy-hint" id="econ-hint">Next buy: <span id="buy-cost-hint">10g</span> | Income: <span id="income-hint">0/s</span></div>
    <div class="merge-hints" id="merge-hints"></div>
    <div class="merge-grid" id="merge-grid"></div>
    <div class="buy-section">
      <button class="btn btn-buy" id="btn-buy" onclick="buyUnit()">
        BUY &nbsp;<span id="buy-cost">500g</span>
      </button>
      <button class="btn btn-automerge" id="btn-auto" onclick="toggleAuto()">AUTO</button>
      <button class="btn btn-lab btn-3d" onclick="openMergeLab()" title="Merge Lab ‚Äî special crafting recipes">‚öó LAB</button>
    </div>
    <div id="merge-streak-bar">
      <span class="streak-icon">‚ö°</span>
      <span class="streak-count" id="streak-count">0</span>
      <span class="streak-label">MERGE STREAK</span>
      <div class="streak-pips" id="streak-pips"></div>
      <span class="streak-bonus" id="streak-bonus-label">+0% DPS</span>
    </div>
    <div class="synergy-bar" id="synergy-bar"></div>
    <div id="relic-upgrade-panel" style="
      display:none; margin:6px 10px; padding:8px 10px;
      background:rgba(124,58,237,0.1); border:1px solid rgba(168,85,247,0.25);
      border-radius:10px; font-family:'Fredoka One',sans-serif;
    "></div>
  </div>

  <!-- CENTER: Arena -->
  <div class="panel-arena" id="panel-arena">
    <div class="nightmare-debuff-bar" id="nightmare-debuff-bar">üíÄ NIGHTMARE: Blobs deal -40% DPS ¬∑ Enemies deal 2√ó damage</div>
    <div class="arena-header">
      <span style="font-size:12px;color:var(--dim)" id="wave-label-full">WAVE 1</span>
      <span id="kill-counter" style="
        font-family:'Fredoka One',sans-serif; font-size:12px;
        color:rgba(255,255,255,0.35); letter-spacing:0.5px;
        background:rgba(0,0,0,0.2); border:1px solid rgba(255,255,255,0.08);
        border-radius:8px; padding:2px 10px; white-space:nowrap;
      ">‚ò† 0 / 0</span>
      <span class="wave-timer" id="wave-timer">‚Äî</span>
      <span style="font-size:12px;color:var(--pink);margin-left:8px" id="enemy-count">ENEMIES: 0</span>
      <span id="header-lives" style="
        display:flex; gap:3px; align-items:center; margin-left:10px;
        font-size:14px; line-height:1;
      ">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
      <div id="daily-challenge-bar" style="
      display:none; align-items:center; gap:4px;
      padding:2px 8px; border-radius:10px;
      background:rgba(0,0,0,0.3); border:1px solid rgba(167,139,250,0.25);
      font-family:'Fredoka One',sans-serif; font-size:10px;
      min-width:180px;
    "></div>
    <button id="btn-follow-mouse" onclick="toggleFollowMouse()" title="Slims follow cursor" style="
        margin-left:10px; padding:3px 10px; border-radius:8px; border:1.5px solid rgba(255,255,255,0.15);
        background:rgba(255,255,255,0.06); color:rgba(255,255,255,0.45);
        font-family:'Fredoka One',sans-serif; font-size:11px; cursor:pointer;
        transition:all .15s; white-space:nowrap; letter-spacing:0.5px;
      ">üñ± FOLLOW</button>
    <div id="arena-zoom-ctrl" style="
        display:flex; align-items:center; gap:3px; margin-left:8px;
        background:rgba(0,0,0,0.25); border:1px solid rgba(255,255,255,0.1);
        border-radius:10px; padding:2px 5px;
      ">
      <button onclick="arenaZoom(-1)" title="Zoom out" style="
        width:22px;height:22px;border:none;background:transparent;
        color:rgba(255,255,255,0.5);font-size:14px;cursor:pointer;
        border-radius:6px;line-height:1;padding:0;transition:all .1s;
        font-family:'Fredoka One',sans-serif;
      " onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">‚àí</button>
      <span id="arena-zoom-label" style="
        font-family:'Fredoka One',sans-serif;font-size:10px;
        color:rgba(255,255,255,0.4);min-width:30px;text-align:center;
        letter-spacing:0.5px;
      ">100%</span>
      <button onclick="arenaZoom(1)" title="Zoom in" style="
        width:22px;height:22px;border:none;background:transparent;
        color:rgba(255,255,255,0.5);font-size:14px;cursor:pointer;
        border-radius:6px;line-height:1;padding:0;transition:all .1s;
        font-family:'Fredoka One',sans-serif;
      " onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">+</button>
    </div>
    </div>
    <div class="canvas-wrap">
      <canvas id="arena-canvas" style="flex:1;width:100%;height:100%;display:block;"></canvas>
      <canvas id="event-vfx" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:50;display:none;"></canvas>
      <div class="live-dps" id="live-dps">
        <span style="font-size:9px;letter-spacing:2px;color:var(--dim)">LIVE DPS</span>
        <span class="live-dps-val" id="live-dps-val">0</span>
      </div>
      <div class="x2-banner" id="x2-banner">üí∞ 2√ó INCOME <span id="x2-timer-display">3:00</span></div>
    </div>
    <div class="stat-pills" id="stat-pills-bar">
      <div class="stat-pill active" id="pill-dps">DPS: 0</div>
      <div class="stat-pill" id="pill-units">UNITS: 0</div>
      <div class="stat-pill" id="pill-kills">KILLS: 0</div>
      <div class="stat-pill" id="pill-idle">IDLE: 30%</div>
      <button class="log-toggle-btn" id="log-toggle-btn" onclick="toggleLogPanel()" title="Toggle log">‚ñ≤ LOG</button>
    </div>
    <div class="log-collapsible" id="log-collapsible">
      <div class="battle-log" id="battle-log"></div>
    </div>
    <div class="reward-bar">
      <button class="btn-reward rwd-bio" id="rwd-bio" onclick="rewardBio()">
        <span class="rwd-icon">üß¨</span>
        <span class="rwd-label">FREE BIOMASS</span>
        <span class="rwd-sub" id="rwd-bio-cd">watch ad</span>
        <span class="rwd-ad-note">üì∫ watch a short ad</span>
      </button>
      <button class="btn-reward rwd-gold" id="rwd-gold" onclick="rewardGold()">
        <span class="rwd-icon">‚öó</span>
        <span class="rwd-label">FREE GOLD</span>
        <span class="rwd-sub" id="rwd-gold-cd">watch ad</span>
        <span class="rwd-ad-note">üì∫ watch a short ad</span>
      </button>
      <button class="btn-reward rwd-res" id="rwd-res" onclick="rewardRes()">
        <span class="rwd-icon">üî¨</span>
        <span class="rwd-label">FREE RESEARCH</span>
        <span class="rwd-sub" id="rwd-res-cd">watch ad</span>
        <span class="rwd-ad-note">üì∫ watch a short ad</span>
      </button>
    </div>
    <div class="arena-footer">
      <button class="btn-start" id="btn-start" onclick="toggleWave()">‚ñ∂ START WAVE</button>
    </div>
  </div>

  <!-- RIGHT: Upgrades -->
  <div class="panel-upgrades">
    <div class="tabs">
      <div class="tab active" id="upgrade-tab-0" onclick="switchTab('upgrades')">‚ö° UPGRADES</div>
      <div class="tab" onclick="switchTab('research')">üî¨ RESEARCH</div>
      <div class="tab" onclick="switchTab('bioshop')" id="tab-bio-btn">üß¨ BIO</div>
    </div>
    <div class="tab-content active" id="tab-upgrades">
      <div class="upgrade-list" id="upgrade-list"></div>
    </div>
    <div class="tab-content" id="tab-research">
      <div class="upgrade-list" id="research-list"></div>
    </div>
    <div class="tab-content" id="tab-bioshop">
      <div class="upgrade-list" id="bioshop-list"></div>
    </div>
    <div class="prestige-section" id="prestige-section">
      <div class="prestige-bar-label">PRESTIGE PROGRESS ‚Äî GAIN: +<span id="prestige-gain">0</span> RES</div>
      <div class="prestige-bar-wrap">
        <div class="prestige-bar" id="prestige-bar" style="width:0%"></div>
      </div>
      <div style="font-size:9px;color:var(--dim);text-align:center;margin-bottom:6px;font-family:'Fredoka One',sans-serif;letter-spacing:0.4px">
        <span style="font-size:8px">Wave <span id="prestige-wave-progress">1</span> ¬∑ Resets run ¬∑ Keeps research</span>
      </div>
      <div style="font-size:9px;color:var(--dim);text-align:center;margin-bottom:6px;line-height:1.7;border:1px solid var(--border);padding:4px;border-radius:2px;font-family:'Fredoka One',sans-serif;letter-spacing:0.4px">
        BEST WAVE <span id="stat-best-wave" style="color:var(--blue)">‚Äî</span> &nbsp;|&nbsp;
        BEST KILLS <span id="stat-best-kills" style="color:var(--yellow)">‚Äî</span><br>
        RUNS <span id="stat-runs" style="color:var(--purple)">0</span>
      </div>
      <button class="btn-prestige" id="btn-prestige" id="btn-prestige-el" onclick="doPrestige()">‚ö° PRESTIGE</button>
      <div style="text-align:center;margin-top:8px">
        <button class="btn-reset" id="btn-reset-el" onclick="resetSave()" style="font-size:9px;padding:3px 10px;opacity:0.45;width:auto">
          ‚ö† RESET SAVE
        </button>
      </div>
    </div>
  </div>
</div>

<!-- MOBILE BOTTOM TAB BAR -->
<nav class="mobile-tabs" id="mobile-tabs">
  <button class="mobile-tab active" id="mtab-merge" onclick="switchMobileTab('merge')">
    <span class="tab-icon">‚¨°</span>MERGE
  </button>
  <button class="mobile-tab" id="mtab-arena" onclick="switchMobileTab('arena')">
    <span class="tab-icon">‚öî</span>ARENA
  </button>
  <button class="mobile-tab" id="mtab-upgrades" onclick="switchMobileTab('upgrades')">
    <span class="tab-icon">‚¨Ü</span>UPGRADES
  </button>
</nav>

<!-- RELIC PICKER -->
<div class="overlay-full" id="relic-overlay">
  <div class="relic-modal">
    <div class="relic-title">‚öó CHOOSE YOUR RELIC</div>
    <div class="relic-sub">This relic shapes your entire run. Choose wisely.</div>
    <div class="relic-cards" id="relic-cards"></div>
  </div>
</div>

<!-- WAVE EVENT POPUP -->
<div class="overlay-full" id="event-overlay">
  <div class="event-modal">
    <div class="event-title">‚ö° WAVE EVENT</div>
    <div class="event-sub">Choose one reward for the upcoming waves:</div>
    <div class="event-cards" id="event-cards"></div>
    <button class="btn-event-skip" onclick="closeEventPopup()">SKIP</button>
  </div>
</div>

<!-- TUTORIAL OVERLAY -->
<!-- INTRO SCREEN (static, before relic) -->
<div class="tutorial-overlay" id="tutorial-overlay">
  <div class="tutorial-box" style="max-width:480px">
    <div class="tutorial-header">
      <div class="tutorial-title" style="font-size:26px">‚¨° SLIME ARENA LAB</div>
      <div class="tutorial-subtitle" style="font-size:13px;margin-top:4px">Merge blobs ¬∑ Build an army ¬∑ Survive the waves</div>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:18px 0">
      <div class="tut-intro-card"><div class="tut-intro-icon">üí∞</div><div class="tut-intro-label">BUY blobs with gold</div></div>
      <div class="tut-intro-card"><div class="tut-intro-icon">‚¨°</div><div class="tut-intro-label">MERGE identical blobs</div></div>
      <div class="tut-intro-card"><div class="tut-intro-icon">‚öîÔ∏è</div><div class="tut-intro-label">FIGHT waves of enemies</div></div>
      <div class="tut-intro-card"><div class="tut-intro-icon">‚öó</div><div class="tut-intro-label">UPGRADE your lab</div></div>
    </div>
    <div style="font-size:10px;color:rgba(255,255,255,0.35);text-align:center;margin-bottom:16px;letter-spacing:0.5px">
      Boss waves every 10 ¬∑ Nightmare waves at 25, 50, 75 ¬∑ How far can you go?
    </div>
    <button class="btn-tutorial-start" onclick="closeTutorial()">‚ñ∂ CHOOSE YOUR RELIC</button>
  </div>
</div>

<!-- INTERACTIVE TUTORIAL TOOLTIP -->
<div id="synergy-popup"></div>

<div id="itut-backdrop" style="display:none;position:fixed;inset:0;z-index:4000;pointer-events:none"></div>
<div id="itut-box" style="display:none;position:fixed;z-index:4001;max-width:280px">
  <div id="itut-inner">
    <div id="itut-step-indicator"></div>
    <div id="itut-icon"></div>
    <div id="itut-title"></div>
    <div id="itut-desc"></div>
    <div id="itut-action-hint"></div>
    <button id="itut-skip" onclick="itutSkip()">skip tutorial</button>
  </div>
  <div id="itut-arrow"></div>
</div>

<!-- LOSE SCREEN -->
<div class="lose-screen" id="lose-screen">
  <div class="lose-sub">EXPERIMENT FAILED</div>
  <div class="lose-title">CONTAINMENT LOST</div>
  <div class="lose-wave">WAVE <span id="ls-wave">1</span> &nbsp;¬∑&nbsp; üèÜ BEST <span id="ls-wave-max">1</span></div>
  <div id="lose-lives-display" class="lives-wrap">
    <div class="lives-bar" id="lose-lives-bar">
      <span class="life-heart" id="lose-life-0">‚ù§Ô∏è</span>
      <span class="life-heart" id="lose-life-1">‚ù§Ô∏è</span>
      <span class="life-heart" id="lose-life-2">‚ù§Ô∏è</span>
    </div>
    <div class="lose-no-lives" id="lose-no-lives-msg" style="display:none">NO LIVES ‚Äî regen in <span id="lose-next-regen">20:00</span></div>
  </div>
  <div class="lose-stats">
    <div class="lose-stat"><div class="lose-stat-val" id="ls-kills">0</div><div class="lose-stat-lbl">KILLS</div></div>
    <div class="lose-stat"><div class="lose-stat-val" id="ls-gold">0</div><div class="lose-stat-lbl">GOLD EARNED</div></div>
    <div class="lose-stat"><div class="lose-stat-val" id="ls-res">0</div><div class="lose-stat-lbl">PRESTIGE GAIN</div></div>
  </div>
  <div class="lose-buttons">
    <button class="btn-lose btn-lose-retry" id="btn-lose-retry" onclick="loseRetry()">‚Ü∫ TRY AGAIN</button>
    <button class="btn-lose btn-lose-revive" id="btn-lose-revive" onclick="loseRevive()">üß™ REVIVE WAVE <span id="lose-revive-cost">50 SLM</span></button>
  </div>
</div>

<!-- SHOP MODAL -->
<div class="shop-overlay" id="shop-overlay" onclick="if(event.target===this)closeShop()">
  <div class="shop-modal" onclick="event.stopPropagation()">

    <div class="shop-header">
      <div class="shop-header-icon">üß™</div>
      <div class="shop-header-text">
        <div class="shop-title">LAB STORE</div>
        <div class="shop-subtitle">Spend Slime ¬∑ Support the lab</div>
      </div>
      <button onclick="closeShop()" style="
        background:none; border:1px solid rgba(255,255,255,0.15); color:rgba(255,255,255,0.5);
        font-size:18px; cursor:pointer; line-height:1; padding:6px 10px;
        border-radius:10px; flex-shrink:0; transition:all 0.15s;
      " onmouseover="this.style.color='#fff';this.style.borderColor='rgba(255,255,255,0.4)'"
         onmouseout="this.style.color='rgba(255,255,255,0.5)';this.style.borderColor='rgba(255,255,255,0.15)'">‚úï</button>
    </div>

    <!-- TABS -->
    <div class="shop-tabs">
      <button class="shop-tab-btn active" id="stab-lab" onclick="switchShopTab('lab')">üõí Lab Store</button>
      <button class="shop-tab-btn" id="stab-slime" onclick="switchShopTab('slime')">üß™ Buy Slime</button>
    </div>

    <!-- TAB: LAB STORE -->
    <div class="shop-tab-pane active" id="spane-lab">
      <div class="slime-balance-bar">
        üß™ Your Slime: <strong id="shop-lab-balance">0</strong> SLM
        <span style="flex:1"></span>
        <span style="font-size:10px;color:var(--dim);cursor:pointer" onclick="switchShopTab('slime')">+ Buy more ‚Üí</span>
      </div>

      <div class="shop-section-label">üîì Grid Expansion</div>

      <div class="shop-item" id="shop-slots4">
        <div class="shop-item-icon">üîì</div>
        <div class="shop-item-info">
          <div class="shop-item-name">+4 Grid Slots <span class="shop-item-badge new">NEW</span></div>
          <div class="shop-item-desc">Unlock 4 extra blob slots (12 ‚Üí 16). More units, more power.</div>
        </div>
        <button class="btn-shop-buy" id="btn-shop-slots4" onclick="shopBuy('slots4')">üß™ 80</button>
      </div>

      <div class="shop-item" id="shop-slots8">
        <div class="shop-item-icon">üîìüîì</div>
        <div class="shop-item-info">
          <div class="shop-item-name">Full Grid (20 Slots) <span class="shop-item-badge hot">HOT</span></div>
          <div class="shop-item-desc">All 20 blob slots unlocked. Includes +4 pack. Maximum mayhem.</div>
        </div>
        <button class="btn-shop-buy" id="btn-shop-slots8" onclick="shopBuy('slots8')">üß™ 150</button>
      </div>

      <div class="shop-section-label">‚ôæ Permanent Upgrades</div>

      <div class="shop-item" id="shop-noads">
        <div class="shop-item-icon">üö´</div>
        <div class="shop-item-info">
          <div class="shop-item-name">Remove Ads</div>
          <div class="shop-item-desc">Remove all ad prompts permanently. Support the lab.</div>
        </div>
        <button class="btn-shop-buy" id="btn-shop-noads" onclick="shopBuy('noads')">üß™ 100</button>
      </div>

      <div class="shop-item" id="shop-speed2x">
        <div class="shop-item-icon">‚ö°</div>
        <div class="shop-item-info">
          <div class="shop-item-name">Ultra Speed Pack</div>
          <div class="shop-item-desc">Unlock 8√ó and 10√ó speed. Free tier: 1√ó/2√ó/4√ó/6√ó.</div>
        </div>
        <button class="btn-shop-buy" id="btn-shop-speed2x" onclick="shopBuy('speed2x')">üß™ 250</button>
      </div>

      <div class="shop-item" id="shop-skins">
        <div class="shop-item-icon">üé®</div>
        <div class="shop-item-info">
          <div class="shop-item-name">Mutation Skins Pack</div>
          <div class="shop-item-desc">Neon / Void / Toxic visual variants for all blob tiers.</div>
        </div>
        <button class="btn-shop-buy" id="btn-shop-skins" onclick="shopBuy('skins')">üß™ 350</button>
      </div>

      <div id="skin-selector" style="display:none;margin-top:10px">
        <div style="font-size:9px;letter-spacing:2px;color:var(--dim);margin-bottom:8px;text-transform:uppercase">üé® Choose Skin</div>
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
          <button class="skin-btn" onclick="applySkin('')" id="skin-default" data-skin="">
            <span class="skin-dots"><span style="background:#6fdd4a"></span><span style="background:#5cb8ff"></span><span style="background:#ff7ee0"></span></span>
            DEFAULT
          </button>
          <button class="skin-btn" onclick="applySkin('neon')" data-skin="neon">
            <span class="skin-dots"><span style="background:#00ffea"></span><span style="background:#ff00ff"></span><span style="background:#ffff00"></span></span>
            NEON
          </button>
          <button class="skin-btn" onclick="applySkin('void')" data-skin="void">
            <span class="skin-dots"><span style="background:#9060ff"></span><span style="background:#6040cc"></span><span style="background:#c080ff"></span></span>
            VOID
          </button>
          <button class="skin-btn" onclick="applySkin('toxic')" data-skin="toxic">
            <span class="skin-dots"><span style="background:#aaff00"></span><span style="background:#ccff44"></span><span style="background:#00ff88"></span></span>
            TOXIC
          </button>
          <button class="skin-btn" onclick="applySkin('blood')" data-skin="blood">
            <span class="skin-dots"><span style="background:#ff2020"></span><span style="background:#cc0000"></span><span style="background:#ff6060"></span></span>
            BLOOD
          </button>
          <button class="skin-btn" onclick="applySkin('ice')" data-skin="ice">
            <span class="skin-dots"><span style="background:#a0e8ff"></span><span style="background:#c0f0ff"></span><span style="background:#ffffff"></span></span>
            ICE
          </button>
          <button class="skin-btn" onclick="applySkin('gold')" data-skin="gold">
            <span class="skin-dots"><span style="background:#ffd700"></span><span style="background:#ffb800"></span><span style="background:#ffe040"></span></span>
            GOLD
          </button>
          <button class="skin-btn" onclick="applySkin('shadow')" data-skin="shadow">
            <span class="skin-dots"><span style="background:#444466"></span><span style="background:#556688"></span><span style="background:#9900ff"></span></span>
            SHADOW
          </button>
          <button class="skin-btn" onclick="applySkin('cyber')" data-skin="cyber">
            <span class="skin-dots"><span style="background:#00ffcc"></span><span style="background:#ff00aa"></span><span style="background:#ffff00"></span></span>
            CYBER
          </button>
        </div>
      </div>
    </div>

    <!-- TAB: BUY SLIME -->
    <div class="shop-tab-pane" id="spane-slime">
      <div class="slime-balance-bar">
        üß™ Your Slime: <strong id="shop-slime-balance">0</strong> SLM
      </div>

      <div class="slime-pack-grid">
        <div class="slime-pack" onclick="buySlimePack('small')">
          <div class="slime-pack-icon">üß™</div>
          <div class="slime-pack-name">Small Vial</div>
          <div class="slime-pack-amount">100 <span>SLM</span></div>
          <div class="slime-pack-price">$0.99</div>
        </div>

        <div class="slime-pack popular" onclick="buySlimePack('medium')">
          <div class="slime-pack-badge popular-badge">POPULAR</div>
          <div class="slime-pack-icon">‚öó</div>
          <div class="slime-pack-name">Lab Flask</div>
          <div class="slime-pack-amount">300 <span>SLM</span></div>
          <div class="slime-pack-price">$2.49</div>
        </div>

        <div class="slime-pack" onclick="buySlimePack('large')">
          <div class="slime-pack-icon">ü´ß</div>
          <div class="slime-pack-name">Mega Barrel</div>
          <div class="slime-pack-amount">700 <span>SLM</span></div>
          <div class="slime-pack-price">$4.99</div>
        </div>

        <div class="slime-pack popular" onclick="buySlimePack('mega')">
          <div class="slime-pack-badge best">BEST VALUE</div>
          <div class="slime-pack-icon">üíö</div>
          <div class="slime-pack-name">MEGA Bundle</div>
          <div class="slime-pack-amount">1600 <span>SLM</span></div>
          <div class="slime-pack-price">$9.99</div>
        </div>
      </div>

      <div class="slime-note">
        üß™ Slime is the premium currency of Slime Arena Lab.<br>
        Prices shown are for prototype only ¬∑ Real payments not processed.
      </div>
    </div>

    <div class="shop-footer">
      <button class="btn-shop-close" onclick="closeShop()">‚úï CLOSE</button>
    </div>

  </div>
</div>

<!-- WIN SCREEN -->
<div class="win-screen" id="win-screen">
  <div class="win-sub">EXPERIMENT COMPLETE</div>
  <div class="win-title">CONTAINMENT BREACH</div>
  <div class="win-flavour">"The subjects have overcome every obstacle. The lab cannot hold them any longer. What have we created?"</div>
  <div class="win-stats">
    <div class="win-stat"><div class="win-stat-val" id="ws-kills">0</div><div class="win-stat-lbl">KILLS</div></div>
    <div class="win-stat"><div class="win-stat-val" id="ws-gold">0</div><div class="win-stat-lbl">GOLD EARNED</div></div>
    <div class="win-stat"><div class="win-stat-val" id="ws-res">0</div><div class="win-stat-lbl">PRESTIGE GAIN</div></div>
  </div>
  <div class="win-buttons">
    <button class="btn-win btn-win-prestige" onclick="winPrestige()">‚ö° PRESTIGE NOW</button>
    <button class="btn-win btn-win-continue" onclick="winContinue()">‚ñ∂ KEEP FIGHTING</button>
  </div>
</div>

<div id="wave-cleared-banner">
  <div class="wcb-wave" id="wcb-wave-num">WAVE 1</div>
  <div class="wcb-title">CLEARED!</div>
  <div class="wcb-gold" id="wcb-gold">+0 GOLD</div>
</div>

<div class="idle-badge" id="idle-popup">
  <div class="idle-title">OFFLINE EARNINGS</div>
  <div class="idle-amount" id="idle-amount">0 GOLD</div>
  <button class="btn-collect" onclick="collectIdle()">COLLECT</button>
</div>

<script>
(function(){
  var _a=atob('RXN0ZWwgSVQgTWF0ZXVzeiBSdXNuYWs='); // SlimeArenaLab
  var _b=atob('wqkgMjAyNSBFc3RlbCBJVCBNYXRldXN6IFJ1c25hay4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTklQOiA2MzIyMDM4OTUx');
  window.__gameAuthor = _a;
  window.__gameCopy   = _b;
  // Self-check: if someone changed the page title, log warning
  if(typeof document !== 'undefined'){
    var _t = document.title || '';
    if(_t && _t.indexOf('SLIME')===-1 && _t.indexOf('Slime')===-1){
      console.warn('[SAL] Unauthorized distribution detected. ' + _b);
    }
  }
})();

let audioCtx = null;
let soundEnabled = false;
function initAudio() {
 if (audioCtx) return;
 audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
let musicVolume = 0.45; 
let sfxVolume = 0.70; 
const AUDIO_KEY = 'auto_arena_audio';
function saveAudioSettings() {
 try {
 const json = JSON.stringify({ soundEnabled, musicVolume, sfxVolume });
 _memSave_audio = json;
 if (_hasLocal) { try { localStorage.setItem(AUDIO_KEY, json); } catch(e) {} }
 else if (_hasSession) { try { sessionStorage.setItem(AUDIO_KEY, json); } catch(e) {} }
 } catch(e) {}
}
let _memSave_audio = null;
function loadAudioSettings() {
 try {
 let raw = null;
 if (_hasLocal) { try { raw = localStorage.getItem(AUDIO_KEY); } catch(e) {} }
 if (!raw && _hasSession) { try { raw = sessionStorage.getItem(AUDIO_KEY); } catch(e) {} }
 if (!raw) raw = _memSave_audio;
 if (!raw) return;
 const d = JSON.parse(raw);
 musicVolume = d.musicVolume ?? 0.45;
 sfxVolume = d.sfxVolume ?? 0.70;
 soundEnabled = d.soundEnabled ?? false;
 const sm = document.getElementById('slider-music');
 const ss = document.getElementById('slider-sfx');
 const mv = Math.round(musicVolume * 100);
 const sv = Math.round(sfxVolume * 100);
 if (sm) { sm.value = mv; updateSliderFill('slider-music', mv); document.getElementById('val-music').textContent = mv; }
 if (ss) { ss.value = sv; updateSliderFill('slider-sfx', sv); document.getElementById('val-sfx').textContent = sv; }
 const btn = document.getElementById('btn-sound');
 if (btn) { btn.textContent = soundEnabled ? t('btnSfxOn') : t('btnSfx'); btn.className = 'btn-sound' + (soundEnabled ? ' on' : ''); }
 const toggleBtn = document.getElementById('vol-toggle-btn');
 if (toggleBtn) { if (toggleBtn) toggleBtn.textContent = soundEnabled ? t('audioOn') : t('audioOff'); toggleBtn.style.color = soundEnabled ? 'var(--green)' : 'var(--text2)'; }
 const music = document.getElementById('bg-music');
 if (music) music.volume = musicVolume;
 } catch(e) {}
}
function setMusicVol(v) {
 musicVolume = v / 100;
 const music = document.getElementById('bg-music');
 if (music) music.volume = musicVolume;
 document.getElementById('val-music').textContent = v;
 updateSliderFill('slider-music', v);
 saveAudioSettings();
}
function setSfxVol(v) {
 sfxVolume = v / 100;
 document.getElementById('val-sfx').textContent = v;
 updateSliderFill('slider-sfx', v);
 saveAudioSettings();
}
function updateSliderFill(id, v) {
 const el = document.getElementById(id);
 if (!el) return;
 el.style.background = `linear-gradient(to right, var(--blue) 0%, var(--blue) ${v}%, rgba(255,255,255,0.15) ${v}%)`;
}
function toggleVolPanel(e) {
 e.stopPropagation();
 document.getElementById('vol-panel').classList.toggle('open');
}
document.addEventListener('click', () => {
 const p = document.getElementById('vol-panel');
 if (p) p.classList.remove('open');
});
function openVolPanel(e) {
 e.stopPropagation();
 initAudio();
 const panel = document.getElementById('vol-panel');
 panel.classList.toggle('open');
}
function toggleSound() {
 soundEnabled = !soundEnabled;
 const btn = document.getElementById('btn-sound');
 btn.textContent = soundEnabled ? t('btnSfxOn') : t('btnSfx');
 btn.className = 'btn-sound' + (soundEnabled ? ' on' : '');
 const toggleBtn = document.getElementById('vol-toggle-btn');
 if (toggleBtn) if (toggleBtn) toggleBtn.textContent = soundEnabled ? t('audioOn') : t('audioOff');
 if (toggleBtn) toggleBtn.style.color = soundEnabled ? 'var(--green)' : 'var(--text2)';
 const music = document.getElementById('bg-music');
 if (soundEnabled) {
 if (music) { music.volume = musicVolume; music.play().catch(()=>{}); }
 sfx.tick();
 } else {
 if (music) music.pause();
 }
 saveAudioSettings();
}
function playTone(freq, type, vol, attack, sustain, release, startFreq = null) {
 if (!soundEnabled || !audioCtx) return;
 const osc = audioCtx.createOscillator();
 const gain = audioCtx.createGain();
 const filter = audioCtx.createBiquadFilter();
 filter.type = 'lowpass';
 filter.frequency.value = 3000;
 osc.connect(filter);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 osc.type = type;
 const now = audioCtx.currentTime;
 if (startFreq) {
 osc.frequency.setValueAtTime(startFreq, now);
 osc.frequency.exponentialRampToValueAtTime(freq, now + attack);
 } else {
 osc.frequency.setValueAtTime(freq, now);
 }
 const _vol = vol * (typeof sfxVolume !== "undefined" ? sfxVolume : 1);
 gain.gain.setValueAtTime(0, now);
 gain.gain.linearRampToValueAtTime(_vol, now + attack);
 gain.gain.setValueAtTime(_vol, now + attack + sustain);
 gain.gain.exponentialRampToValueAtTime(0.001, now + attack + sustain + release);
 osc.start(now);
 osc.stop(now + attack + sustain + release + 0.01);
}
function playNoise(vol, dur, freq = 2000) {
 if (!soundEnabled || !audioCtx) return;
 const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
 const data = buf.getChannelData(0);
 for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
 const src = audioCtx.createBufferSource();
 src.buffer = buf;
 const filter = audioCtx.createBiquadFilter();
 filter.type = 'bandpass';
 filter.frequency.value = freq;
 filter.Q.value = 0.5;
 const gain = audioCtx.createGain();
 const _nvol = vol * (typeof sfxVolume !== "undefined" ? sfxVolume : 1);
 gain.gain.setValueAtTime(_nvol, audioCtx.currentTime);
 gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
 src.connect(filter);
 filter.connect(gain);
 gain.connect(audioCtx.destination);
 src.start();
}
const sfx = {
 buy() {
 playTone(660, 'sine', 0.05, 0.005, 0.015, 0.08);
 },
 merge(tier) {
 const roots = [0, 261, 330, 392, 523, 659, 784, 880, 987, 1047, 1175];
 const r = roots[Math.min(tier, roots.length - 1)];
 playTone(r, 'sine', 0.07, 0.008, 0.05, 0.18);
 setTimeout(() => playTone(r * 1.5, 'sine', 0.04, 0.005, 0.03, 0.14), 65);
 },
 mutant() {
 playTone(880, 'sine', 0.07, 0.005, 0.04, 0.20);
 setTimeout(() => playTone(1320, 'sine', 0.05, 0.005, 0.05, 0.22), 75);
 },
 tick() { playTone(1047, 'sine', 0.03, 0.002, 0.01, 0.04); },
 heal() {
  // Miƒôkki, pozytywny d≈∫wiƒôk healowania ‚Äî rosnƒÖce nuty
  playTone(523, 'sine', 0.04, 0.01, 0.08, 0.18);
  setTimeout(() => playTone(659, 'sine', 0.035, 0.01, 0.07, 0.16), 80);
  setTimeout(() => playTone(784, 'sine', 0.03, 0.01, 0.10, 0.22), 160);
 },
 prestige() {
 [261, 329, 392, 523, 659].forEach((f, i) =>
 setTimeout(() => playTone(f, 'sine', 0.06, 0.01, 0.07, 0.18), i * 75));
 setTimeout(() => playTone(1047, 'sine', 0.07, 0.01, 0.15, 0.30), 420);
 },
 kill() {
 playNoise(0.025, 0.04, 1600);
 playTone(180, 'sine', 0.03, 0.002, 0.01, 0.04, 260);
 },
 crit() {
 playTone(1320, 'sine', 0.06, 0.002, 0.02, 0.10);
 playNoise(0.03, 0.05, 3500);
 setTimeout(() => playTone(1760, 'triangle', 0.04, 0.002, 0.02, 0.08), 25);
 },
 waveStart() {
 [261, 392, 523].forEach((f, i) =>
 setTimeout(() => playTone(f, 'sine', 0.05, 0.01, 0.05, 0.12), i * 80));
 },
 waveEnd(victory) {
 if (victory) {
 [523, 659, 784, 1047].forEach((f, i) =>
 setTimeout(() => playTone(f, 'sine', 0.06, 0.01, 0.06, 0.14), i * 70));
 } else {
 [440, 349, 294].forEach((f, i) =>
 setTimeout(() => playTone(f, 'triangle', 0.05, 0.01, 0.05, 0.14), i * 90));
 }
 },
 boss() {
 [120, 90].forEach((f, i) =>
 setTimeout(() => {
 playTone(f, 'sawtooth', 0.07, 0.005, 0.10, 0.20);
 playNoise(0.04, 0.08, 150);
 }, i * 130));
 },
 gold() {},
 foodPickup(color) {
  // Radosny dwutonowy "pickup" jingle
  playTone(784, 'sine', 0.08, 0.005, 0.04, 0.12);
  setTimeout(() => playTone(1047, 'sine', 0.07, 0.005, 0.06, 0.16), 70);
  setTimeout(() => playTone(1319, 'sine', 0.06, 0.005, 0.08, 0.20), 145);
 },
 eventShield() {},
 eventRegen() {},
 eventGold() {},
 eventCrit() {},
 eventOverclock(){},
 eventToxic() {},
 eventElite() {},
 eventMeteor() {},
};
let gameSpeed = 1;
let shopOwned = { noads: false, speed2x: false, skins: false, slots4: false, slots8: false };
let slimePurchases = { pack1: 0, pack2: 0, pack3: 0 }; 
const G = {
 gold: 60,
 biomass: 0,
 research: 0,
 slime: 0,
 bioDPS: 0,
 bioHP: 0,
 bioGold: 0,
 bioMerge: 0,
 bioSpawn: 0,
 bioElite: 0,
 wave: 1,
 prestige: 0,
 kills: 0,
 totalDPS: 0,
 idleEfficiency: 0.06,
 autoMerge: false,
 fighting: false,
 waveTime: 0,
 waveMaxTime: 30,
 lastSave: Date.now(),
 bestWave: 1,
 bestKills: 0,
 totalRuns: 0,
 lives: 3,
 livesLastRegen: [0, 0, 0], // timestamp gdy ≈ºycie zosta≈Ço utracone
 tutorialSeen: false,
 relicSeen: false, 
 activeRelic: null, 
 activeEffects: [], 
 synergyBonuses: {}, 
 upgrades: {
 automerge_unlock: false,
 idle_boost: 0,
 merge_luck: 0,
 spawn_rate: 0,
 dps_boost: 0,
 start_tier: false,
 gold_boost: 0,
 hp_boost: 0,
 elite_chance: 0,
 mass_merge: false,
 },
 researchBonuses: {
 merge_chance: 0,
 offline_pct: 0,
 mutation_chance: 0,
 spawn_rate_res: 0,
 gold_mult: 0,
 dps_research: 0,
 elite_res: 0,
 blob_hp: 0,
 wave_speed: 0,
 prestige_boost: 0,
 }
};
const GRID_SIZE = 20;
const MAX_WAVE = Infinity;
let grid = Array(GRID_SIZE).fill(null);
let selectedCell = null;
let dragSrc = null;
function waveGoldReward(wave) {
 wave = wave || 1;
 const base = 12 + Math.pow(wave, 1.55) * 1.4;
 const boss = isBossWave(wave) ? 3 : 1;
 const presBonus = 1 + (G.prestige || 0) * 0.15;
 const upgradeBonus = 1 + (G.upgrades?.idle_boost || 0) * 0.25;
 const goldMult = 1 + (G.researchBonuses?.gold_mult || 0) * 0.10 + (G.upgrades?.gold_boost || 0) * 0.15;
 const bioMult = 1 + (G.bioGold || 0);
 const result = Math.floor(base * boss * presBonus * upgradeBonus * goldMult * bioMult);
 return isNaN(result) ? 12 : result;
}
function getBuyCost() {
 const base = Math.floor(10 + Math.pow(G.wave, 2.1) * 1.8);
 const mult = G.activeRelic === 'economy' ? 1.5 : 1;
 return Math.floor(base * mult);
}
function idleGoldPerSec() {
 return Math.sqrt(G.totalDPS) * 0.006 * (G.idleEfficiency / 0.30);
}
const UNIT_TYPES = [
 null,
 { name: 'BLOB', emoji: 'üü¢', dps: 4, speed: 1.0, tags: ['BIO'],
 role: 'support', roleDesc: 'Buffs adjacent allies +8% DPS.',
 traitDesc: 'Basic melee. Charges into range.' },
 { name: 'SPITTER', emoji: 'üîµ', dps: 15, speed: 1.3, tags: ['TOXIC'],
 role: 'sniper', roleDesc: 'Targets furthest enemy. Ignores nearby.',
 traitDesc: 'Fires at distant enemies first.' },
 { name: 'SPLITTER', emoji: 'ü©∑', dps: 50, speed: 0.8, tags: ['BIO','TOXIC'],
 role: 'exploder', roleDesc: 'On death: AoE explosion around self.',
 traitDesc: '35% chance to spawn a weak clone on kill.' },
 { name: 'MAGNET', emoji: 'üü†', dps: 160, speed: 1.1, tags: ['MECH'],
 role: 'tank', roleDesc: 'High HP. Pulls enemies to self. Shields allies.',
 traitDesc: 'Randomly yanks nearby enemies toward itself.' },
 { name: 'REACTOR', emoji: 'üü£', dps: 520, speed: 1.5, tags: ['FIRE','MECH'],
 role: 'leech', roleDesc: 'Heals 15% of damage dealt.',
 traitDesc: 'Damages ALL enemies within blast radius.' },
 { name: 'ANOMALY', emoji: '‚ö™', dps: 1700, speed: 2.0, tags: ['FIRE','BIO','TOXIC','MECH'],
 role: 'glasscannon', roleDesc: '3√ó DPS but only 30% HP.',
 traitDesc: 'Fires chaotic bolts. Unstable but devastating.' },
 { name: 'PHANTOM', emoji: 'ü©µ', dps: 5600, speed: 2.3, tags: ['BIO','FIRE'],
 role: 'sniper', roleDesc: 'Targets furthest enemy. Phase-shifts when low HP.',
 traitDesc: 'Becomes briefly invulnerable at 25% HP. High single-target DPS.' },
 { name: 'COLOSSUS', emoji: 'üü§', dps: 18000, speed: 0.65, tags: ['MECH'],
 role: 'tank', roleDesc: 'Massive HP pool. Stomps nearby enemies.',
 traitDesc: 'Stomp stuns enemies in range 0.4s. Nearly unkillable.' },
 { name: 'VOIDLING', emoji: 'üñ§', dps: 60000, speed: 1.9, tags: ['TOXIC','FIRE'],
 role: 'glasscannon', roleDesc: 'Extreme DPS but only 20% HP.',
 traitDesc: 'Corrupts enemies ‚Äî reduces their max HP by 15% on hit.' },
 { name: 'OMEGA', emoji: 'üí•', dps:200000, speed: 2.1, tags: ['BIO','FIRE','TOXIC','MECH'],
 role: 'leech', roleDesc: 'All tags. Heals 25% of damage dealt.',
 traitDesc: 'Cosmic entity. All friendly units gain +20% DPS while alive.' },
];
const UNIT_HP_BASE = [0, 100, 160, 220, 550, 400, 700, 500, 2000, 1500, 1200];
function getUnitDPS(tier, mutant, synergyMult, cellIdx) {
 const base = (UNIT_TYPES[tier]?.dps) || (tier > 10 ? 200000 : 4);
 const p = 1 + G.prestige * 0.20;
 const u = 1 + G.upgrades.dps_boost * 0.30 + G.researchBonuses.dps_research * 0.25;
 const m = mutant ? 2.2 : 1;
 const syn = synergyMult || 1;
 const relic = G.activeRelic === 'berserker' ? 1.4 : 1;
 const rowMult = (cellIdx !== undefined) ? getRowDPS(cellIdx) : 1;
 const streakMult = getMergeStreakBonus();
 // Special unit dps multi
 const cell = (cellIdx !== undefined) ? grid[cellIdx] : null;
 const specialMult = (cell?.dpsMulti) ? cell.dpsMulti : 1;
 return Math.floor(base * p * u * m * syn * relic * rowMult * streakMult * specialMult);
}
function getUnitHP(tier, role, cellIdx) {
 const base = UNIT_HP_BASE[Math.min(tier, UNIT_HP_BASE.length - 1)] || 100;
 const rowHpMult = (cellIdx !== undefined) ? getRowHP(cellIdx) : 1;
 const cell = (cellIdx !== undefined) ? grid[cellIdx] : null;
 if (role === 'tank') return Math.floor(base * 3.5 * rowHpMult);
 if (role === 'glasscannon') return Math.floor(base * 0.3 * rowHpMult);
 if (role === 'leech') return Math.floor(base * 1.4 * rowHpMult);
 return Math.floor(base * rowHpMult);
}
function calcTotalDPS() {
 calcSynergies();
 return grid.reduce((s, c, i) => c ? s + getUnitDPS(c.tier, c.mutant, getSynergyMultForUnit(c.tier) * getAdjacencyMult(i), i) : s, 0);
}
const SYNERGY_DEFS = {
 // icon, color, name, perUnitBonus (% DPS per unit), maxUnits cap, special effect label
 BIO:  { icon:'üåø', color:'#4ade80', name:'Bio Cluster',  perUnit:0.07, specialAt:6, special:'+ Regen',   desc:'Each BIO unit adds +7% DPS. 6+ unlocks team regen.' },
 TOXIC:{ icon:'‚ò†Ô∏è',  color:'#a3e635', name:'Toxic Cloud',  perUnit:0.08, specialAt:6, special:'+ DOT Aura', desc:'Each TOXIC unit adds +8% DPS. 6+ poisons all enemies.' },
 FIRE: { icon:'üî•', color:'#fb923c', name:'Fire Storm',   perUnit:0.09, specialAt:6, special:'+ Burn',     desc:'Each FIRE unit adds +9% DPS. 6+ ignites on hit.' },
 MECH: { icon:'‚öôÔ∏è', color:'#60a5fa', name:'Mech Core',    perUnit:0.06, specialAt:6, special:'+ Shield',   desc:'Each MECH unit adds +6% DPS + armor. 6+ grants shields.' },
};
// ‚îÄ‚îÄ SYNERGY COMBOS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SYNERGY_COMBOS = [
 { tags: ['BIO','TOXIC'], name: 'PLAGUE CLOUD',  icon: 'ü¶†', color: '#84cc16',
   minEach: 3, dpsBonus: 0.25, desc: 'BIO+TOXIC ‚â•3 each: +25% all DPS + plague DOT on kill' },
 { tags: ['FIRE','MECH'], name: 'INFERNO CORE',  icon: 'üî©', color: '#f97316',
   minEach: 3, dpsBonus: 0.30, desc: 'FIRE+MECH ‚â•3 each: +30% all DPS + armor shred' },
 { tags: ['BIO','MECH'],  name: 'BIO-MECH',      icon: 'ü§ñ', color: '#22d3ee',
   minEach: 3, dpsBonus: 0.20, desc: 'BIO+MECH ‚â•3 each: +20% all DPS + self-repair' },
 { tags: ['FIRE','TOXIC'],'name': 'VENOM BLAZE',  icon: 'üåã', color: '#c084fc',
   minEach: 3, dpsBonus: 0.22, desc: 'FIRE+TOXIC ‚â•3 each: +22% all DPS + burning poison' },
];
function getActiveCombo(counts) {
 for (const combo of SYNERGY_COMBOS) {
  if (combo.tags.every(t => (counts[t] || 0) >= combo.minEach)) return combo;
 }
 return null;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  ROW BONUS SYSTEM ‚Äî 4√ó5 grid, rows give special bonuses
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const ROW_DEFS = [
  { row: 0, name: 'TANK',     color: '#ff453a', bonus: { hp: 0.35, shield: true },
    desc: '+35% HP ¬∑ Gives shield to all allies every 8s', icon: 'üõ°', overlayClass: 'row-glow-front', cellClass: 'row-front' },
  { row: 1, name: 'DPS',      color: '#5ac8fa', bonus: { dps: 0.30 },
    desc: '+30% DPS ¬∑ Crit aura: +10% crit chance to row', icon: '‚ö°', overlayClass: 'row-glow-mid', cellClass: 'row-mid' },
  { row: 2, name: 'BRUISER',  color: '#fb923c', bonus: { dps: 0.15, hp: 0.15, taunt: true },
    desc: '+15% DPS +15% HP ¬∑ Taunts enemies every 6s', icon: 'üî•', overlayClass: 'row-glow-mid', cellClass: 'row-mid' },
  { row: 3, name: 'ASSASSIN', color: '#bf5af2', bonus: { dps: 0.50, fragile: true },
    desc: '+50% DPS ¬∑ -20% HP ¬∑ Stealth burst every 10s', icon: 'üó°', overlayClass: 'row-glow-back', cellClass: 'row-back' },
  { row: 4, name: 'SUPPORT',  color: '#4cd964', bonus: { support: true },
    desc: 'Heals allies every 5s ¬∑ Passive gold', icon: 'üåø', overlayClass: 'row-glow-support', cellClass: 'row-support' },
];
function getRowDef(cellIdx) {
  return ROW_DEFS[Math.floor(cellIdx / 4)];
}
function getRowDPS(cellIdx) {
  const r = getRowDef(cellIdx);
  if (!r) return 1;
  return 1 + (r.bonus.dps || 0);
}
function getRowHP(cellIdx) {
  const r = getRowDef(cellIdx);
  if (!r) return 1;
  let mult = 1 + (r.bonus.hp || 0);
  if (r.bonus.fragile) mult *= 0.80; // ASSASSIN -20% HP
  return mult;
}
// Support row passives ‚Äî applied each second in game loop
function applyRowSupportEffects() {
  const supportRowStart = 16; // row 4 = indices 16-19
  const playableSupport = [16,17,18,19].filter(i => {
    if (G.activeRelic === 'fortress') return i < 12;
    return isSlotPlayable(i);
  });
  const supportUnits = playableSupport.filter(i => grid[i]);
  const count = supportUnits.length;
  if (count === 0) return;
  if (!G._supportTick) G._supportTick = 0;
  G._supportTick++;
  if (G._supportTick % 5 === 0) {
    // ‚îÄ‚îÄ HEAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const healPct = 0.04 + count * 0.015; // 4% base + 1.5% per support unit
    let totalHealed = 0;
    arenaUnits.forEach(u => {
      if (u.hp >= u.maxHp) return;
      const heal = Math.floor(u.maxHp * healPct);
      u.hp = Math.min(u.maxHp, u.hp + heal);
      totalHealed += heal;
      // Floating heal number na ka≈ºdej jednostce
      if (typeof addFloatDmg === 'function') {
        addFloatDmg(`+${formatNum(heal)}`, u.x, u.y - 10, '#4cd964', false);
      }
    });

    // ‚îÄ‚îÄ SFX ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (totalHealed > 0 && sfx?.heal) sfx.heal();
    else if (totalHealed > 0) sfx?.buy?.();

    // ‚îÄ‚îÄ VFX ‚Äî zielone fale z ka≈ºdej jednostki support ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    arenaUnits
      .filter(u => u.formationRow === 4)
      .forEach(u => {
        spawnHealPulse(u.x, u.y, count);
      });

    // ‚îÄ‚îÄ Notif ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (totalHealed > 0) {
      addLog?.(`üíö Support healed allies for ${formatNum(totalHealed)} HP`, 'wave');
    }

    if (count >= 2) {
      const bonus = Math.floor(count * 2);
      G.gold += bonus;
      updateCurrencies();
    }
  }
}

// ‚îÄ‚îÄ ROW ACTIVE ABILITIES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if (!window._rowTicks) window._rowTicks = { tank: 0, bruiser: 0, assassin: 0 };

function applyRowActiveEffects() {
  if (!G.fighting) return;
  window._rowTicks.tank     = (window._rowTicks.tank     || 0) + 1;
  window._rowTicks.bruiser  = (window._rowTicks.bruiser  || 0) + 1;
  window._rowTicks.assassin = (window._rowTicks.assassin || 0) + 1;

  // ‚îÄ‚îÄ TANK (row 0) ‚Äî Shield burst every 8s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const tankUnits = arenaUnits.filter(u => u.formationRow === 0);
  if (tankUnits.length > 0 && window._rowTicks.tank >= 8) {
    window._rowTicks.tank = 0;
    const shieldAmt = tankUnits.reduce((s, u) => s + u.maxHp, 0) / tankUnits.length * 0.15 * tankUnits.length;
    arenaUnits.forEach(u => {
      u.shield = (u.shield || 0) + Math.floor(u.maxHp * 0.15);
    });
    sfx.heal?.();
    // VFX ‚Äî niebieskie fale z ka≈ºdego tanka
    tankUnits.forEach(u => {
      for (let i = 0; i < 3; i++) {
        _healPulses.push({ x: u.x, y: u.y, r: 0, maxR: 70, alpha: 0.7, delay: i * 0.1, life: 0, color: '#5ac8fa' });
      }
    });
    showNotif(`üõ° Tank Shield! All allies +15% HP shield`, '#5ac8fa');
    addLog('üõ° TANK: Shield granted to all allies!', 'wave');
  }

  // ‚îÄ‚îÄ BRUISER (row 2) ‚Äî Taunt every 6s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const bruiserUnits = arenaUnits.filter(u => u.formationRow === 2);
  if (bruiserUnits.length > 0 && window._rowTicks.bruiser >= 6) {
    window._rowTicks.bruiser = 0;
    // Wszystkie wrogi celujƒÖ w bruiser√≥w przez 3s
    enemies.forEach(e => {
      e._taunted = true;
      e._tauntTarget = bruiserUnits[Math.floor(Math.random() * bruiserUnits.length)];
      setTimeout(() => { if (e) { e._taunted = false; e._tauntTarget = null; } }, 3000);
    });
    // VFX ‚Äî pomara≈Ñczowe iskry z ka≈ºdego bruisera
    bruiserUnits.forEach(u => {
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        _healPulses.push({ cross: true, x: u.x, y: u.y,
          vx: Math.cos(angle) * 55, vy: Math.sin(angle) * 55 - 15,
          alpha: 1, life: 0, maxLife: 0.6, color: '#fb923c' });
      }
      _healPulses.push({ x: u.x, y: u.y, r: 0, maxR: 50, alpha: 0.6, delay: 0, life: 0, color: '#fb923c' });
    });
    sfx.waveStart?.();
    addLog('üî• BRUISER: Taunt! Enemies forced to attack bruisers!', 'wave');
  }

  // ‚îÄ‚îÄ ASSASSIN (row 3) ‚Äî Stealth burst every 10s ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const assassinUnits = arenaUnits.filter(u => u.formationRow === 3);
  if (assassinUnits.length > 0 && window._rowTicks.assassin >= 10) {
    window._rowTicks.assassin = 0;
    // Burst dmg na losowych wrogach
    const burstDmg = assassinUnits.reduce((s, u) => s + u.dps * 3, 0);
    const targets = [...enemies].sort(() => Math.random() - 0.5).slice(0, assassinUnits.length * 2);
    targets.forEach(e => {
      if (!e || e.hp <= 0) return;
      const dmg = Math.floor(burstDmg / Math.max(1, targets.length));
      e.hp -= dmg;
      if (typeof addFloatDmg === 'function') addFloatDmg(`üíÄ${formatNum(dmg)}`, e.x, e.y - 10, '#bf5af2', true);
      if (e.hp <= 0) onEnemyKill(e, assassinUnits[0]);
    });
    // VFX ‚Äî fioletowe b≈Çyski z assassin√≥w
    assassinUnits.forEach(u => {
      u._stealthFlash = 0.5; // trigger visual flash
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        _healPulses.push({ cross: true, x: u.x, y: u.y,
          vx: Math.cos(angle) * 70, vy: Math.sin(angle) * 70 - 20,
          alpha: 1, life: 0, maxLife: 0.5, color: '#bf5af2' });
      }
      _healPulses.push({ x: u.x, y: u.y, r: 0, maxR: 60, alpha: 0.7, delay: 0, life: 0, color: '#bf5af2' });
    });
    sfx.crit?.();
    showNotif(`üó° Assassin Burst! ${formatNum(burstDmg)} damage!`, '#bf5af2');
    addLog(`üó° ASSASSIN: Stealth burst for ${formatNum(burstDmg)} dmg!`, 'boss');
  }
}


let _healPulses = [];
function spawnHealPulse(x, y, count) {
  const rings = 2 + count;
  for (let i = 0; i < rings; i++) {
    _healPulses.push({
      x, y,
      r: 0,
      maxR: 80 + count * 20,
      alpha: 0.8,
      delay: i * 0.12,
      life: 0,
    });
  }
  // Drobne czƒÖsteczki krzy≈ºyk√≥w +
  for (let i = 0; i < 6 + count * 2; i++) {
    const angle = (i / (6 + count * 2)) * Math.PI * 2;
    const speed = 40 + Math.random() * 30;
    _healPulses.push({
      cross: true,
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 20,
      alpha: 1,
      life: 0,
      maxLife: 0.7,
    });
  }
}

function drawHealPulses(dt) {
  if (!_healPulses.length) return;
  _healPulses = _healPulses.filter(p => {
    p.life += dt;
    if (p.delay && p.life < p.delay) return true;
    const t = p.delay ? (p.life - p.delay) : p.life;
    const col = p.color || '#4cd964';

    if (p.cross) {
      if (t > p.maxLife) return false;
      const prog = t / p.maxLife;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 60 * dt;
      ctx.save();
      ctx.globalAlpha = (1 - prog) * p.alpha;
      ctx.fillStyle = col;
      ctx.shadowColor = col; ctx.shadowBlur = 8;
      ctx.font = `bold ${Math.floor(10 + (1-prog)*4)}px sans-serif`;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(p.color === '#4cd964' ? '+' : p.color === '#bf5af2' ? '‚ú¶' : '!', p.x, p.y);
      ctx.restore();
      return true;
    } else {
      const maxT = 0.65;
      if (t > maxT) return false;
      const prog = t / maxT;
      p.r = p.maxR * prog;
      p.alpha = (1 - prog) * 0.6;
      ctx.save();
      ctx.globalAlpha = p.alpha;
      ctx.strokeStyle = col;
      ctx.lineWidth = 2.5 - prog * 1.5;
      ctx.shadowColor = col; ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.restore();
      return true;
    }
  });
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  MERGE STREAK SYSTEM
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let mergeStreak = 0;
let _mergeStreakResetTimer = null;
const STREAK_MAX = 6;
const STREAK_BONUS_PER = 0.05; // +5% DPS per merge in streak
function getMergeStreakBonus() {
  return 1 + Math.min(mergeStreak, STREAK_MAX) * STREAK_BONUS_PER;
}
function onMergeStreakTick() {
  mergeStreak = Math.min(mergeStreak + 1, STREAK_MAX);
  // Reset streak timer on wave start
  if (_mergeStreakResetTimer) clearTimeout(_mergeStreakResetTimer);
  _mergeStreakResetTimer = setTimeout(() => {
    if (mergeStreak > 0) {
      mergeStreak = 0;
      renderMergeStreak();
    }
  }, 15000); // 15s without merge resets streak
  renderMergeStreak();
  if (mergeStreak === 3) showNotif('‚ö° STREAK √ó3! +15% DPS!', 'var(--purple)');
  if (mergeStreak === STREAK_MAX) showNotif('üî• MAX STREAK! +30% DPS BONUS!', 'var(--yellow)');
}
function renderMergeStreak() {
  const bar = document.getElementById('merge-streak-bar');
  if (!bar) return;
  if (mergeStreak === 0) { bar.classList.remove('visible'); return; }
  bar.classList.add('visible');
  document.getElementById('streak-count').textContent = mergeStreak;
  const pct = Math.round((getMergeStreakBonus() - 1) * 100);
  const bonusEl = document.getElementById('streak-bonus-label');
  if (bonusEl) bonusEl.textContent = `+${pct}% DPS`;
  const pipsEl = document.getElementById('streak-pips');
  if (pipsEl) {
    pipsEl.innerHTML = Array.from({length: STREAK_MAX}, (_, i) =>
      `<div class="streak-pip${i < mergeStreak ? ' on' : ''}${i === STREAK_MAX-1 && mergeStreak === STREAK_MAX ? ' bonus-pip' : ''}"></div>`
    ).join('');
  }
}
function resetMergeStreak() {
  mergeStreak = 0;
  if (_mergeStreakResetTimer) { clearTimeout(_mergeStreakResetTimer); _mergeStreakResetTimer = null; }
  renderMergeStreak();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  SPECIAL MERGE RECIPES (MERGE LAB)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// discoveredRecipes = Set of recipe IDs the player has found
let discoveredRecipes = new Set();
const MERGE_RECIPES = [
  {
    id: 'inferno_slug',
    name: 'INFERNO SLUG',
    icon: 'üî•üêå',
    color: '#fb923c',
    desc: 'A molten terror that burns everything in its path. Leaves fire trails.',
    ingredients: [
      { tag: 'BIO', minTier: 3 },
      { tag: 'FIRE', minTier: 3 }
    ],
    ingredientsDesc: 'T3+ BIO unit + T3+ FIRE unit',
    result: { tier: 4, mutant: true, special: 'inferno_slug', name: 'INFERNO SLUG', emoji: 'üî•' },
    stats: [
      { label: '√ó3.0 DPS', color: '#fb923c' },
      { label: 'Fire Trail', color: '#ff453a' },
    ],
    dpsMulti: 3.0,
  },
  {
    id: 'bio_titan',
    name: 'BIO TITAN',
    icon: 'ü¶†üí™',
    color: '#4ade80',
    desc: 'An evolved biological behemoth. Regenerates HP during combat.',
    ingredients: [
      { tag: 'BIO', minTier: 4 },
      { tag: 'TOXIC', minTier: 4 }
    ],
    ingredientsDesc: 'T4+ BIO unit + T4+ TOXIC unit',
    result: { tier: 5, mutant: true, special: 'bio_titan', name: 'BIO TITAN', emoji: 'ü¶†' },
    stats: [
      { label: '√ó2.5 DPS', color: '#4ade80' },
      { label: 'Regen 2%/s', color: '#22d3ee' },
    ],
    dpsMulti: 2.5,
  },
  {
    id: 'mech_overlord',
    name: 'MECH OVERLORD',
    icon: 'ü§ñ‚ö°',
    color: '#5ac8fa',
    desc: 'Supreme mechanical intelligence. Shields allies and overclocks nearby units.',
    ingredients: [
      { tag: 'MECH', minTier: 3 },
      { tag: 'MECH', minTier: 3 }
    ],
    ingredientsDesc: 'Two T3+ MECH units (instead of normal merge)',
    result: { tier: 5, mutant: false, special: 'mech_overlord', name: 'MECH OVERLORD', emoji: 'ü§ñ' },
    stats: [
      { label: '√ó2.8 DPS', color: '#5ac8fa' },
      { label: '+20% team DPS', color: '#60a5fa' },
    ],
    dpsMulti: 2.8,
  },
  {
    id: 'void_phoenix',
    name: 'VOID PHOENIX',
    icon: 'üíÄüî•',
    color: '#c084fc',
    desc: 'A creature of pure chaos. Reborns upon death with 30% HP once per wave.',
    ingredients: [
      { tag: 'FIRE', minTier: 5 },
      { tag: 'TOXIC', minTier: 5 }
    ],
    ingredientsDesc: 'T5+ FIRE unit + T5+ TOXIC unit',
    result: { tier: 7, mutant: true, special: 'void_phoenix', name: 'VOID PHOENIX', emoji: 'üíÄ' },
    stats: [
      { label: '√ó4.0 DPS', color: '#c084fc' },
      { label: 'Rebirth 1√ó', color: '#e879f9' },
    ],
    dpsMulti: 4.0,
    hidden: true, // discovered only through experimentation
  },
];

function findRecipeMatch(idx1, idx2) {
  const u1 = grid[idx1], u2 = grid[idx2];
  if (!u1 || !u2) return null;
  // Je≈õli oba majƒÖ ten sam tier ‚Äî r√≥b normalny merge, nie recepturƒô
  if (u1.tier === u2.tier) return null;
  const tags1 = UNIT_TYPES[u1.tier]?.tags || [];
  const tags2 = UNIT_TYPES[u2.tier]?.tags || [];
  for (const recipe of MERGE_RECIPES) {
    const [req1, req2] = recipe.ingredients;
    const m1 = (tags1.includes(req1.tag) && u1.tier >= req1.minTier && tags2.includes(req2.tag) && u2.tier >= req2.minTier);
    const m2 = (tags1.includes(req2.tag) && u1.tier >= req2.minTier && tags2.includes(req1.tag) && u2.tier >= req1.minTier);
    if (m1 || m2) return recipe;
  }
  return null;
}

function craftRecipe(recipe, idx1, idx2) {
  if (idx1 === undefined || idx2 === undefined) {
    // Find suitable units in grid
    const units = grid.map((c, i) => ({ u: c, i })).filter(x => x.u);
    const [req1, req2] = recipe.ingredients;
    let found1 = null, found2 = null;
    for (const { u, i } of units) {
      const tags = UNIT_TYPES[u.tier]?.tags || [];
      if (!found1 && tags.includes(req1.tag) && u.tier >= req1.minTier) { found1 = i; continue; }
      // req2 might be same tag
      if (found1 !== null && !found2 && tags.includes(req2.tag) && u.tier >= req2.minTier && i !== found1) { found2 = i; }
    }
    if (found1 === null || found2 === null) {
      showNotif('‚ùå Not enough ingredients!', 'var(--red)');
      return false;
    }
    idx1 = found1; idx2 = found2;
  }
  // Perform the craft
  const result = recipe.result;
  grid[idx1] = null;
  grid[idx2] = { tier: result.tier, mutant: result.mutant, special: result.special, specialName: result.name, specialEmoji: result.emoji, dpsMulti: recipe.dpsMulti };
  discoveredRecipes.add(recipe.id);
  renderGrid();
  onMergeStreakTick();
  showNotif(`üß™ CRAFTED: ${result.name}!`, recipe.color);
  sfx.mutant();
  // Animation
  const cell = document.querySelector(`#merge-grid [data-idx="${idx2}"]`);
  if (cell) {
    const rect = cell.getBoundingClientRect();
    const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
    const colors = [recipe.color, '#fff', '#ffd60a'];
    colors.forEach((color, i) => {
      setTimeout(() => {
        const ring = document.createElement('div');
        ring.className = 'merge-ring';
        ring.style.cssText = `left:${cx-22}px;top:${cy-22}px;width:44px;height:44px;border-color:${color};`;
        document.body.appendChild(ring);
        setTimeout(() => ring.remove(), 600);
      }, i * 80);
    });
    // Label
    const lbl = document.createElement('div');
    lbl.style.cssText = `position:fixed;left:${cx}px;top:${cy}px;transform:translate(-50%,-50%);
      font-family:'Fredoka One',sans-serif;font-size:13px;color:${recipe.color};
      pointer-events:none;z-index:9999;text-align:center;white-space:nowrap;
      text-shadow:0 0 10px ${recipe.color};`;
    lbl.textContent = `‚öó ${result.name}!`;
    document.body.appendChild(lbl);
    lbl.animate([{opacity:1,transform:'translate(-50%,-50%) translateY(0)'},{opacity:0,transform:'translate(-50%,-50%) translateY(-50px)'}],{duration:1200,easing:'ease-out'}).onfinish = () => lbl.remove();
  }
  closeMergeLab();
  return true;
}

function openMergeLab() {
  document.getElementById('merge-lab-overlay').classList.add('open');
  renderMergeLabContent();
  sfx.tick();
}
function closeMergeLab() {
  document.getElementById('merge-lab-overlay').classList.remove('open');
}
function renderMergeLabContent() {
  const el = document.getElementById('merge-lab-content');
  if (!el) return;
  // Check which recipes are craftable
  function canCraft(recipe) {
    const [req1, req2] = recipe.ingredients;
    const units = grid.map((c, i) => ({ u: c, i })).filter(x => x.u);
    let f1 = false, f2Idx = -1;
    let idx1 = -1;
    for (const { u, i } of units) {
      const tags = UNIT_TYPES[u.tier]?.tags || [];
      if (!f1 && tags.includes(req1.tag) && u.tier >= req1.minTier) { f1 = true; idx1 = i; continue; }
      if (f1 && tags.includes(req2.tag) && u.tier >= req2.minTier && i !== idx1) { f2Idx = i; break; }
    }
    return f1 && f2Idx >= 0;
  }
  el.innerHTML = '';
  const grid2 = document.createElement('div');
  grid2.className = 'recipe-grid';
  MERGE_RECIPES.forEach(recipe => {
    const isDiscovered = discoveredRecipes.has(recipe.id);
    const craftable = canCraft(recipe);
    const isHidden = recipe.hidden && !isDiscovered && !craftable;
    const card = document.createElement('div');
    card.className = 'recipe-card' + (craftable ? ' can-craft' : isDiscovered ? ' discovered' : isHidden ? ' undiscovered' : ' discovered');
    card.style.setProperty('--recipe-color', recipe.color);
    if (isHidden) {
      card.innerHTML = `
        <div class="recipe-status unk">???</div>
        <div class="recipe-icon" style="filter:grayscale(1)">‚ùì</div>
        <div class="recipe-name unknown">??? UNKNOWN ???</div>
        <div class="recipe-desc">Discover through experimentation...</div>
      `;
    } else {
      const status = craftable ? 'can' : 'need';
      const statusTxt = craftable ? '‚úì CRAFT' : '‚úó NEED';
      card.innerHTML = `
        <div class="recipe-status ${status}">${statusTxt}</div>
        <div class="recipe-icon">${recipe.icon}</div>
        <div class="recipe-name">${recipe.name}</div>
        <div class="recipe-formula">
          ${recipe.ingredients.map(r => `<span class="tag tag-${r.tag.toLowerCase()}">${r.tag} T${r.minTier}+</span>`).join('<span style="color:rgba(255,255,255,0.3)">+</span>')}
          <span style="color:rgba(255,255,255,0.3)">‚Üí</span>
          <span style="color:var(--yellow);font-weight:800">T${recipe.result.tier}${recipe.result.mutant?' ‚ö°':''}</span>
        </div>
        <div class="recipe-desc">${recipe.desc}</div>
        <div class="recipe-stats">
          ${recipe.stats.map(s => `<span class="recipe-stat" style="background:color-mix(in srgb,${s.color} 15%,transparent);color:${s.color};border:1px solid color-mix(in srgb,${s.color} 30%,transparent)">${s.label}</span>`).join('')}
        </div>
        <button class="recipe-craft-btn" ${craftable ? '' : 'disabled'} onclick="craftRecipe(MERGE_RECIPES.find(r=>r.id==='${recipe.id}'))">
          ${craftable ? '‚öó CRAFT NOW' : 'Missing ingredients'}
        </button>
      `;
    }
    grid2.appendChild(card);
  });
  el.appendChild(grid2);
  // Tip
  const tip = document.createElement('div');
  tip.style.cssText = 'font-size:10px;color:rgba(255,255,255,0.3);text-align:center;margin-top:8px;line-height:1.6;';
  tip.textContent = 'üí° Some recipes are discovered only through experimentation. Try merging unusual combinations!';
  el.appendChild(tip);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  LONG HOLD PREVIEW
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let _holdTimer = null;
let _holdCellIdx = null;
let _holdPreviewOpen = false;
const HOLD_DURATION = 600; // ms

function initHoldPreview() {
  document.addEventListener('pointerdown', (e) => {
    const cell = e.target.closest('.grid-cell');
    if (!cell) return;
    const idx = parseInt(cell.dataset.idx);
    if (isNaN(idx) || !grid[idx]) return;
    _holdCellIdx = idx;
    _holdTimer = setTimeout(() => {
      showHoldPreview(idx, e.clientX, e.clientY);
    }, HOLD_DURATION);
  });
  document.addEventListener('pointerup', hideHoldPreview);
  document.addEventListener('pointermove', (e) => {
    if (_holdTimer && e.buttons === 0) hideHoldPreview();
  });
}
function showHoldPreview(idx, x, y) {
  if (!grid[idx]) return;
  _holdPreviewOpen = true;
  const u = grid[idx];
  const ut = UNIT_TYPES[u.tier];
  const tip = document.getElementById('hold-preview-tooltip');
  if (!tip) return;
  // Find possible merges and recipes
  const possibleMerges = [];
  const possibleRecipes = [];
  for (let i = 0; i < GRID_SIZE; i++) {
    if (i === idx || !grid[i]) continue;
    const other = grid[i];
    // Normal merge?
    if (other.tier === u.tier && u.tier < 10) possibleMerges.push({ i, tier: u.tier + 1 });
    // Recipe?
    const recipe = findRecipeMatch(idx, i);
    if (recipe && !possibleRecipes.find(r => r.id === recipe.id)) possibleRecipes.push(recipe);
  }
  let html = `<div class="hold-preview-title">${ut.name}${u.mutant ? ' ‚ö°' : ''}${u.specialName ? ` <span style="color:var(--yellow)">${u.specialName}</span>` : ''}</div>`;
  if (possibleMerges.length > 0) {
    html += `<div class="hold-preview-section">‚¨° MERGE OPTIONS</div>`;
    const shown = possibleMerges.slice(0, 2);
    shown.forEach(m => {
      const nt = UNIT_TYPES[m.tier];
      html += `<div class="hold-preview-merge">
        <span style="font-size:14px">T${u.tier} + T${u.tier}</span>
        <span style="color:rgba(255,255,255,0.3)">‚Üí</span>
        <span class="hold-preview-merge-txt">T${m.tier} ${nt?.name || ''}</span>
      </div>`;
    });
  }
  if (possibleRecipes.length > 0) {
    html += `<div class="hold-preview-section">‚öó RECIPE COMBOS</div>`;
    possibleRecipes.slice(0, 2).forEach(r => {
      html += `<div class="hold-preview-recipe" onclick="openMergeLab()">
        <div class="hold-preview-recipe-icon">${r.icon}</div>
        <div class="hold-preview-recipe-info">
          <div class="hold-preview-recipe-name">${r.name}</div>
          <div class="hold-preview-recipe-req">${r.ingredientsDesc}</div>
        </div>
      </div>`;
    });
  }
  if (possibleMerges.length === 0 && possibleRecipes.length === 0) {
    html += `<div class="hold-preview-empty">No merge or recipe combos available yet.</div>`;
  }
  tip.innerHTML = html;
  // Position
  const tw = 200, pad = 10;
  let tx = x + 14, ty = y - 20;
  if (tx + tw > window.innerWidth - pad) tx = x - tw - 14;
  if (ty < pad) ty = pad;
  tip.style.left = tx + 'px';
  tip.style.top = ty + 'px';
  tip.classList.add('visible');
}
function hideHoldPreview() {
  if (_holdTimer) { clearTimeout(_holdTimer); _holdTimer = null; }
  _holdCellIdx = null;
  _holdPreviewOpen = false;
  const tip = document.getElementById('hold-preview-tooltip');
  if (tip) tip.classList.remove('visible');
}

// Linear synergy: mult = 1 + (count * perUnit), capped at 10 units
function calcLinearSynergyMult(tag, count) {
 const def = SYNERGY_DEFS[tag];
 if (!def || count < 1) return 1;
 const effective = Math.min(count, 10);
 return +(1 + effective * def.perUnit).toFixed(3);
}
// ‚îÄ‚îÄ DAILY CHALLENGE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DAILY_CHALLENGES = [
 { id: 'synergy_killer', name: 'üåø BIO DOMINATION',   type:'synergy_kills', tag:'BIO',   target:30, reward:{ res:8, gold:500 },  desc:'Kill 30 enemies using BIO units' },
 { id: 'fire_starter',   name: 'üî• FIRE STARTER',    type:'synergy_kills', tag:'FIRE',  target:25, reward:{ res:10, gold:400 }, desc:'Kill 25 enemies using FIRE units' },
 { id: 'wave_runner',    name: '‚öîÔ∏è WAVE RUNNER',     type:'reach_wave',    target:10,   reward:{ res:12, gold:300 }, desc:'Reach wave 10 in this run' },
 { id: 'kill_streak',    name: 'üî• STREAK MASTER',   type:'streak',        target:25,   reward:{ res:15, gold:600 }, desc:'Achieve a 25 kill streak in one wave' },
 { id: 'merger',         name: '‚¨° MERGE MANIAC',     type:'merges',        target:10,   reward:{ res:6,  gold:350 }, desc:'Perform 10 merges in one run' },
 { id: 'mech_wall',      name: '‚öôÔ∏è MECH FORTRESS',   type:'synergy_kills', tag:'MECH',  target:20, reward:{ res:8,  gold:450 }, desc:'Kill 20 enemies using MECH units' },
];
function getDailyChallenge() {
 const day = Math.floor(Date.now() / 86400000);
 return DAILY_CHALLENGES[day % DAILY_CHALLENGES.length];
}
function initDailyChallenge() {
 const ch = getDailyChallenge();
 const stored = (() => { try { return JSON.parse(localStorage.getItem('aa_daily') || '{}'); } catch(e) { return {}; } })();
 const today = Math.floor(Date.now() / 86400000);
 G.dailyChallenge = ch;
 G.dailyChallengeProgress = (stored.day === today) ? (stored.progress || 0) : 0;
 G.dailyChallengeCompleted = (stored.day === today) ? (stored.completed || false) : false;
 renderDailyChallenge();
}
function checkDailyProgress(type, amount, extra) {
 const ch = G.dailyChallenge;
 if (!ch || G.dailyChallengeCompleted) return;
 let advance = false;
 if (ch.type === type) {
  if (type === 'streak' && extra >= ch.target) { G.dailyChallengeProgress = ch.target; advance = true; }
  else if (type !== 'reach_wave') { G.dailyChallengeProgress += amount; }
  if (G.dailyChallengeProgress >= ch.target) advance = true;
 }
 if (type === 'reach_wave' && G.wave >= ch.target && ch.type === 'reach_wave') { G.dailyChallengeProgress = ch.target; advance = true; }
 if (advance && !G.dailyChallengeCompleted) {
  G.dailyChallengeCompleted = true;
  G.gold += ch.reward.gold; G.research += ch.reward.res;
  updateCurrencies();
  showNotif(`üèÜ DAILY COMPLETE! +${ch.reward.res} RES +${ch.reward.gold}g`, '#facc15');
  try { localStorage.setItem('aa_daily', JSON.stringify({ day: Math.floor(Date.now()/86400000), progress: ch.target, completed: true })); } catch(e) {}
 } else {
  try { localStorage.setItem('aa_daily', JSON.stringify({ day: Math.floor(Date.now()/86400000), progress: G.dailyChallengeProgress, completed: false })); } catch(e) {}
 }
 renderDailyChallenge();
}
function renderDailyChallenge() {
 let el = document.getElementById('daily-challenge-bar');
 if (!el) return;
 const ch = G.dailyChallenge;
 if (!ch) { el.style.display = 'none'; return; }
 el.style.display = 'flex';
 const prog = Math.min(G.dailyChallengeProgress, ch.target);
 const pct = Math.round(prog / ch.target * 100);
 const done = G.dailyChallengeCompleted;
 el.innerHTML = `
  <span style="font-size:11px;letter-spacing:1px;color:${done?'#facc15':'rgba(255,255,255,0.5)'}">
   üìÖ DAILY: ${ch.name}
  </span>
  <div style="flex:1;height:5px;background:rgba(255,255,255,0.1);border-radius:3px;margin:0 8px;overflow:hidden">
   <div style="height:100%;width:${pct}%;background:${done?'#facc15':'#a78bfa'};border-radius:3px;transition:width 0.3s"></div>
  </div>
  <span style="font-size:10px;color:${done?'#facc15':'rgba(255,255,255,0.4)'}">
   ${done ? '‚úì DONE' : prog+'/'+ch.target}
  </span>
 `;
}

let _lastSynCounts = {};
let _synPopupTimer = null;
function calcSynergies() {
 const counts = { BIO:0, TOXIC:0, FIRE:0, MECH:0 };
 grid.forEach(c => { if (c) UNIT_TYPES[c.tier].tags.forEach(t => counts[t]++); });
 const bonuses = {};
 const active = [];
 let changed = false;
 Object.keys(SYNERGY_DEFS).forEach(tag => {
 const n = counts[tag];
 const def = SYNERGY_DEFS[tag];
 const mult = calcLinearSynergyMult(tag, n);
 const pct = Math.round((mult - 1) * 100);
 const hasSpecial = n >= def.specialAt;
 const label = n > 0 ? `+${pct}% DPS${hasSpecial ? ' ' + def.special : ''}` : '';
 bonuses[tag] = { mult, count: n, label, hasSpecial };
 if (n > 0) active.push({ tag, mult, count: n, label, color: def.color, name: def.name, hasSpecial });
 // Detect change for pop-up trigger
 if ((_lastSynCounts[tag] || 0) !== n) changed = true;
 });
 G.synergyBonuses = bonuses;
 const combo = getActiveCombo(counts);
 if (combo !== G.activeCombo) {
  G.activeCombo = combo;
  if (combo) showNotif(`${combo.icon} COMBO: ${combo.name}! +${Math.round(combo.dpsBonus*100)}% ALL DPS`, combo.color);
 }
 const prevCounts = { ..._lastSynCounts };
 _lastSynCounts = { ...counts };
 if (changed) showSynergyPopup(bonuses, counts, prevCounts);
 return { bonuses, active, counts };
}
function showSynergyPopup(bonuses, counts, prevCounts) {
 // Find the tag that changed most significantly
 let bestTag = null, bestDelta = 0;
 Object.keys(SYNERGY_DEFS).forEach(tag => {
 const delta = Math.abs((counts[tag]||0) - (prevCounts[tag]||0));
 if (delta > bestDelta && counts[tag] > 0) { bestDelta = delta; bestTag = tag; }
 });
 if (!bestTag) return;
 const def = SYNERGY_DEFS[bestTag];
 const bon = bonuses[bestTag];
 const pct = Math.round((bon.mult - 1) * 100);
 let popup = document.getElementById('synergy-popup');
 if (!popup) {
 popup = document.createElement('div');
 popup.id = 'synergy-popup';
 document.body.appendChild(popup);
 }
 popup.style.setProperty('--syn-popup-color', def.color);
 popup.innerHTML = `
 <div class="syn-popup-tag">${def.icon} ${bestTag} SYNERGY</div>
 <div class="syn-popup-name">${def.name}</div>
 <div class="syn-popup-bonus">+${pct}% DPS${bon.hasSpecial ? ' ' + def.special : ''}</div>
 <div class="syn-popup-desc">${counts[bestTag]} unit${counts[bestTag]!==1?'s':''} active ¬∑ ${def.desc}</div>
 `;
 popup.classList.add('visible');
 if (_synPopupTimer) clearTimeout(_synPopupTimer);
 _synPopupTimer = setTimeout(() => { popup.classList.remove('visible'); }, 2800);
}
function getAdjacencyMult(gridIdx) {
 if (!grid[gridIdx]) return 1;
 const myTags = UNIT_TYPES[grid[gridIdx].tier]?.tags || [];
 const cols = 4, rows = 5;
 const row = Math.floor(gridIdx / cols), col = gridIdx % cols;
 const neighbors = [
 gridIdx - cols, gridIdx + cols,
 col > 0 ? gridIdx - 1 : -1,
 col < cols-1 ? gridIdx + 1 : -1,
 ].filter(n => n >= 0 && n < GRID_SIZE && grid[n]);
 const perNeighbor = G.activeRelic === 'synergy' ? 0.24 : 0.12; 
 const cap = G.activeRelic === 'synergy' ? 1.96 : 1.48;
 let bonus = 1;
 neighbors.forEach(n => {
 const nTags = UNIT_TYPES[grid[n].tier].tags;
 if (myTags.some(t => nTags.includes(t))) bonus += perNeighbor;
 });
 return Math.min(bonus, cap);
}
function getSynergyMultForUnit(tier) {
 const tags = UNIT_TYPES[tier]?.tags || [];
 let mult = 1;
 tags.forEach(t => { if (G.synergyBonuses[t]) mult *= G.synergyBonuses[t].mult; });
 if (G.activeCombo) mult *= (1 + G.activeCombo.dpsBonus);
 return mult;
}
let _lastSynergyRender = 0;
let _prevSynCounts = {};
function renderSynergyBar() {
 const now = Date.now();
 if (now - _lastSynergyRender < 400) return;
 _lastSynergyRender = now;
 const { active, counts, bonuses } = calcSynergies();
 const el = document.getElementById('synergy-bar');
 if (!el) return;

 // Pierwsze wywo≈Çanie ‚Äî buduj chipy raz
 if (!el.dataset.built) {
  el.innerHTML = '';
  Object.keys(SYNERGY_DEFS).forEach(tag => {
   const def = SYNERGY_DEFS[tag];
   const chip = document.createElement('div');
   chip.className = 'syn-chip';
   chip.dataset.tag = tag;
   chip.style.setProperty('--syn-color', def.color);
   el.appendChild(chip);
  });
  el.dataset.built = '1';
 }

 // Aktualizuj ka≈ºdy chip in-place (bez rebuild)
 Object.keys(SYNERGY_DEFS).forEach(tag => {
  const n = counts[tag];
  const def = SYNERGY_DEFS[tag];
  const bon = bonuses[tag];
  const isActive = n > 0;
  const pct = Math.round((bon.mult - 1) * 100);
  const chip = el.querySelector(`[data-tag="${tag}"]`);
  if (!chip) return;

  const wasActive = chip.classList.contains('syn-active');
  chip.className = 'syn-chip' + (isActive ? ' syn-active' : '');
  chip.style.setProperty('--syn-color', def.color);

  const maxPips = 6;
  const pips = Array.from({length: maxPips}, (_,i) =>
   `<span class="syn-pip${i < n ? ' syn-pip-on' : ''}"></span>`
  ).join('');
  chip.innerHTML = `
   <span class="syn-icon">${def.icon}</span>
   <span class="syn-tag" style="color:${def.color}">${tag}</span>
   <span class="syn-count" style="color:${isActive ? def.color : 'rgba(255,255,255,0.25)'}">${n}</span>
   ${isActive ? `<span class="syn-bonus" style="color:${def.color}">+${pct}%${bon.hasSpecial ? ' ‚òÖ' : ''}</span>` : ''}
   <span class="syn-track">${pips}</span>
  `;
  chip.title = isActive ? bon.label : `Need 1 ${tag} unit`;

  // Pulse tylko gdy count siƒô zmieni≈Ç
  const prev = _prevSynCounts[tag] || 0;
  if (prev !== n && isActive) {
   chip.classList.add('syn-pulse');
   setTimeout(() => chip.classList.remove('syn-pulse'), 500);
  }
 });
 _prevSynCounts = { ...counts };
}
function calcScore() {
 const waveScore = G.wave * G.wave * 100;
 const killScore = Math.floor(G.kills * 15);
 const prestigeMul = 1 + G.prestige * 0.5;
 const nightmareBonus = (G.bestWave >= 25 ? 5000 : 0)
 + (G.bestWave >= 50 ? 15000 : 0)
 + (G.bestWave >= 75 ? 40000 : 0);
 return Math.floor((waveScore + killScore + nightmareBonus) * prestigeMul);
}
let nightmareActive = false;
function isNightmareWave(wave) { return wave % 25 === 0 && !isBossWave(wave); }
function activateNightmareDebuff() {
 nightmareActive = true;
 document.getElementById('nightmare-debuff-bar').classList.add('active');
}
function clearNightmareDebuff() {
 nightmareActive = false;
 document.getElementById('nightmare-debuff-bar').classList.remove('active');
}
const LB_KEY_PREFIX = 'lb:';
const LB_MAX = 50;
let lbMyKey = null;
function openLeaderboard() {
 document.getElementById('lb-overlay').classList.add('open');
 try {
 const saved = (_hasLocal ? localStorage : (_hasSession ? sessionStorage : null))?.getItem('aa_nick');
 if (saved) document.getElementById('lb-nick').value = saved;
 } catch(e) {}
 setTimeout(() => { try { document.getElementById('lb-nick').focus(); } catch(e) {} }, 100);
 loadLeaderboard();
}
function closeLeaderboard() {
 document.getElementById('lb-overlay').classList.remove('open');
}
async function loadLeaderboard() {
 const list = document.getElementById('lb-list');
 if (!window.storage) {
 list.innerHTML = `<li class="lb-empty">üöß Global leaderboard coming soon!<br><span style="font-size:11px;opacity:0.6;display:block;margin-top:6px">For now, write your score in Notepad üìù</span></li>`;
 return;
 }
 list.innerHTML = `<li class="lb-loading">${t('lbLoading')}</li>`;
 try {
 const res = await window.storage.list(LB_KEY_PREFIX, true);
 if (!res || !res.keys || res.keys.length === 0) {
 list.innerHTML = `<li class="lb-empty">${t('lbEmpty')}</li>`;
 return;
 }
 const entries = await Promise.all(
 res.keys.map(async k => {
 try {
 const r = await window.storage.get(k, true);
 return r ? { key: k, ...JSON.parse(r.value) } : null;
 } catch { return null; }
 })
 );
 const valid = entries.filter(Boolean).sort((a, b) => b.score - a.score).slice(0, LB_MAX);
 renderLeaderboard(valid);
 } catch(e) {
 list.innerHTML = `<li class="lb-empty">${t('lbError')}</li>`;
 }
}
function renderLeaderboard(entries) {
 const list = document.getElementById('lb-list');
 if (!entries.length) { list.innerHTML = `<li class="lb-empty">${t('lbNoEntries')}</li>`; return; }
 const rankLabels = ['ü•á','ü•à','ü•â'];
 const rankClasses = ['gold','silver','bronze'];
 list.innerHTML = entries.map((e, i) => {
 const isMe = lbMyKey && e.key === lbMyKey;
 const rankTxt = i < 3 ? rankLabels[i] : `#${i+1}`;
 const rankCls = i < 3 ? rankClasses[i] : '';
 return `<li class="lb-row${isMe?' me':''}">
 <span class="lb-rank ${rankCls}">${rankTxt}</span>
 <span class="lb-name">${escLB(e.name)}</span>
 <div class="lb-score-col">
 <div class="lb-score-main">${formatNum(e.score)}</div>
 <div class="lb-score-sub">W${e.wave} ¬∑ ${formatNum(e.kills)}K ¬∑ P${e.prestige}</div>
 </div>
 </li>`;
 }).join('');
}
function escLB(str) {
 return String(str).replace(/[&<>"']/g, c =>
 ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
async function submitScore() {
 const nick = document.getElementById('lb-nick').value.trim();
 if (!nick) { setLbStatus(t('lbNickRequired'), '#ff8aad'); return; }
 const btn = document.getElementById('lb-submit-btn');
 btn.disabled = true;
 setLbStatus(t('lbSubmitting'), 'var(--dim)');
 try {
 const store = _hasLocal ? localStorage : (_hasSession ? sessionStorage : null);
 if (store) store.setItem('aa_nick', nick);
 } catch(e) {}
 if (!lbMyKey) {
 try {
 const store = _hasLocal ? localStorage : (_hasSession ? sessionStorage : null);
 lbMyKey = store?.getItem('aa_lb_key') || null;
 if (!lbMyKey) {
 lbMyKey = LB_KEY_PREFIX + nick.replace(/[^a-zA-Z0-9]/g,'_').slice(0,12)
 + '_' + Math.random().toString(36).slice(2,8);
 if (store) store.setItem('aa_lb_key', lbMyKey);
 }
 } catch(e) {
 lbMyKey = LB_KEY_PREFIX + nick.replace(/[^a-zA-Z0-9]/g,'_').slice(0,12)
 + '_' + Math.random().toString(36).slice(2,8);
 }
 }
 const score = calcScore();
 const entry = {
 name: nick,
 score: score,
 wave: G.wave,
 kills: G.kills,
 prestige: G.prestige,
 ts: Date.now()
 };
 if (!window.storage) {
  setLbStatus('üöß Leaderboard coming soon! For now, write your score in Notepad üìù', '#fb923c');
  btn.disabled = false;
  return;
 }
 try {
 await window.storage.set(lbMyKey, JSON.stringify(entry), true);
 setLbStatus(t('lbSubmitOk', formatNum(score)), 'var(--green)');
 await loadLeaderboard();
 } catch(e) {
 setLbStatus(t('lbSubmitFail'), '#ff8aad');
 }
 btn.disabled = false;
}
function setLbStatus(msg, color) {
 const el = document.getElementById('lb-status');
 if (el) { el.textContent = msg; el.style.color = color; }
}
function promptLeaderboard() {
 setTimeout(() => {
 if (confirm('Submit your score to the global leaderboard?')) openLeaderboard();
 }, 1200);
}
function isBossWave(wave) { return wave % 10 === 0; }
function isMiniB(wave) { return wave % 5 === 0 && !isBossWave(wave) && !isNightmareWave(wave); }
const MINI_BOSSES = [
 { name: 'ALPHA CRAWLER', color: '#ff6b6b', hpMult: 8,  reward: 3, size: 18, weakTo: 'FIRE',  special: 'mini' },
 { name: 'VENOM BRUISER', color: '#a3e635', hpMult: 10, reward: 3, size: 20, weakTo: 'BIO',   special: 'mini' },
 { name: 'IRON GOLEM',    color: '#94a3b8', hpMult: 12, reward: 4, size: 22, weakTo: 'TOXIC', special: 'mini' },
 { name: 'BLAZE TITAN',   color: '#fb923c', hpMult: 9,  reward: 3, size: 19, weakTo: 'MECH',  special: 'mini' },
 { name: 'VOID PHANTOM',  color: '#c084fc', hpMult: 7,  reward: 4, size: 16, weakTo: 'BIO',   special: 'mini' },
];
const BOSS_TYPES = [
 { name: 'VOID LEECH',  hp:   800, speed: 0.6, reward:   80, color: '#7c3aed', size: 30, color2: '#4c1d95' },
 { name: 'IRON HULK',  hp:  2500, speed: 0.3, reward:  200, color: '#dc2626', size: 38, color2: '#7f1d1d' },
 { name: 'PHASE WRAITH', hp: 6000, speed: 0.9, reward:  450, color: '#0ea5e9', size: 32, color2: '#082f49' },
 { name: 'OMEGA CORE',  hp: 14000, speed: 0.5, reward: 1000, color: '#f59e0b', size: 42, color2: '#78350f' },
 { name: 'NULL TITAN',  hp: 32000, speed: 0.4, reward: 2500, color: '#ec4899', size: 48, color2: '#500724' },
 { name: 'APEX HORROR', hp: 75000, speed: 0.7, reward: 6000, color: '#00ffea', size: 52, color2: '#003d38' },
];
function getBossForWave(wave) {
 const idx = Math.floor(wave / 10) - 1;
 return BOSS_TYPES[idx % BOSS_TYPES.length];
}
const GRID_ANIM_CANVASES = new Map();
let gridAnimId = null;
function startGridAnim() {
 if (gridAnimId) return;
 function tick() {
 GRID_ANIM_CANVASES.forEach(({ canvas, ctx2, unit, phase }) => {
 drawGridBlob(ctx2, canvas.width, canvas.height, unit, phase);
 });
 gridAnimId = requestAnimationFrame(tick);
 }
 gridAnimId = requestAnimationFrame(tick);
}
const SKIN_PALETTES = {
 '': ['',['#6fdd4a','#2a8a18'],['#5cb8ff','#1460c0'],['#ff7ee0','#b0208a'],['#ffb030','#c05800'],['#c060ff','#6808c8'],['#ffffff','#a0c0ff'],['#00e5ff','#005575'],['#cd8040','#5a2800'],['#aa00ff','#1a0030'],['#ff5500','#ffd000']],
 neon: ['',['#00ffea','#006060'],['#ff00ff','#800080'],['#ffff00','#707000'],['#00ff80','#006030'],['#ff0080','#700030'],['#00cfff','#005070'],['#ff8800','#703000'],['#8800ff','#200050'],['#ff0044','#500010'],['#ffffff','#aaffee']],
 void: ['',['#9060ff','#2a0880'],['#6040cc','#180060'],['#c080ff','#4a0090'],['#4020a0','#100040'],['#e0a0ff','#5a00a0'],['#b060ff','#300060'],['#8040cc','#1a0050'],['#d0a0ff','#600090'],['#2010a0','#080020'],['#ff80ff','#800080']],
 toxic: ['',['#aaff00','#446600'],['#ccff44','#507000'],['#88ff22','#304400'],['#ffee00','#604400'],['#00ff88','#005030'],['#ddff33','#508000'],['#44ff44','#106010'],['#aaee00','#405000'],['#ffaa00','#503000'],['#00ffaa','#006040']],
 blood: ['',['#ff2020','#880000'],['#ff4444','#aa0000'],['#cc0000','#500000'],['#ff6060','#880020'],['#dd0000','#440000'],['#ff3030','#660000'],['#aa0000','#330000'],['#ff5050','#770010'],['#880000','#220000'],['#ff0000','#ffaa00']],
 ice: ['',['#a0e8ff','#4080c0'],['#c0f0ff','#5090d0'],['#80d0ff','#3070b0'],['#e0f8ff','#60a0d0'],['#60c0ff','#2060a0'],['#ffffff','#80c0ff'],['#d0f0ff','#5090c0'],['#b0e0ff','#4080b0'],['#f0faff','#70b0d0'],['#40a0ff','#f0ffff']],
 gold: ['',['#ffd700','#a06000'],['#ffb800','#804000'],['#ffe040','#b07000'],['#ffc820','#906000'],['#ffec80','#c08000'],['#ffffff','#ffd700'],['#ffdc60','#a07000'],['#ffa000','#603000'],['#ffe880','#b09000'],['#ff8800','#ffdd00']],
 shadow: ['',['#444466','#111122'],['#556688','#223344'],['#334455','#101520'],['#667788','#2a3344'],['#223344','#080c14'],['#8899aa','#3a4a5a'],['#445566','#181c24'],['#556677','#202830'],['#111133','#050510'],['#9900ff','#220044']],
 cyber: ['',['#00ffcc','#004433'],['#ff00aa','#440022'],['#00aaff','#002244'],['#ffcc00','#443300'],['#aa00ff','#220033'],['#00ffff','#004444'],['#ff6600','#442200'],['#0066ff','#001144'],['#ff0066','#330011'],['#ffff00','#ff6600']],
};
function getSkinColors(tier) {
 const p = SKIN_PALETTES[activeSkin] || SKIN_PALETTES[''];
 return p[tier] || p[1];
}
function drawGridBlob(ctx2, W, H, u, phase) {
 ctx2.clearRect(0, 0, W, H);
 const now = Date.now() / 1000;

 // ‚îÄ‚îÄ BLINK SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 // Each blob has its own blink timer based on phase
 const blinkCycle = 3.5 + (phase % 2.1); // blink every 3.5-5.6s
 const blinkT = (now + phase * 1.7) % blinkCycle;
 const isBlinking = blinkT > blinkCycle - 0.18; // blink for 0.18s
 const blinkProgress = isBlinking ? Math.sin((blinkT - (blinkCycle - 0.18)) / 0.18 * Math.PI) : 0;
 const eyeScaleY = 1 - blinkProgress * 0.95; // nearly closes

 // ‚îÄ‚îÄ EXPRESSION SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 // Cycle through expressions: happy ‚Üí curious ‚Üí surprised ‚Üí happy
 const exprCycle = 6 + (phase % 4);
 const exprT = (now * 0.4 + phase * 0.8) % exprCycle;
 const expr = exprT < exprCycle * 0.6 ? 'happy' : exprT < exprCycle * 0.82 ? 'curious' : 'surprised';

 // r must be declared before jumpY uses it
 const r = W * 0.34;

 // ‚îÄ‚îÄ BOUNCE / JUMP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const jumpCycle = 4.2 + (phase % 2.8);
 const jumpT = (now * 0.7 + phase * 1.3) % jumpCycle;
 const jumpY = jumpT < 0.5 ? -Math.sin(jumpT / 0.5 * Math.PI) * r * 0.22 : 0;

 // ‚îÄ‚îÄ SQUASH & STRETCH on landing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const isLanding = jumpT > 0.46 && jumpT < 0.70;
 const squash = isLanding ? 1 + Math.sin((jumpT - 0.46) / 0.24 * Math.PI) * 0.18 : 1;

 // ‚îÄ‚îÄ EXCITED WIGGLE (higher tiers) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const wiggleMult = u.tier >= 7 ? 1.2 : u.tier >= 5 ? 1.1 : u.tier >= 3 ? 1.05 : 1.0;
 const wob = Math.sin(now * 2.5 + phase) * 0.07 * wiggleMult;
 const wob2 = Math.cos(now * 1.8 + phase + 1.2) * 0.04 * wiggleMult;
 const tiltWobble = Math.sin(now * 1.9 + phase * 2.1) * 0.06;

 // ‚îÄ‚îÄ PUPIL WANDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const pupilWanderX = Math.sin(now * 0.8 + phase) * 1.8;
 const pupilWanderY = Math.cos(now * 0.6 + phase * 1.3) * 1.2;

 const cx = W * 0.5, cy = H * 0.51 + jumpY;
 const[_bT,_bB]=getSkinColors(u.tier);
 ctx2.shadowColor = _bT;
 ctx2.shadowBlur = u.mutant ? 14 : u.tier >= 7 ? 14 : 10;
 ctx2.beginPath();
 ctx2.ellipse(cx, cy + r * (0.6 + wob * 0.3), r * (0.75 - wob * 0.05), r * (0.38 + wob * 0.18), 0, 0, Math.PI * 2);
 const dg = ctx2.createLinearGradient(cx, cy - r * 0.2, cx, cy + r * 1.0);
 dg.addColorStop(0, _bT + 'cc');
 dg.addColorStop(1, _bB + '44');
 ctx2.fillStyle = dg;
 ctx2.fill();
 const bW = r * (1.0 + wob * 0.12);
 const bH = r * (1.0 - wob * 0.08);
 ctx2.save();
 ctx2.translate(cx, cy);
 ctx2.rotate(tiltWobble);
 ctx2.scale(bW / r * (1 / squash), bH / r * squash);
 const bump = r * (1 + wob2 * 0.15);
 ctx2.beginPath();
 ctx2.moveTo(0, -bump);
 ctx2.bezierCurveTo( bump * 0.6, -bump, bump, -bump * 0.5, bump * (1 + wob2 * 0.1), 0);
 ctx2.bezierCurveTo( bump, bump * 0.55, bump * 0.55, bump, 0, bump * (1 - wob2 * 0.1));
 ctx2.bezierCurveTo(-bump * 0.55, bump, -bump, bump * 0.5, -bump * (1 - wob2 * 0.08), 0);
 ctx2.bezierCurveTo(-bump, -bump * 0.5, -bump * 0.6, -bump, 0, -bump);
 ctx2.closePath();
 const bg = ctx2.createRadialGradient(-r * 0.22 / (bW/r), -r * 0.26 / (bH/r), r * 0.04, 0, 0, r * 1.15);
 bg.addColorStop(0, lighten(_bT, 0.5));
 bg.addColorStop(0.45, _bT);
 bg.addColorStop(1, _bB);
 ctx2.fillStyle = bg;
 ctx2.fill();
 ctx2.restore();
 ctx2.shadowBlur = 0;
 ctx2.beginPath();
 ctx2.ellipse(cx - r * 0.27, cy - r * 0.30, r * 0.20, r * 0.12, -0.55, 0, Math.PI * 2);
 ctx2.fillStyle = 'rgba(255,255,255,0.65)';
 ctx2.fill();
 ctx2.beginPath();
 ctx2.arc(cx - r * 0.12, cy - r * 0.44, r * 0.07, 0, Math.PI * 2);
 ctx2.fillStyle = 'rgba(255,255,255,0.35)';
 ctx2.fill();
 if (u.tier >= 2) {
 const ax = r * 0.29;
 ctx2.strokeStyle = _bT; ctx2.lineWidth = 1.8;
 ctx2.shadowColor = _bT; ctx2.shadowBlur = 6;
 ctx2.lineCap = 'round';
 ctx2.beginPath();
 ctx2.moveTo(cx - ax, cy - r * 0.88);
 ctx2.quadraticCurveTo(cx - ax - r * 0.16, cy - r * 1.30, cx - ax - r * 0.04 + Math.sin(now * 3) * r * 0.06, cy - r * 1.50);
 ctx2.stroke();
 if (u.tier >= 3) {
 ctx2.beginPath();
 ctx2.moveTo(cx + ax, cy - r * 0.88);
 ctx2.quadraticCurveTo(cx + ax + r * 0.16, cy - r * 1.30, cx + ax + r * 0.04 + Math.sin(now * 3 + 1) * r * 0.06, cy - r * 1.50);
 ctx2.stroke();
 }
 ctx2.shadowBlur = 0; ctx2.fillStyle = lighten(_bT, 0.35);
 ctx2.beginPath(); ctx2.arc(cx - ax - r*0.04 + Math.sin(now*3)*r*0.06, cy - r*1.52, 2.5, 0, Math.PI*2); ctx2.fill();
 if (u.tier >= 3) {
 ctx2.beginPath(); ctx2.arc(cx + ax + r*0.04 + Math.sin(now*3+1)*r*0.06, cy - r*1.52, 2.5, 0, Math.PI*2); ctx2.fill();
 }
 }
 if (u.tier >= 5) {
 for (let k = 0; k < 3; k++) {
 const a = -Math.PI / 2 + (k - 1) * 0.46;
 const spikeLen = r * (1.52 + Math.sin(now * 4 + k) * 0.06);
 ctx2.strokeStyle = u.tier >= 9 ? '#ff5500' : u.tier >= 7 ? '#00e5ff' : u.tier >= 6 ? '#ffffff' : '#d060f8';
 ctx2.lineWidth = 2.2; ctx2.lineCap = 'round';
 ctx2.shadowColor = ctx2.strokeStyle; ctx2.shadowBlur = 6;
 ctx2.beginPath();
 ctx2.moveTo(cx + Math.cos(a) * r * 0.9, cy + Math.sin(a) * r * 0.9);
 ctx2.lineTo(cx + Math.cos(a) * spikeLen, cy + Math.sin(a) * spikeLen);
 ctx2.stroke();
 }
 }
 ctx2.shadowBlur = 0;
 const eyeY = cy - r * 0.10;
 const eyeSp = r * 0.33, eyeR = r * 0.25, pupR = eyeR * 0.54;
 const irisPulse = 0; // removed - caused flicker
 // Surprised expression: eyes wider
 const exprEyeScale = expr === 'surprised' ? 1.3 : expr === 'curious' ? 1.1 : 1.0;
 const EC = ['','#156800','#004090','#800060','#703000','#4800a0','#cc0055','#0077aa','#880000','#550077','#cc3300'];
 const ec = u.mutant ? '#cc0044' : (EC[Math.min(u.tier, 10)] || '#333');
 [-1, 1].forEach(s => {
  const ex = cx + s * eyeSp;
  const scY = eyeScaleY * exprEyeScale;
  // White of eye
  ctx2.beginPath();
  ctx2.ellipse(ex, eyeY, eyeR * exprEyeScale, eyeR * (1.08 + wob * 0.12) * scY, 0, 0, Math.PI * 2);
  ctx2.fillStyle = 'rgba(255,255,255,0.95)'; ctx2.fill();
  if (!isBlinking || blinkProgress < 0.5) {
   // Iris
   const px = ex + s * 1.2 + pupilWanderX * s;
   const py = eyeY + 0.8 + pupilWanderY;
   ctx2.beginPath();
   ctx2.arc(px, py, pupR * (1 + irisPulse * 0.3) * exprEyeScale, 0, Math.PI * 2);
   ctx2.fillStyle = ec; ctx2.fill();
   // Pupil
   ctx2.beginPath();
   ctx2.arc(px, py, pupR * 0.44 * exprEyeScale, 0, Math.PI * 2);
   ctx2.fillStyle = '#000'; ctx2.fill();
   // Shine
   ctx2.beginPath();
   ctx2.arc(ex + s * 0.3, eyeY - pupR * 0.38, pupR * 0.27, 0, Math.PI * 2);
   ctx2.fillStyle = 'rgba(255,255,255,0.92)'; ctx2.fill();
  }
  // Blink lid
  if (isBlinking) {
   ctx2.beginPath();
   ctx2.ellipse(ex, eyeY, eyeR * exprEyeScale + 1, eyeR * (1.08 + wob*0.12) * blinkProgress + 1, 0, 0, Math.PI * 2);
   ctx2.fillStyle = _bT; ctx2.fill();
  }
  // Curious: raised inner eyebrow
  if (expr === 'curious') {
   ctx2.save();
   ctx2.strokeStyle = 'rgba(0,0,0,0.5)'; ctx2.lineWidth = 1.4; ctx2.lineCap = 'round';
   ctx2.beginPath();
   ctx2.moveTo(ex - s * eyeR * 0.7, eyeY - eyeR * 1.3);
   ctx2.quadraticCurveTo(ex, eyeY - eyeR * 1.6 - s * eyeR * 0.2, ex + s * eyeR * 0.7, eyeY - eyeR * 1.3);
   ctx2.stroke();
   ctx2.restore();
  }
 });
 ctx2.strokeStyle = 'rgba(0,0,0,0.55)'; ctx2.lineWidth = 1.8; ctx2.lineCap = 'round';
 ctx2.shadowBlur = 0;
 ctx2.beginPath();
 if (expr === 'surprised') {
  // O-shape mouth
  ctx2.ellipse(cx, cy + r * 0.30, r * 0.10, r * 0.13, 0, 0, Math.PI * 2);
  ctx2.stroke();
 } else if (expr === 'curious') {
  // Slight smirk ‚Äî asymmetric
  ctx2.arc(cx + r * 0.05, cy + r * 0.28, r * 0.16, Math.PI * 0.15, Math.PI * 0.75);
  ctx2.stroke();
 } else {
  // Big happy smile
  const smileBoost = Math.sin(now * 1.1 + phase) * 0.05;
  ctx2.arc(cx, cy + r * 0.22, r * (0.22 + smileBoost), Math.PI * 0.08, Math.PI * 0.92);
  ctx2.stroke();
  // Teeth for high tiers
  if (u.tier >= 6) {
   ctx2.fillStyle = 'rgba(255,255,255,0.9)';
   ctx2.fillRect(cx - r * 0.13, cy + r * 0.22, r * 0.11, r * 0.08);
   ctx2.fillRect(cx + r * 0.02, cy + r * 0.22, r * 0.11, r * 0.08);
  }
 }

 const sk = activeSkin;
 if (sk === 'neon') {
 const pulse = 0.5 + 0.5 * Math.sin(now * 2.5 + phase);
 ctx2.save();
 ctx2.globalAlpha = 0.25 + pulse * 0.25;
 ctx2.strokeStyle = _bT;
 ctx2.lineWidth = 2.5;
 ctx2.shadowColor = _bT; ctx2.shadowBlur = 14 + pulse * 8;
 ctx2.beginPath();
 ctx2.ellipse(cx, cy, r * 1.08, r * 1.05, 0, 0, Math.PI * 2);
 ctx2.stroke();
 ctx2.restore();
 // Deterministyczne iskry ‚Äî bez Math.random()
 for (let ni = 0; ni < 2; ni++) {
  const nAngle = now * 1.3 + phase + ni * Math.PI;
  const nAlpha = 0.3 + 0.25 * Math.sin(now * 2 + ni * 2.1 + phase);
  const nax = cx + Math.cos(nAngle) * r * 0.9;
  const nay = cy + Math.sin(nAngle) * r * 0.7;
  ctx2.save();
  ctx2.globalAlpha = nAlpha;
  ctx2.strokeStyle = _bT; ctx2.lineWidth = 1.0;
  ctx2.shadowColor = _bT; ctx2.shadowBlur = 6;
  ctx2.beginPath();
  ctx2.moveTo(nax, nay);
  ctx2.lineTo(nax + Math.cos(nAngle + 0.8) * 8, nay + Math.sin(nAngle + 0.8) * 8);
  ctx2.stroke();
  ctx2.restore();
 }
 }
 if (sk === 'blood') {
 const dripCount = 2 + (u.tier % 3);
 ctx2.save();
 for (let d = 0; d < dripCount; d++) {
 const dx = cx + (d - dripCount/2 + 0.5) * r * 0.4;
 const dripLen = r * (0.3 + 0.25 * Math.sin(now * 1.5 + d * 2.1 + phase));
 const dg2 = ctx2.createLinearGradient(dx, cy + r*0.6, dx, cy + r*0.6 + dripLen);
 dg2.addColorStop(0, '#cc0000cc');
 dg2.addColorStop(1, '#cc000000');
 ctx2.fillStyle = dg2;
 ctx2.beginPath();
 ctx2.ellipse(dx, cy + r*0.6 + dripLen*0.5, r*0.07, dripLen*0.55, 0, 0, Math.PI*2);
 ctx2.fill();
 ctx2.fillStyle = '#cc0000';
 ctx2.beginPath();
 ctx2.arc(dx, cy + r*0.6 + dripLen, r*0.08, 0, Math.PI*2);
 ctx2.fill();
 }
 ctx2.globalAlpha = 0.12 + 0.08 * Math.sin(now * 2);
 ctx2.fillStyle = '#ff0000';
 ctx2.beginPath(); ctx2.ellipse(cx, cy, r*1.2, r*1.2, 0, 0, Math.PI*2);
 ctx2.fill();
 ctx2.restore();
 }
 if (sk === 'ice') {
 const crystalN = 5 + u.tier;
 ctx2.save();
 ctx2.strokeStyle = '#c0f0ff'; ctx2.lineWidth = 1.2;
 ctx2.shadowColor = '#a0e8ff'; ctx2.shadowBlur = 8;
 for (let cr = 0; cr < crystalN; cr++) {
 const angle = (cr / crystalN) * Math.PI * 2 + now * 0.5 + phase;
 const dist = r * (1.18 + 0.06 * Math.sin(now * 2 + cr));
 const kx = cx + Math.cos(angle) * dist;
 const ky = cy + Math.sin(angle) * dist;
 const kLen = r * 0.18;
 ctx2.globalAlpha = 0.5 + 0.3 * Math.sin(now * 3 + cr * 1.3);
 ctx2.beginPath();
 ctx2.moveTo(kx - Math.cos(angle) * kLen, ky - Math.sin(angle) * kLen);
 ctx2.lineTo(kx + Math.cos(angle) * kLen, ky + Math.sin(angle) * kLen);
 ctx2.stroke();
 ctx2.beginPath();
 ctx2.moveTo(kx - Math.sin(angle) * kLen*0.5, ky + Math.cos(angle) * kLen*0.5);
 ctx2.lineTo(kx + Math.sin(angle) * kLen*0.5, ky - Math.cos(angle) * kLen*0.5);
 ctx2.stroke();
 }
 ctx2.globalAlpha = 0.08 + 0.06 * Math.sin(now * 1.5);
 ctx2.fillStyle = '#e0f8ff';
 ctx2.beginPath(); ctx2.ellipse(cx, cy, r*1.25, r*1.2, 0, 0, Math.PI*2);
 ctx2.fill();
 ctx2.restore();
 }
 if (sk === 'gold') {
 ctx2.save();
 const starN = 6 + u.tier;
 for (let st = 0; st < starN; st++) {
 const angle = (st / starN) * Math.PI * 2 + now * 0.8 + phase;
 const dist = r * (0.9 + 0.35 * Math.abs(Math.sin(now * 1.2 + st * 0.9)));
 const sx = cx + Math.cos(angle) * dist;
 const sy = cy + Math.sin(angle) * dist;
 const sa = 0.4 + 0.5 * Math.sin(now * 3 + st);
 ctx2.globalAlpha = sa;
 ctx2.fillStyle = st % 2 === 0 ? '#ffd700' : '#ffffff';
 ctx2.shadowColor = '#ffd700'; ctx2.shadowBlur = 8;
 ctx2.beginPath(); ctx2.arc(sx, sy, r * 0.055, 0, Math.PI*2); ctx2.fill();
 }
 ctx2.globalAlpha = 0.2 + 0.12 * Math.sin(now*2);
 ctx2.strokeStyle = '#ffd700'; ctx2.lineWidth = 2.5;
 ctx2.shadowColor = '#ffd700'; ctx2.shadowBlur = 12;
 ctx2.beginPath(); ctx2.ellipse(cx, cy, r*1.06, r*1.04, 0, 0, Math.PI*2);
 ctx2.stroke();
 ctx2.restore();
 }
 if (sk === 'shadow') {
 ctx2.save();
 const pN = 8 + u.tier;
 for (let p = 0; p < pN; p++) {
 const angle = (p / pN) * Math.PI * 2;
 const t2 = now * 0.6 + phase + p * 0.7;
 const dist = r * (0.7 + 0.5 * Math.sin(t2));
 const px = cx + Math.cos(angle + now * 0.4) * dist;
 const py = cy + Math.sin(angle + now * 0.4) * dist;
 ctx2.globalAlpha = 0.3 + 0.3 * Math.sin(t2 * 2);
 ctx2.fillStyle = p % 3 === 0 ? '#9900ff' : '#222244';
 ctx2.shadowColor = '#9900ff'; ctx2.shadowBlur = 10;
 ctx2.beginPath(); ctx2.arc(px, py, r * 0.07, 0, Math.PI*2); ctx2.fill();
 }
 ctx2.globalAlpha = 0.15 + 0.1 * Math.sin(now * 1.8);
 ctx2.fillStyle = '#000022';
 ctx2.beginPath(); ctx2.ellipse(cx, cy, r*1.2, r*1.2, 0, 0, Math.PI*2);
 ctx2.fill();
 ctx2.restore();
 }
 if (sk === 'cyber') {
 ctx2.save();
 const scanY = cy - r + ((now * 40 + phase * 20) % (r * 2));
 ctx2.globalAlpha = 0.18;
 ctx2.fillStyle = _bT;
 ctx2.fillRect(cx - r, scanY, r * 2, 2);
 ctx2.globalAlpha = 0.5 + 0.3 * Math.sin(now * 3);
 ctx2.strokeStyle = _bT; ctx2.lineWidth = 1.5;
 ctx2.shadowColor = _bT; ctx2.shadowBlur = 8;
 const bkSize = r * 0.25;
 [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([sx2, sy2]) => {
 const bx = cx + sx2 * r * 0.95, by = cy + sy2 * r * 0.88;
 ctx2.beginPath();
 ctx2.moveTo(bx, by + sy2 * bkSize); ctx2.lineTo(bx, by); ctx2.lineTo(bx + sx2 * bkSize, by);
 ctx2.stroke();
 });
 for (let dp = 0; dp < 4; dp++) {
 const angle = (dp / 4) * Math.PI * 2 + now * 2;
 ctx2.globalAlpha = 0.35 + 0.25 * Math.sin(now * 2.5 + dp * 1.57 + phase);
 ctx2.fillStyle = _bT;
 ctx2.fillRect(
 cx + Math.cos(angle) * r * 1.1 - 1.5,
 cy + Math.sin(angle) * r * 1.0 - 1.5,
 3, 3
 );
 }
 ctx2.restore();
 }
 // ‚îÄ‚îÄ BIO SHOP VISUAL EFFECTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (G && (G.bioDPS || G.bioHP || G.bioGold || G.bioMerge || G.bioSpawn || G.bioElite)) {
  ctx2.save();
  // Clip do canvas ≈ºeby efekty nie wychodzi≈Çy poza kom√≥rkƒô
  ctx2.beginPath();
  ctx2.rect(0, 0, W, H);
  ctx2.clip();
  const t3 = now * 2 + phase;
  const orb = r * 0.88; // orbit wewnƒÖtrz blob, nie na zewnƒÖtrz

  // üí™ bio_dps ‚Äî flame aura
  if (G.bioDPS > 0) {
   const dpsLevel = G.bioDPS;
   const flameCount = dpsLevel >= 0.80 ? 8 : dpsLevel >= 0.40 ? 6 : 4;
   for (let fi = 0; fi < flameCount; fi++) {
    const a = (fi / flameCount) * Math.PI * 2 + t3 * 0.8;
    const dist = orb * (0.85 + 0.1 * Math.sin(t3 * 2 + fi));
    const fx = cx + Math.cos(a) * dist;
    const fy = cy + Math.sin(a) * dist;
    const fsize = r * (0.10 + 0.05 * Math.sin(t3 * 3 + fi * 1.3));
    ctx2.globalAlpha = 0.55 + 0.3 * Math.sin(t3 * 2 + fi);
    ctx2.beginPath();
    ctx2.arc(fx, fy, fsize, 0, Math.PI * 2);
    const fg = ctx2.createRadialGradient(fx, fy, 0, fx, fy, fsize);
    fg.addColorStop(0, '#fff5a0');
    fg.addColorStop(0.4, '#ff6600');
    fg.addColorStop(1, 'rgba(200,0,0,0)');
    ctx2.fillStyle = fg;
    ctx2.shadowColor = '#ff3300'; ctx2.shadowBlur = 6;
    ctx2.fill();
   }
   ctx2.globalAlpha = 0.12 + 0.06 * Math.sin(t3 * 1.5);
   ctx2.beginPath();
   ctx2.arc(cx, cy, orb, 0, Math.PI * 2);
   ctx2.fillStyle = '#ff4400';
   ctx2.shadowColor = '#ff2200'; ctx2.shadowBlur = 10;
   ctx2.fill();
  }

  // üõ° bio_hp ‚Äî green shield
  if (G.bioHP > 0) {
   const hpLevel = G.bioHP;
   ctx2.globalAlpha = 0.22 + 0.10 * Math.sin(t3 * 1.2);
   ctx2.strokeStyle = hpLevel >= 0.55 ? '#00ff88' : '#4cd964';
   ctx2.lineWidth = hpLevel >= 0.55 ? 2.5 : 1.8;
   ctx2.shadowColor = '#4cd964'; ctx2.shadowBlur = 8;
   ctx2.setLineDash([4, 3]);
   ctx2.beginPath();
   ctx2.ellipse(cx, cy, orb * 0.95, orb * 0.93, t3 * 0.3, 0, Math.PI * 2);
   ctx2.stroke();
   ctx2.setLineDash([]);
   if (hpLevel >= 0.55) {
    for (let hi = 0; hi < 6; hi++) {
     const ha = hi / 6 * Math.PI * 2 + t3 * 0.2;
     ctx2.globalAlpha = 0.5 + 0.3 * Math.sin(t3 * 2 + hi);
     ctx2.beginPath();
     ctx2.arc(cx + Math.cos(ha) * orb * 0.95, cy + Math.sin(ha) * orb * 0.93, r * 0.06, 0, Math.PI * 2);
     ctx2.fillStyle = '#00ff88';
     ctx2.fill();
    }
   }
  }

  // ‚öó bio_gold ‚Äî gold stars orbiting
  if (G.bioGold > 0) {
   const starCount = G.bioGold >= 0.55 ? 5 : 3;
   for (let gi = 0; gi < starCount; gi++) {
    const ga = (gi / starCount) * Math.PI * 2 + t3 * 0.6;
    const gdist = orb * (0.80 + 0.08 * Math.sin(t3 * 1.5 + gi * 2));
    const gx = cx + Math.cos(ga) * gdist;
    const gy = cy + Math.sin(ga) * gdist;
    ctx2.globalAlpha = 0.7 + 0.3 * Math.sin(t3 * 2 + gi * 1.5);
    ctx2.font = `${Math.floor(r * 0.24)}px sans-serif`;
    ctx2.textAlign = 'center'; ctx2.textBaseline = 'middle';
    ctx2.shadowColor = '#ffd700'; ctx2.shadowBlur = 6;
    ctx2.fillStyle = '#ffd700';
    ctx2.fillText('‚ú¶', gx, gy);
   }
  }

  // ‚¨° bio_merge ‚Äî purple DNA particles
  if (G.bioMerge > 0) {
   for (let mi = 0; mi < 5; mi++) {
    const ma = (mi / 5) * Math.PI * 2 + t3 * -0.5;
    const mdist = orb * (0.70 + 0.22 * Math.sin(t3 * 2.5 + mi));
    ctx2.globalAlpha = 0.5 + 0.4 * Math.sin(t3 * 1.8 + mi * 1.2);
    ctx2.beginPath();
    ctx2.arc(cx + Math.cos(ma) * mdist, cy + Math.sin(ma) * mdist, r * 0.055, 0, Math.PI * 2);
    ctx2.fillStyle = '#bf5af2';
    ctx2.shadowColor = '#bf5af2'; ctx2.shadowBlur = 5;
    ctx2.fill();
   }
  }

  // ‚ö° bio_spawn ‚Äî electric sparks
  if (G.bioSpawn > 0) {
   ctx2.strokeStyle = '#5ac8fa'; ctx2.lineWidth = 1.4;
   ctx2.shadowColor = '#5ac8fa'; ctx2.shadowBlur = 5;
   for (let zi = 0; zi < 3; zi++) {
    const za = (zi / 3) * Math.PI * 2 + Math.floor(t3 * 4) * 0.7 + zi;
    const zr1 = orb * 0.6, zr2 = orb * 0.88;
    ctx2.globalAlpha = 0.5 + 0.4 * Math.sin(t3 * 4 + zi * 2);
    ctx2.beginPath();
    ctx2.moveTo(cx + Math.cos(za) * zr1, cy + Math.sin(za) * zr1);
    const zmid = za + 0.3;
    ctx2.lineTo(cx + Math.cos(zmid) * (zr1 + zr2) / 2 + Math.sin(t3 * 8 + zi) * r * 0.12, cy + Math.sin(zmid) * (zr1 + zr2) / 2);
    ctx2.lineTo(cx + Math.cos(za + 0.6) * zr2, cy + Math.sin(za + 0.6) * zr2);
    ctx2.stroke();
   }
  }

  // ‚≠ê bio_elite ‚Äî gold stars at top corners of blob
  if (G.bioElite > 0) {
   const starPulse = 0.7 + 0.3 * Math.sin(t3 * 2.5);
   ctx2.font = `${Math.floor(r * 0.28)}px sans-serif`;
   ctx2.textAlign = 'center'; ctx2.textBaseline = 'middle';
   ctx2.shadowColor = '#ffd700'; ctx2.shadowBlur = 8;
   ctx2.fillStyle = `rgba(255,215,0,${starPulse})`;
   ctx2.globalAlpha = starPulse;
   ctx2.fillText('‚òÖ', cx - r * 0.55, cy - r * 0.65);
   ctx2.globalAlpha = 0.6 + 0.3 * Math.sin(t3 * 2.5 + 1.5);
   ctx2.fillText('‚òÖ', cx + r * 0.55, cy - r * 0.65);
  }

  ctx2.globalAlpha = 1;
  ctx2.shadowBlur = 0;
  ctx2.restore();
 }

 const fs = Math.floor(r * 0.42);
 ctx2.font = `bold ${fs}px "Fredoka One", sans-serif`;
 ctx2.textAlign = 'center'; ctx2.textBaseline = 'middle';
 ctx2.fillStyle = 'rgba(255,255,255,0.88)';
 ctx2.shadowColor = _bB; ctx2.shadowBlur = 4;
 ctx2.fillText('T' + u.tier, cx, H - r * 0.18);
 ctx2.shadowBlur = 0;
}
let _lastGridFingerprint = '';
function getGridFingerprint() {
 const bioState = `bio:${G.bioDPS||0}|${G.bioHP||0}|${G.bioGold||0}|${G.bioMerge||0}|${G.bioSpawn||0}|${G.bioElite||0}`;
 return grid.map((u,i) => u
  ? `${i}:${u.tier}${u.mutant?'m':''}${u.elite?'e':''}${u.special||''}`
  : `${i}:_`
 ).join('|') + '|' + getUnlockedSlots() + '|' + (G.activeRelic||'') + '|sel:' + selectedCell + '|' + bioState;
}
function updateGridStats() {
 G.totalDPS = calcTotalDPS();
 const unitCount = grid.filter(Boolean).length;
 const totalPlayable = Array.from({length: GRID_SIZE}, (_, i) => i)
  .filter(i => G.activeRelic === 'fortress' ? i < 12 : isSlotPlayable(i)).length;
 const el_dps  = document.getElementById('pill-dps');
 const el_ldv  = document.getElementById('live-dps-val');
 const el_units= document.getElementById('pill-units');
 const el_idle = document.getElementById('pill-idle');
 const el_inc  = document.getElementById('income-hint');
 const el_buy  = document.getElementById('buy-cost-hint');
 if (el_dps)   el_dps.textContent   = `DPS: ${formatNum(G.totalDPS)}`;
 if (el_ldv)   el_ldv.textContent   = formatNum(G.totalDPS);
 if (el_units) el_units.textContent = `UNITS: ${unitCount}/${totalPlayable}`;
 if (el_idle)  el_idle.textContent  = `IDLE: ${Math.round(G.idleEfficiency * 100)}%`;
 if (el_inc)   el_inc.textContent   = `${formatNum(idleGoldPerSec()).padStart(3)}/s`;
 if (el_buy)   el_buy.textContent   = getBuyCost() + 'g';
 updateBuyButton(); renderMergeHints(); renderSynergyBar();
}
function renderGrid(forceRebuild) {
 const fp = getGridFingerprint();
 if (!forceRebuild && fp === _lastGridFingerprint) {
  updateGridStats();
  return;
 }
 _lastGridFingerprint = fp;
 const el = document.getElementById('merge-grid');
 // Zachowaj pozycjƒô scrolla i rozmiar ≈ºeby layout nie skaka≈Ç
 const savedScroll = el.scrollTop;
 const savedHeight = el.offsetHeight;
 el.style.minHeight = savedHeight + 'px';
 el.innerHTML = '';
 GRID_ANIM_CANVASES.clear();
 if (gridAnimId) { cancelAnimationFrame(gridAnimId); gridAnimId = null; }

 const ROW_META = [
  { cls:'row-front',   icon:'üõ°', name:'TANK',     bonus:'+35% HP',  color:'#ff453a', locked: false },
  { cls:'row-mid',     icon:'‚ö°', name:'DPS',      bonus:'+30% DPS', color:'#5ac8fa', locked: false },
  { cls:'row-mid',     icon:'üî•', name:'BRUISER',  bonus:'+15/15%',  color:'#fb923c', locked: false },
  { cls:'row-back',    icon:'üó°', name:'ASSASSIN', bonus:'+50% DPS', color:'#bf5af2', locked: false },
  { cls:'row-support', icon:'üåø', name:'SUPPORT',  bonus:'passive',  color:'#4cd964', locked: false },
 ];
 const unlockedSlots = getUnlockedSlots();

 for (let rowIdx = 0; rowIdx < 5; rowIdx++) {
  const meta = ROW_META[rowIdx];
  const rowStart = rowIdx * 4;
  const rowEnd   = rowStart + 4;

  // Count how many slots in this row are playable
  const playableInRow = [rowStart, rowStart+1, rowStart+2, rowStart+3]
   .filter(i => isSlotPlayable(i) && G.activeRelic !== 'fortress' || G.activeRelic === 'fortress' && i < 12)
   .length;
  const allLocked   = playableInRow === 0;
  const partialLock = playableInRow > 0 && playableInRow < 4;

  // Row group wrapper
  const rg = document.createElement('div');
  rg.className = 'row-group ' + (allLocked ? 'row-locked' : meta.cls);

  // ‚îÄ‚îÄ Label column ‚îÄ‚îÄ
  const lc = document.createElement('div');
  lc.className = 'row-label-col';
  let bonusLabel = meta.bonus;
  if (allLocked) bonusLabel = 'üîí BUY';
  else if (partialLock) bonusLabel = meta.bonus + ' ¬∑ 2/4';
  lc.innerHTML = `
   <span class="row-label-icon">${meta.icon}</span>
   <span class="row-label-name">${meta.name}</span>
   <span class="row-label-bonus">${bonusLabel}</span>
  `;
  if (allLocked || partialLock) {
   lc.title = partialLock ? `2 free slots! Buy in Shop to unlock all 4.` : 'Unlock in Shop!';
   lc.style.cursor = 'pointer';
   lc.addEventListener('click', openShop);
  }
  rg.appendChild(lc);

  // ‚îÄ‚îÄ 4 cells ‚îÄ‚îÄ
  const rc = document.createElement('div');
  rc.className = 'row-cells';

  for (let i = rowStart; i < rowEnd; i++) {
   const cell = document.createElement('div');
   const u = grid[i];
   const fortressLocked = G.activeRelic === 'fortress' && i >= 12;
   const storeLocked    = !fortressLocked && !isSlotPlayable(i);

   cell.className = 'grid-cell'
    + (u && !storeLocked ? ' occupied' : '')
    + (selectedCell === i && !storeLocked ? ' selected' : '')
    + (u && !storeLocked ? ` t${u.tier}-cell` : '')
    + (u?.mutant  && !storeLocked ? ' mutant-cell' : '')
    + (u?.elite   && !storeLocked ? ' elite-cell'  : '')
    + (u?.special && !storeLocked ? ' special-cell': '')
    + (fortressLocked ? ' fortress-locked' : '')
    + (storeLocked    ? ' store-locked'    : '');
   cell.dataset.idx = i;

   if (u && !storeLocked && !fortressLocked) {
    const ut = UNIT_TYPES[u.tier];
    const dps = getUnitDPS(u.tier, u.mutant, getSynergyMultForUnit(u.tier) * getAdjacencyMult(i), i);
    // Blob canvas
    const bc = document.createElement('canvas');
    bc.className = 'blob-canvas'; bc.width = 80; bc.height = 80;
    const bctx = bc.getContext('2d');
    const phase = (i * 2.4) % (Math.PI * 2);
    GRID_ANIM_CANVASES.set(i, { canvas: bc, ctx2: bctx, unit: u, phase });
    drawGridBlob(bctx, 80, 80, u, phase);
    cell.appendChild(bc);
    // Tag badges
    const tagWrap = document.createElement('div');
    tagWrap.style.cssText = 'position:absolute;bottom:3px;right:3px;display:flex;gap:2px;z-index:4;';
    (ut?.tags || []).forEach(t => {
     const tb = document.createElement('span');
     tb.className = `tag-badge tag-${t.toLowerCase()}`;
     tb.textContent = t[0];
     tagWrap.appendChild(tb);
    });
    cell.appendChild(tagWrap);
    // Special badge
    if (u.special) {
     const badge = document.createElement('div');
     badge.className = 'special-unit-badge';
     badge.textContent = u.specialEmoji || 'üß™';
     cell.appendChild(badge);
    }
    // Tooltip
    const wrap = document.createElement('div');
    wrap.className = 'tooltip-wrap';
    wrap.style.cssText = 'position:absolute;inset:0;z-index:5;';
    const tip = document.createElement('div');
    tip.className = 'tooltip';
    const rowInfo = `<div style="color:${meta.color};font-size:9px;margin-top:3px">${meta.icon} ${meta.name}: ${meta.bonus}</div>`;
    tip.innerHTML = `
     <div class="tt-name">${ut?.name || u.specialName || 'SPECIAL'}${u.mutant?' ‚ö°MUTANT':''}${u.elite?' üåüELITE':''}${u.special?' üß™':''}
     </div>
     <hr class="tt-sep">
     <div class="tt-dps">DPS: ${formatNum(dps)}</div>
     <div>ROLE: <span style="color:var(--blue)">${ut?.role?.toUpperCase() || 'SPECIAL'}</span></div>
     <div>${ut?.roleDesc || ''}</div>
     <div class="tt-trait">${(ut?.tags||[]).map(t=>`[${t}]`).join(' ')} ${ut?.traitDesc || ''}</div>
     ${u.mutant ?'<div style="color:var(--yellow)">√ó2.2 DPS mutant</div>'  : ''}
     ${u.elite  ?'<div style="color:var(--yellow)">√ó2.0 DPS elite</div>'   : ''}
     ${u.special?`<div style="color:var(--yellow)">üß™ √ó${u.dpsMulti||1} crafted</div>` : ''}
     ${rowInfo}`;
    wrap.appendChild(tip);
    cell.appendChild(wrap);
    // Drag
    cell.draggable = true;
    cell.addEventListener('dragstart', () => { dragSrc = i; cell.style.opacity = '0.4'; });
    cell.addEventListener('dragend',   () => {
     cell.style.opacity = '1';
     setTimeout(() => { if (dragSrc !== null) { dragSrc = null; renderGrid(); } }, 50);
    });
   }
   // Events always
   cell.addEventListener('dragover',  e => { e.preventDefault(); cell.classList.add('drag-over'); });
   cell.addEventListener('dragleave', ()  => cell.classList.remove('drag-over'));
   cell.addEventListener('drop',      e  => { e.preventDefault(); handleDrop(i); });
   cell.addEventListener('click',     ()  => handleCellClick(i));
   cell.addEventListener('touchstart', e => {
    if (!grid[i]) return; e.preventDefault();
    dragSrc = i; cell.style.opacity = '0.4'; cell.classList.add('selected');
   }, { passive: false });
   cell.addEventListener('touchend', e => {
    e.preventDefault(); cell.style.opacity = '1'; cell.classList.remove('selected');
    if (dragSrc === null) return;
    const touch = e.changedTouches[0];
    const tgt = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.grid-cell');
    if (tgt) { const ti = parseInt(tgt.dataset.idx); if (!isNaN(ti) && ti !== dragSrc) { handleDrop(ti); return; } }
    dragSrc = null; renderGrid();
   }, { passive: false });
   cell.addEventListener('touchmove', e => {
    e.preventDefault();
    const t = e.touches[0];
    document.querySelectorAll('.grid-cell.drag-over').forEach(c => c.classList.remove('drag-over'));
    const tc = document.elementFromPoint(t.clientX, t.clientY)?.closest('.grid-cell');
    if (tc && tc !== cell) tc.classList.add('drag-over');
   }, { passive: false });
   rc.appendChild(cell);
  } // end cells loop

  rg.appendChild(rc);
  el.appendChild(rg);
 } // end rows loop

 startGridAnim();
 updateGridStats();
 // Przywr√≥ƒá scroll i zwolnij blokadƒô wysoko≈õci
 el.scrollTop = savedScroll;
 requestAnimationFrame(() => { el.style.minHeight = ''; });
}
function renderRowLabels() {} // noop ‚Äî handled inside renderGrid now
function renderMergeHints() { const el = document.getElementById('merge-hints');
 el.innerHTML = '';
 const counts = new Array(11).fill(0);
 grid.forEach(c => { if (c && c.tier < 10) counts[c.tier]++; });
 for (let t = 1; t <= 9; t++) {
 if (counts[t] === 0) continue;
 const need = 2, have = counts[t];
 const ready = have >= need;
 const oneAway = have === 1;
 const chip = document.createElement('div');
 chip.className = 'merge-hint-chip' + (ready ? ' ready' : oneAway ? ' one-away' : '');
 const tierColors = ['','#4ade80','#60a5fa','#f472b6','#fb923c','#e879f9','#ffffff','#00e5ff','#cd8040','#aa00ff','#ff5500'];
 const pips = `<span class="hint-bar">
 <span class="hint-pip ${have >= 1 ? 'filled' : ''}"></span>
 <span class="hint-pip ${have >= 2 ? 'filled' : ''}"></span>
 </span>`;
 chip.innerHTML = `<span style="color:${tierColors[t]}">T${t}</span>${pips}<span>${have}/2${ready ? ' ‚ñ≤' : ''}</span>`;
 chip.title = ready
 ? `MERGE READY: 2√ó T${t} ‚Üí T${t+1} ${UNIT_TYPES[t+1].name}!`
 : `Need ${need - have} more T${t} to merge`;
 el.appendChild(chip);
 }
}
function doMerge(srcIdx, tgtIdx) {
 const src = grid[srcIdx], tgt = grid[tgtIdx];
 if (!tgt || !src || src.tier !== tgt.tier || src.tier >= 10) return false;
 // Check for special recipes first
 const recipe = findRecipeMatch(srcIdx, tgtIdx);
 if (recipe) {
  craftRecipe(recipe, srcIdx, tgtIdx);
  return true;
 }
 if (G.activeRelic === 'volatile') {
 const hpCost = 20 + src.tier * 10;
 const u = arenaUnits.find(u => u.tier === src.tier);
 if (u) {
 u.hp = Math.max(1, u.hp - hpCost);
 addFloatDmg ? addFloatDmg(`-${hpCost}HP`, 200, 200, '#ff006e', false) : null;
 }
 }
 const mutChance = G.activeRelic === 'catalyst' ? 0.30
 : 0.05
 + G.upgrades.merge_luck * 0.035
 + G.researchBonuses.mutation_chance * 0.05
 + G.researchBonuses.merge_chance * 0.05;
 const mutant = Math.random() < mutChance;
 grid[srcIdx] = null;
 grid[tgtIdx] = { tier: src.tier + 1, mutant };
 triggerMergeAnim(tgtIdx, src.tier + 1, mutant);
 onMergeStreakTick();
 if (mutant) {
 addLog(t('logMutation', src.tier+1, tUnit(src.tier+1)), 'mutant');
 showNotif(t('mutation'), 'var(--pink)');
 sfx.mutant();
 } else {
 addLog(t('logMerged', src.tier+1, tUnit(src.tier+1)), 'merge');
 sfx.merge(src.tier + 1);
 }
 // Przebuduj arenaUnits podczas walki ≈ºeby nowa jednostka by≈Ça widoczna z mutacjƒÖ
 if (G.fighting) buildArenaUnits();
 return true;
}
function triggerBuyAnim(cellIdx, cost) {
 const cell = document.querySelector(`#merge-grid [data-idx="${cellIdx}"]`);
 if (!cell) return;
 cell.classList.remove('blob-spawning');
 void cell.offsetWidth; 
 cell.classList.add('blob-spawning');
 setTimeout(() => cell.classList.remove('blob-spawning'), 600);
 const rect = cell.getBoundingClientRect();
 const pop = document.createElement('div');
 pop.className = 'buy-gold-pop';
 pop.textContent = `-${cost}g`;
 pop.style.left = (rect.left + rect.width / 2 - 18) + 'px';
 pop.style.top = (rect.top + rect.height / 2) + 'px';
 document.body.appendChild(pop);
 setTimeout(() => pop.remove(), 750);
 const colors = ['#4ade80','#60a5fa','#fbbf24','#fff'];
 for (let i = 0; i < 8; i++) {
 const s = document.createElement('div');
 const angle = (i / 8) * Math.PI * 2;
 const dist = 28 + Math.random() * 18;
 const cx = rect.left + rect.width / 2;
 const cy = rect.top + rect.height / 2;
 s.style.cssText = `
 position:fixed; pointer-events:none; z-index:9999;
 width:5px; height:5px; border-radius:50%;
 background:${colors[i % colors.length]};
 left:${cx}px; top:${cy}px;
 box-shadow: 0 0 6px ${colors[i % colors.length]};
 transition: transform 0.4s ease-out, opacity 0.4s ease-out;
 transform: translate(-50%,-50%);
 opacity: 1;
 `;
 document.body.appendChild(s);
 requestAnimationFrame(() => requestAnimationFrame(() => {
 s.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px)) scale(0)`;
 s.style.opacity = '0';
 }));
 setTimeout(() => s.remove(), 450);
 }
}
function triggerMergeAnim(cellIdx, tier, mutant) {
 const cell = document.querySelector(`#merge-grid [data-idx="${cellIdx}"]`);
 if (!cell) return;
 const rect = cell.getBoundingClientRect();
 const cx = rect.left + rect.width / 2;
 const cy = rect.top + rect.height / 2;
 cell.classList.add('merge-flash');
 setTimeout(() => cell.classList.remove('merge-flash'), 450);
 const ringColors = mutant
 ? ['var(--pink)', 'var(--yellow)', 'var(--purple)']
 : ['var(--green)', 'var(--blue)', '#fff'];
 const ringSize = 44;
 ringColors.forEach((color, i) => {
 setTimeout(() => {
 const ring = document.createElement('div');
 ring.className = 'merge-ring';
 ring.style.cssText = `
 left:${cx - ringSize/2}px; top:${cy - ringSize/2}px;
 width:${ringSize}px; height:${ringSize}px;
 border-color:${color};
 animation-delay:0s;
 `;
 document.body.appendChild(ring);
 setTimeout(() => ring.remove(), 600);
 }, i * 80);
 });
 const symbols = mutant
 ? ['‚ö°','üß¨','‚ú¶','‚òÖ','‚ö°']
 : ['‚ú¶','‚óÜ','‚óè','‚ú¶','‚óã'];
 const count = mutant ? 14 : 10;
 for (let i = 0; i < count; i++) {
 const angle = (Math.PI * 2 / count) * i + Math.random() * 0.4;
 const dist = 40 + Math.random() * 60;
 const tx = Math.cos(angle) * dist;
 const ty = Math.sin(angle) * dist;
 const sp = document.createElement('div');
 sp.className = 'sparkle';
 sp.style.cssText = `
 left:${cx}px; top:${cy}px;
 --tx:${tx}px; --ty:${ty}px;
 color:${mutant ? '#ff006e' : '#39ff14'};
 animation-duration:${0.55 + Math.random() * 0.35}s;
 animation-delay:${Math.random() * 0.1}s;
 font-size:${8 + Math.random() * 9}px;
 `;
 sp.textContent = symbols[i % symbols.length];
 document.body.appendChild(sp);
 setTimeout(() => sp.remove(), 1000);
 }
 setTimeout(() => {
 const lbl = document.createElement('div');
 lbl.style.cssText = `
 position:fixed; left:${cx}px; top:${cy - 24}px;
 font-family:'Orbitron',sans-serif; font-size:${mutant ? 16 : 13}px; font-weight:900;
 color:${mutant ? 'var(--pink)' : 'var(--green)'};
 text-shadow: 0 0 10px currentColor;
 pointer-events:none; z-index:460;
 animation: float-up 1s ease-out forwards;
 `;
 lbl.textContent = mutant ? `‚ö° T${tier} MUTANT!` : `‚ñ≤ T${tier}`;
 document.body.appendChild(lbl);
 setTimeout(() => lbl.remove(), 1100);
 }, 60);
}
function handleDrop(target) {
 if (dragSrc === null || dragSrc === target) return;
 if (!isSlotPlayable(target) && G.activeRelic !== 'fortress') {
 openShop(); dragSrc = null; renderGrid(); return;
 }
 if (G.activeRelic === 'fortress' && target >= 12) {
 showNotif('üîí FORTRESS: only left 12 slots!', 'var(--yellow)');
 dragSrc = null; renderGrid(); return;
 }
 const src = grid[dragSrc], tgt = grid[target];
 if (tgt && src && src.tier === tgt.tier && src.tier < 10) {
 doMerge(dragSrc, target);
 } else if (!tgt) {
 grid[target] = src;
 grid[dragSrc] = null;
 } else {
 grid[target] = src;
 grid[dragSrc] = tgt;
 }
 dragSrc = null;
 renderGrid();
}
function handleCellClick(i) {
 if (!isSlotPlayable(i) && G.activeRelic !== 'fortress') { openShop(); return; }
 const fortressTarget = G.activeRelic === 'fortress' && i >= 12;
 if (fortressTarget && selectedCell === null) {
 if (grid[i]) { selectedCell = i; sfx.tick(); renderGrid(); }
 return;
 }
 if (fortressTarget) {
 showNotif('üîí Move to left 3 columns!', 'var(--yellow)');
 selectedCell = null; renderGrid(); return;
 }
 if (selectedCell === null) {
 if (grid[i]) {
  selectedCell = i;
  sfx.tick();
  // Ma≈Çy hint przy pierwszym zaznaczeniu (tylko raz)
  if (!G._clickMergeHintShown) {
   G._clickMergeHintShown = true;
   showNotif('üëÜ Now click another blob to merge or move!', 'var(--yellow)');
  }
 }
 } else {
 if (selectedCell === i) {
  // Klik na tƒô samƒÖ ‚Äî odznacz
  selectedCell = null;
  sfx.tick();
  renderGrid();
  return;
 }
 const src = grid[selectedCell], tgt = grid[i];
 if (tgt && src && src.tier === tgt.tier && src.tier < 10) {
  doMerge(selectedCell, i);
 } else if (!tgt) {
  grid[i] = src;
  grid[selectedCell] = null;
 } else {
  // Swap
  grid[i] = src;
  grid[selectedCell] = tgt;
 }
 selectedCell = null;
 renderGrid();
 return;
 }
 renderGrid();
}
function tryAutoMerge() {
 if (!G.autoMerge) return;
 let merged = false;
 for (let t = 1; t <= 9; t++) {
 const idx = [];
 for (let i = 0; i < GRID_SIZE; i++) {
  const playable = G.activeRelic === 'fortress' ? i < 12 : isSlotPlayable(i);
  if (grid[i] && grid[i].tier === t && playable) idx.push(i);
 }
 if (idx.length >= 2) {
  // src = wy≈ºszy indeks (ni≈ºej w gridzie), tgt = ni≈ºszy indeks (wy≈ºej) ‚Äî wynik zostaje wy≈ºej
  doMerge(idx[1], idx[0]);
  merged = true;
  break;
 }
 }
 if (merged) {
 renderGrid();
 setTimeout(tryAutoMerge, 150);
 }
}
function buyUnit() {
 initAudio();
 const cost = getBuyCost();
 if (G.gold < cost) return;
 const empty = grid.map((c, i) => {
  const playable = G.activeRelic === 'fortress' ? i < 12 : isSlotPlayable(i);
  return c === null && playable ? i : -1;
 }).filter(i => i >= 0);
 if (empty.length === 0) { showNotif(t('gridFull'), 'var(--pink)'); return; }
 G.gold -= cost;
 const slot = empty[Math.floor(Math.random() * empty.length)];
 const tier = G.upgrades.start_tier ? 2 : 1;
 grid[slot] = { tier, mutant: false };
 addLog(t('logBought', tier, tUnit(tier), cost), 'merge');
 sfx.buy();
 updateCurrencies();
 renderGrid();
 requestAnimationFrame(() => triggerBuyAnim(slot, cost));
 if (G.autoMerge) {
 setTimeout(tryAutoMerge, 80);
 setTimeout(tryAutoMerge, 200);
 }
}
function updateBuyButton() {
 const cost = getBuyCost();
 const tier = G.upgrades.start_tier ? 2 : 1;
 // Policz wszystkie tiery w gridzie
 const tierCounts = {};
 grid.forEach(c => { if (c) tierCounts[c.tier] = (tierCounts[c.tier] || 0) + 1; });
 const tiers = Object.keys(tierCounts).map(Number).sort((a,b) => b - a);
 const hint = tiers.length > 0
  ? ' (' + tiers.slice(0, 3).map(t => `${tierCounts[t]}√óT${t}`).join(' ') + ')'
  : '';
 document.getElementById('buy-cost').textContent = `${cost}g${hint}`;
 const totalPlayable = grid.filter((c, i) => G.activeRelic === 'fortress' ? i < 12 : isSlotPlayable(i)).length;
 const usedSlots = grid.filter((c, i) => c && (G.activeRelic === 'fortress' ? i < 12 : isSlotPlayable(i))).length;
 document.getElementById('btn-buy').disabled = G.gold < cost || usedSlots >= totalPlayable;
}
function toggleAuto() {
 if (!G.upgrades.automerge_unlock) {
 showNotif(t('unlockAuto'), 'var(--pink)');
 return;
 }
 G.autoMerge = !G.autoMerge;
 document.getElementById('btn-auto').className = 'btn btn-automerge' + (G.autoMerge ? ' active' : '');
}
const canvas = document.getElementById('arena-canvas');
const ctx = canvas.getContext('2d');
let arenaUnits = [];
let _godMode = false;
let enemies = [];
let particles = [];
let floatingDmg = [];
let foodItems = [];
let _foodSpawnTimer = 3;
let _foodBuffs = [];
let _foodFlash = null;
let _lastDt = 0.016; // dla drawFoodFlash/drawFoodNotifs
let animFrame;
let bossPhase = false;
let bossRef = null; 
const ENEMY_TYPES = [
 { name: 'Crawler',  hp: 40,    speed: 1.0,  reward: 4,   color: '#ef4444', size: 8,  resist: [], weakTo: 'FIRE',  weakMult: 1.4 },
 { name: 'Bruiser',  hp: 130,   speed: 0.65, reward: 12,  color: '#f97316', size: 13, resist: [], weakTo: 'TOXIC', weakMult: 1.5 },
 { name: 'Speeder',  hp: 55,    speed: 2.6,  reward: 7,   color: '#eab308', size: 6,  resist: [], weakTo: 'MECH',  weakMult: 1.6 },
 { name: 'Tank',     hp: 1400,  speed: 0.35, reward: 45,  color: '#dc2626', size: 19, resist: [], weakTo: 'FIRE',  weakMult: 1.45 },
 { name: 'Slasher',  hp: 500,   speed: 1.8,  reward: 22,  color: '#a855f7', size: 10, resist: [], weakTo: 'BIO',   weakMult: 1.5 },
 { name: 'Goliath',  hp: 6000,  speed: 0.25, reward: 110, color: '#6b7280', size: 24, resist: [], weakTo: 'TOXIC', weakMult: 1.4 },
 { name: 'Phantom',  hp: 350,   speed: 3.5,  reward: 35,  color: '#06b6d4', size: 7,  resist: [], weakTo: 'MECH',  weakMult: 1.7 },
 { name: 'Behemoth', hp: 35000, speed: 0.18, reward: 400, color: '#991b1b', size: 30, resist: [], weakTo: 'BIO',   weakMult: 1.35 },
 { name: 'Nullifier', hp: 300,  speed: 1.0,  reward: 30,  color: '#a0a0a0', size: 11,
 resist: ['crit'], resistDesc: 'Immune to critical hits', special: 'anti_crit', weakTo: 'TOXIC', weakMult: 1.6 },
 { name: 'Shielded', hp: 450,   speed: 0.8,  reward: 40,  color: '#3b82f6', size: 14,
 resist: ['dot'], resistDesc: 'Immune to DOT effects', special: 'shield', shieldHp: 200, weakTo: 'FIRE', weakMult: 1.5 },
 { name: 'Rusher',   hp: 80,    speed: 4.5,  reward: 18,  color: '#f59e0b', size: 6,
 resist: [], resistDesc: 'Extremely fast. Bypasses frontline', special: 'rusher', weakTo: 'MECH', weakMult: 1.8 },
 { name: 'Breaker',  hp: 600,   speed: 0.9,  reward: 55,  color: '#ef4444', size: 15,
 resist: [], resistDesc: 'Targets support units first', special: 'anti_support', weakTo: 'BIO', weakMult: 1.55 },
];
function getEnemyTypeForWave(wave) {
 const pool = [0];
 if (wave >= 5) pool.push(2); 
 if (wave >= 5) pool.push(1);
 if (wave >= 8) pool.push(3); 
 if (wave >= 12) pool.push(4); 
 if (wave >= 15) pool.push(8, 9, 10, 11); 
 if (wave >= 18) pool.push(5); 
 if (wave >= 25) pool.push(6); 
 if (wave >= 40) pool.push(7); 
 if (wave >= 20) pool.push(3, 4);
 if (wave >= 30) pool.push(5, 8, 9);
 return pool[Math.floor(Math.random() * pool.length)];
}
const RELICS = [
 { id: 'berserker', name: 'üî• BERSERKER CORE',
 desc: '+40% DPS for all units. Units take 25% more damage.',
 effect: { dpsBonus: 1.4, hpMult: 0.75 } },
 { id: 'fortress', name: 'üõ° FORTRESS GRID',
 desc: 'Units have +80% HP. Only 3 columns usable (left 12 slots).',
 effect: { hpBonus: 1.8, gridLimit: 12 } },
 { id: 'catalyst', name: '‚öó MUTATION CATALYST',
 desc: 'Every merge has 30% mutant chance. Mutants deal 3√ó DPS.',
 effect: { mutantChance: 0.30, mutantDmgMult: 3.0 } },
 { id: 'economy', name: 'üí∞ GOLD RUSH',
 desc: 'Earn 2√ó gold from waves. Units cost 50% more.',
 effect: { goldMult: 2.0, costMult: 1.5 } },
 { id: 'synergy', name: 'üß¨ SYNERGY ENGINE',
 desc: 'Adjacency bonuses doubled. Synergy thresholds reduced by 1.',
 effect: { adjacencyMult: 2.0, synergyReduction: 1 } },
 { id: 'volatile', name: 'üí• VOLATILE MASS',
 desc: 'All units gain Exploder role. Merge costs health instead of gold.',
 effect: { forceExploder: true, mergeCostHP: true } },
];
// ‚îÄ‚îÄ ARENA EVENTS (random during wave) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ARENA_EVENTS = [
 { id: 'meteor_shower', name: '‚òÑ METEOR SHOWER', color: '#fb923c',
   apply() {
    showNotif('‚òÑ METEOR SHOWER!', '#fb923c');
    for (let i = 0; i < 6; i++) setTimeout(() => {
     if (!G.fighting || enemies.length === 0) return;
     const t2 = enemies[Math.floor(Math.random()*enemies.length)];
     if (t2) { const dmg = 200 + G.wave * 30; t2.hp -= dmg; addFloatDmg('‚òÑ'+formatNum(dmg), t2.x, t2.y, '#fb923c', true); spawnBossDeathExplosion(t2.x, t2.y, '#fb923c'); }
    }, i * 400);
   }
 },
 { id: 'gold_rush', name: 'üí∞ GOLD RUSH', color: '#facc15',
   apply() {
    showNotif('üí∞ GOLD RUSH! 10s double income!', '#facc15');
    const orig = G.activeEffects.find(e => e.id === 'economy_temp');
    G.activeEffects.push({ id: 'economy_temp', waves: 1, goldMult: 2 });
    setTimeout(() => { G.activeEffects = G.activeEffects.filter(e => e.id !== 'economy_temp'); }, 10000);
   }
 },
 { id: 'enemy_swarm', name: 'üêõ ENEMY SWARM', color: '#ef4444',
   apply() {
    showNotif('üêõ ENEMY SWARM! Extra enemies incoming!', '#ef4444');
    for (let i = 0; i < 5; i++) setTimeout(() => {
     if (!G.fighting) return;
     const et = ENEMY_TYPES[Math.min(2, Math.floor(G.wave / 10))];
     const side = Math.random() < 0.5 ? 1 : -1;
     enemies.push(makeEnemy(side > 0 ? canvas.width + 20 : -20, 60 + Math.random() * (canvas.height - 120), et, Math.pow(1.10, G.wave - 1) * 0.7));
    }, i * 600);
   }
 },
 { id: 'power_surge', name: '‚ö° POWER SURGE', color: '#e879f9',
   apply() {
    showNotif('‚ö° POWER SURGE! +50% DPS for 8s!', '#e879f9');
    arenaUnits.forEach(u => { u._surgeDps = u.dps; u.dps = Math.floor(u.dps * 1.5); });
    setTimeout(() => { arenaUnits.forEach(u => { if (u._surgeDps) { u.dps = u._surgeDps; delete u._surgeDps; } }); }, 8000);
   }
 },
];
let _arenaEventTimer = 0;
let _arenaEventCooldown = 0;
function tickArenaEvents(dt) {
 if (!G.fighting || enemies.length === 0) return;
 _arenaEventTimer += dt;
 _arenaEventCooldown -= dt;
 // Random event every 18-30 seconds, max once per wave
 if (_arenaEventTimer > 18 + Math.random() * 12 && _arenaEventCooldown <= 0) {
  _arenaEventTimer = 0;
  _arenaEventCooldown = 999; // once per wave
  const ev = ARENA_EVENTS[Math.floor(Math.random() * ARENA_EVENTS.length)];
  ev.apply();
 }
}

const WAVE_EVENTS = [
 { id: 'crit_aura', name: '‚ú¶ CRIT AURA',
 desc: 'All units have +25% crit chance for next 3 waves.',
 apply(){ G.activeEffects.push({ id:'crit_aura', waves:3, critBonus:0.25 }); } },
 { id: 'meteor', name: '‚òÑ METEOR SHOWER',
 desc: 'Start of next wave: 5 meteors hit random enemies for massive damage.',
 apply(){ G.activeEffects.push({ id:'meteor', waves:1, count:5 }); } },
 { id: 'elite', name: '‚ö° SACRIFICE ‚Üí ELITE',
 desc: 'Remove one unit from grid. A random unit becomes Elite (+100% DPS, glow).',
 apply(){ applyEliteEvent(); } },
 { id: 'gold_rain', name: 'üí∞ GOLD RAIN',
 desc: 'Gain gold equal to 3√ó your current wave reward immediately.',
 apply(){ const g=waveGoldReward(G.wave)*3; G.gold+=g; showNotif(`+${formatNum(g)} GOLD!`,'var(--yellow)'); updateCurrencies(); } },
 { id: 'shield_wave', name: 'üõ° BARRIER WAVE',
 desc: 'All arena units gain a shield for next wave (absorbs first 50% HP damage).',
 apply(){ G.activeEffects.push({ id:'shield_wave', waves:1 }); } },
 { id: 'regen_pulse', name: 'üíö REGEN PULSE',
 desc: 'All units heal 40% max HP. Bio synergy heals 80%.',
 apply(){ applyRegenPulse(); } },
 { id: 'overclock', name: '‚öô OVERCLOCK',
 desc: 'Attack speed +50% for next 2 waves.',
 apply(){ G.activeEffects.push({ id:'overclock', waves:2, speedMult:1.5 }); } },
 { id: 'toxic_field', name: '‚ò† TOXIC FIELD',
 desc: 'All enemies take 5 DOT/s for next 2 waves.',
 apply(){ G.activeEffects.push({ id:'toxic_field', waves:2, dotPerSec:5 }); } },
];
function applyEliteEvent() {
 const occupied = grid.map((c,i)=>c?i:-1).filter(i=>i>=0);
 if (occupied.length < 2) { showNotif(t('needElite'), 'var(--pink)'); return; }
 const removeIdx = occupied[0];
 const eliteIdx = occupied[Math.floor(Math.random() * (occupied.length-1)) + 1];
 grid[removeIdx] = null;
 grid[eliteIdx].elite = true;
 showNotif(t('eliteCreated'), 'var(--yellow)');
 addLog(t('logElite', tUnit(grid[eliteIdx].tier)), 'gold');
 renderGrid(); updateCurrencies();
}
function applyRegenPulse() {
 arenaUnits.forEach(u => {
 const healPct = G.synergyBonuses.BIO?.hasSpecial ? 0.8 : 0.4;
 u.hp = Math.min(u.maxHp, u.hp + u.maxHp * healPct);
 });
 showNotif(t('regenPulse'), 'var(--green)');
}
function tickActiveEffects() {
 G.activeEffects = G.activeEffects.filter(e => { e.waves--; return e.waves > 0; });
 renderActiveBuffs(); 
}
function getActiveEffect(id) {
 return G.activeEffects.find(e => e.id === id);
}
// Sta≈Çy rozmiar canvasa podczas walki ‚Äî zapisujemy wymiary na start wave
let _lockedW = 0, _lockedH = 0;
function resizeCanvas() {
 if (G.fighting) return; // anti-cheat: zablokuj podczas walki
 canvas.width = canvas.offsetWidth;
 canvas.height = canvas.offsetHeight;
}
function lockCanvasSize() {
 _lockedW = canvas.offsetWidth;
 _lockedH = canvas.offsetHeight;
 canvas.width = _lockedW;
 canvas.height = _lockedH;
}
function toggleWave() {
 initAudio();
 if (G.fighting) return;
 if (!grid.filter(Boolean).length) { showNotif(t('noUnits'), 'var(--pink)'); return; }
 if (G.activeRelic === 'fortress') {
 const validUnits = grid.slice(0, 12).filter(Boolean).length;
 if (validUnits === 0) {
 showNotif('üîí FORTRESS: Move blobs to left 3 columns!', 'var(--yellow)');
 return;
 }
 }
 const boss = isBossWave(G.wave);
 const nightmare = isNightmareWave(G.wave);
 const miniB = isMiniB(G.wave);
 window._waveStartGrid = grid.map(u => u ? { ...u } : null);
 G.fighting = true;
 G.waveTime = 0;
 G.waveStartedWithUnits = true;
 _arenaEventTimer = 0; _arenaEventCooldown = 0;
 resetMergeStreak();
 if (miniB) {
  const mb = MINI_BOSSES[G.wave % MINI_BOSSES.length];
  const hpScale = Math.pow(1.10, G.wave - 1);
  const mbEnemy = {
   x: canvas.width + 30, y: canvas.height / 2,
   hp: mb.hpMult * 100 * hpScale * (2 + G.prestige * 0.3),
   maxHp: mb.hpMult * 100 * hpScale * (2 + G.prestige * 0.3),
   speed: 0.55, reward: Math.floor(mb.reward * waveGoldReward(G.wave) * 0.4),
   color: mb.color, size: mb.size, resist: [], weakTo: mb.weakTo, weakMult: 1.6,
   isBoss: false, isMiniB: true, bossName: mb.name,
   special: 'mini', name: mb.name,
  };
  setTimeout(() => { if (G.fighting) enemies.push(mbEnemy); showNotif('‚ö† MINI-BOSS: ' + mb.name, mb.color); }, 1500);
 }
 // waveMaxTime controls enemy spawn window only (not a timer limit anymore)
 G.waveMaxTime = (boss || nightmare) ? 999 : 999; // enemies spawn indefinitely until killed
 // Ca≈Çkowity limit mob√≥w na rundƒô (initial burst + reinforcements)
 const baseCount = G.wave <= 3 ? 3 + G.wave
  : G.wave <= 5 ? 5 + Math.floor(G.wave * 1.5)
  : Math.min(8 + Math.floor(G.wave * 2.8), 80);
 const reinforcements = (boss || nightmare)
  ? Math.floor(baseCount * 0.5)
  : Math.floor(baseCount * 0.8);
 G._waveEnemyLimit = reinforcements;
 G._waveEnemyTotal = baseCount + reinforcements; // ≈ÇƒÖczny bud≈ºet dla paska postƒôpu
 G._waveKilled = 0;
 G._waveSpawned = 0;
 G._emptyEnemiesAt = 0;
 bossPhase = boss || nightmare;
 bossRef = null;
 G.bossSpawning = false;
 if (nightmare) activateNightmareDebuff();
 else clearNightmareDebuff();
 const btn = document.getElementById('btn-start');
 btn.className = 'btn-start ' + (boss ? 'boss-wave' : 'fighting');
 btn.textContent = boss ? t('btnBossFighting') : t('btnFighting');
 btn.disabled = true;
 lockCanvasSize();
 buildArenaUnits();
 enemies = [];
 if (nightmare && !boss) {
 const nb = document.createElement('div');
 nb.className = 'nightmare-banner';
 nb.innerHTML = t('nightmareBanner') + '<span>' + t('nightmareSubtitle') + '</span>';
 document.getElementById('panel-arena').appendChild(nb);
 setTimeout(() => nb.remove(), 3200);
 sfx.boss();
 ambientTransition('boss');
 G.bossSpawning = true;
 setTimeout(() => {
 resizeCanvas();
 spawnBossEnemy(G.wave);
 spawnMinionWave(G.wave, 18);
 spawnNormalWave(G.wave);
 spawnMeteors();
 G.bossSpawning = false;
 }, 900);
 addLog(t('logNightmare', G.wave), 'boss');
 } else if (boss) {
 const banner = document.createElement('div');
 banner.className = 'boss-banner';
 banner.textContent = t('bossWaveBanner');
 document.getElementById('panel-arena').appendChild(banner);
 setTimeout(() => banner.remove(), 2600);
 sfx.boss();
 ambientTransition('boss');
 G.bossSpawning = true; 
 setTimeout(() => {
 resizeCanvas();
 spawnBossEnemy(G.wave);
 spawnMinionWave(G.wave, 8);
 spawnMeteors(); 
 G.bossSpawning = false;
 }, 800);
 addLog(t('logBossWave', G.wave), 'boss');
 } else {
 spawnNormalWave(G.wave);
 setTimeout(spawnMeteors, 500); 
 sfx.waveStart();
 ambientTransition('battle');
 addLog(t('logWaveStart', G.wave), 'wave');
 }
 if (animFrame) cancelAnimationFrame(animFrame);
 lastTime = 0;
 cacheArenaDom();
 animFrame = requestAnimationFrame(arenaLoop);
}
function spawnMeteors() {
 const effect = getActiveEffect('meteor');
 if (!effect || enemies.length === 0) return;
 const count = effect.count || 5;
 let hit = 0;
 const targets = [...enemies].sort(() => Math.random()-0.5).slice(0, count);
 targets.forEach((e, i) => {
 setTimeout(() => {
 if (!e || e.hp <= 0) return;
 const dmg = 500 + G.wave * 50;
 e.hp -= dmg;
 spawnBossDeathExplosion(e.x, e.y - 20, '#fb923c');
 addFloatDmg(`‚òÑ${formatNum(dmg)}`, e.x, e.y, '#fb923c', true);
 if (e.hp <= 0) onEnemyKill(e, null);
 }, i * 300);
 });
 addLog(t('logMeteor', count), 'boss');
}
function spawnNormalWave(wave) {
 const count = wave <= 3
 ? 4 + wave
 : wave <= 5
 ? 7 + Math.floor(wave * 2)
 : Math.min(12 + Math.floor(wave * 3.5), 120);
 const w = canvas.width, h = canvas.height;
 for (let i = 0; i < count; i++) {
 const typeIdx = getEnemyTypeForWave(wave);
 const et = ENEMY_TYPES[typeIdx];
 const hpScale = Math.pow(1.10, wave - 1); // by≈Ço 1.065 ‚Äî teraz mocniejszy scaling
 const side = Math.random() < 0.5 ? -20 : w + 20;
 const y = 20 + Math.random() * (h - 40);
 enemies.push(makeEnemy(side, y, et, hpScale));
 }
}
function spawnBossEnemy(wave) {
 const boss = getBossForWave(wave);
 const cycle = Math.floor((Math.floor(wave / 10) - 1) / BOSS_TYPES.length); // ile razy przeszli≈õmy przez cykl
 const cycleBonus = 1 + cycle * 1.2; // ka≈ºdy cykl +120% HP (by≈Ço 80%)
 const hpScale = (1 + wave * 0.14) * (1 + G.prestige * 0.30) * cycleBonus; // by≈Ço 0.08
 const w = canvas.width || 600;
 const h = canvas.height || 400;
 const e = {
 x: w - boss.size - 20, 
 y: h / 2,
 hp: boss.hp * hpScale,
 maxHp: boss.hp * hpScale,
 speed: boss.speed * 2.5,
 reward: Math.floor(boss.reward * (1 + G.prestige * 0.5)),
 color: boss.color,
 color2: boss.color2,
 size: boss.size,
 vx: -boss.speed,
 vy: 0,
 stun: 0,
 isBoss: true,
 bossName: boss.name,
 };
 enemies.push(e);
 bossRef = e;
 addLog(` ‚ò† ${boss.name} appears! HP: ${formatNum(e.hp)}`, 'boss');
 const pill = document.getElementById('pill-kills');
 pill.className = 'stat-pill boss-pill';
}
function spawnMinionWave(wave, count) {
 const w = canvas.width, h = canvas.height;
 for (let i = 0; i < count; i++) {
 const typeIdx = getEnemyTypeForWave(wave - 1);
 const et = ENEMY_TYPES[typeIdx];
 const side = Math.random() < 0.5 ? -20 : w + 20;
 const y = 15 + Math.random() * (h - 30);
 enemies.push(makeEnemy(side, y, et, Math.pow(1.10, wave - 1)));
 }
}
function makeEnemy(x, y, et, hpScale) {
 const spd = et.speed * 3.0; 
 return {
 x, y,
 hp: et.hp * hpScale,
 maxHp: et.hp * hpScale,
 speed: spd,
 reward: et.reward,
 color: et.color,
 size: et.size,
 name: et.name,
 vx: x < 0 ? spd : -spd,
 vy: 0,
 stun: 0,
 isBoss: false,
 };
}
function buildArenaUnits() {
 arenaUnits = [];
 calcSynergies();
 const active = grid.map((u, i) => u ? { ...u, gridIdx: i } : null).filter(Boolean);
 const useActive = active.filter(u => G.activeRelic === 'fortress' ? u.gridIdx < 12 : isSlotPlayable(u.gridIdx));
 const w = canvas.width || 600, h = canvas.height || 400;

 // ‚îÄ‚îÄ Formation layout based on grid row ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 // Grid row  0 = FRONT  (idx 0-3)
 // Grid rows 1-2 = MID  (idx 4-11)
 // Grid row  3 = BACK   (idx 12-15)
 // Grid row  4 = SUPPORT(idx 16-19)
 //
 // Arena X layout (left=enemy side, right=back):
 //  FRONT   ‚Üí x = 15‚Äì22% of width  (closest to enemy)
 //  MID A   ‚Üí x = 28‚Äì35%
 //  MID B   ‚Üí x = 36‚Äì43%
 //  BACK    ‚Üí x = 50‚Äì58%  (ranged, holds distance)
 //  SUPPORT ‚Üí x = 66‚Äì72%  (stays put, passive aura)

 const FORMATION = {
  0: { label:'FRONT',   xBand:[0.10,0.16], color:'#ff453a', moveStyle:'aggressive', attackRange:70,  moveSpeed:28, stayBack:false },
  1: { label:'MID A',   xBand:[0.20,0.26], color:'#5ac8fa', moveStyle:'normal',     attackRange:80,  moveSpeed:22, stayBack:false },
  2: { label:'MID B',   xBand:[0.28,0.34], color:'#5ac8fa', moveStyle:'normal',     attackRange:80,  moveSpeed:22, stayBack:false },
  3: { label:'BACK',    xBand:[0.38,0.44], color:'#bf5af2', moveStyle:'ranged',     attackRange:130, moveSpeed:10, stayBack:true  },
  4: { label:'SUPPORT', xBand:[0.50,0.56], color:'#4cd964', moveStyle:'support',    attackRange:100, moveSpeed:0,  stayBack:true  },
 };

 // Group by formation row (grid row = Math.floor(gridIdx / 4))
 const byRow = { 0:[], 1:[], 2:[], 3:[], 4:[] };
 useActive.forEach(u => {
  const row = Math.min(4, Math.floor(u.gridIdx / 4));
  byRow[row].push(u);
 });

 // Place each group in its x-band, distributed vertically
 Object.entries(byRow).forEach(([rowIdxStr, group]) => {
  if (group.length === 0) return;
  const rowIdx = parseInt(rowIdxStr);
  const fm = FORMATION[rowIdx];
  const xMin = fm.xBand[0] * w, xMax = fm.xBand[1] * w;
  const xBase = (xMin + xMax) / 2;
  const margin = h * 0.12;
  const spread = h - margin * 2;
  const step = spread / (group.length + 1);

  group.forEach((u, slotI) => {
   const ut = UNIT_TYPES[u.tier];
   const synMult = getSynergyMultForUnit(u.tier);
   const adjMult = getAdjacencyMult(u.gridIdx);
   const eliteMult = u.elite ? (G.activeRelic === 'catalyst' ? 3.0 : 2.0) : 1;
   const overclock = getActiveEffect('overclock');
   const speedMult = overclock ? overclock.speedMult : 1;
   const relicHpMult = G.activeRelic === 'fortress' ? 1.8
    : G.activeRelic === 'berserker' ? 0.75 : 1;
   const bioHpMult  = 1 + (G.bioHP  || 0);
   const bioDpsMult = 1 + (G.bioDPS || 0);
   const baseHp = getUnitHP(u.tier, ut?.role || 'support', u.gridIdx);
   const hp = Math.floor(baseHp * relicHpMult * (u.elite ? 1.5 : 1) * bioHpMult);

   // Slight random x jitter within band
   const xJitter = (Math.random() - 0.5) * (xMax - xMin) * 0.6;

   arenaUnits.push({
    x: xBase + xJitter,
    y: margin + step * (slotI + 1),
    // Formation home position (units try to return here when no enemies)
    homeX: xBase + xJitter,
    homeY: margin + step * (slotI + 1),
    formationRow: rowIdx,
    formationLabel: fm.label,
    formationColor: fm.color,
    formationMoveStyle: fm.moveStyle,
    formationAttackRange: fm.attackRange,
    formationMoveSpeed: fm.moveSpeed,
    formationStayBack: fm.stayBack,
    // Initial attack timing ‚Äî FRONT attacks first
    attackTimer: rowIdx * 0.25 + Math.random() * 0.4,
    tier: u.tier,
    mutant: u.mutant,
    elite: u.elite || false,
    special: u.special || null,
    role: ut?.role || 'support',
    tags: ut?.tags || [],
    dps: Math.floor(getUnitDPS(u.tier, u.mutant, synMult * adjMult * eliteMult, u.gridIdx) * bioDpsMult),
    attackSpeed: (ut?.speed || 1.0) * speedMult,
    hp,
    maxHp: hp,
    size: 14 + u.tier * 2.5,
    attackFlash: 0,
    attackBounce: 0,
    shield: getActiveEffect('shield_wave') ? hp * 0.5 : 0,
    leechHeal: ut?.role === 'leech' ? 0.15 : 0,
    gridIdx: u.gridIdx,
   });
  });
 });
}
let lastTime = 0;
let _domTimer, _domKillCounter, _domEnemyCount, _domDPS;
function cacheArenaDom() {
 _domTimer = document.getElementById('wave-timer');
 _domKillCounter = document.getElementById('kill-counter');
 _domEnemyCount = document.getElementById('enemy-count');
 _domDPS = document.getElementById('live-dps-val');
}
let _lastEnemyCountUpdate = 0;
function arenaLoop(ts = 0) {
 const rawDt = Math.min((ts - lastTime) / 1000, 0.05);
 lastTime = ts;
 if (!G.fighting) return;
 const dt = rawDt * gameSpeed;
 _lastDt = dt;
 G.waveTime += dt;

 // Timer ‚Äî pokazuje czas prze≈ºycia
 if (_domTimer) {
  const secs = Math.floor(G.waveTime);
  const mins = Math.floor(secs / 60);
  _domTimer.textContent = mins > 0 ? `${mins}:${String(secs % 60).padStart(2,'0')}` : `${secs}s`;
  _domTimer.className = 'wave-timer';
 }

 // Kill counter ‚Äî ‚ò† 14 / 47
 if (_domKillCounter) {
  const killed = G._waveKilled || 0;
  const total = G._waveEnemyTotal || 0;
  const pct = total > 0 ? killed / total : 0;
  const color = pct >= 0.75 ? '#4cd964' : pct >= 0.4 ? '#ffd60a' : 'rgba(255,255,255,0.35)';
  _domKillCounter.textContent = `‚ò† ${killed} / ${total}`;
  _domKillCounter.style.color = color;
  _domKillCounter.style.borderColor = pct >= 0.75 ? 'rgba(76,217,100,0.3)' : 'rgba(255,255,255,0.08)';
 }

 if (_domEnemyCount && ts - _lastEnemyCountUpdate > 100) {
  _domEnemyCount.textContent = t('enemies', enemies.length);
  _lastEnemyCountUpdate = ts;
 }

 updateArena(dt, rawDt);
 drawArena();

 if (_domDPS && ts - _lastEnemyCountUpdate < 50) {
  _domDPS.textContent = formatNum(arenaUnits.reduce((s, u) => s + u.dps, 0));
 }

 // ‚îÄ‚îÄ PRZEGRANA: wszystkie nasze jednostki zginƒô≈Çy ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (arenaUnits.length === 0 && G.waveTime > 2.0 && !G.bossSpawning) {
  endWave(false);
  triggerLoseScreen();
  return;
 }

 // ‚îÄ‚îÄ WYGRANA: wszyscy wrogowie zabici i spawn sko≈Ñczony ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (enemies.length === 0 && !G.bossSpawning && G.waveTime > 1.0) {
  // Poczekaj 0.8s realnego czasu ≈ºeby nowi wrogowie zdƒÖ≈ºyli wej≈õƒá
  if (!G._emptyEnemiesAt) {
   G._emptyEnemiesAt = ts;
  } else if (ts - G._emptyEnemiesAt > 800) {
   endWave(true);
   return;
  }
 } else {
  G._emptyEnemiesAt = 0;
 }

 animFrame = requestAnimationFrame(arenaLoop);
}
function updateArena(dt, rawDt = 0.016) {
 const w = canvas.width, h = canvas.height;
 const magnetUnit = arenaUnits.find(u => u.tier === 4);
 if (enemies.some(e => e.hp <= 0)) {
 enemies = enemies.filter(e => e.hp > 0);
 }
 if (particles.length > 150) particles.splice(0, particles.length - 150);
 const enemyTargetCache = new Map();
 if (arenaUnits.length > 0) {
 enemies.forEach(e => {
 if (e.hp <= 0 || e.stun > 0) return;
 // Taunt override ‚Äî bruiser forces enemy to attack them
 if (e._taunted && e._tauntTarget && e._tauntTarget.hp > 0) {
  const d = Math.hypot(e._tauntTarget.x - e.x, e._tauntTarget.y - e.y);
  enemyTargetCache.set(e, { unit: e._tauntTarget, dist: d });
  return;
 }
 let nearest = null, minDist = Infinity;
 for (let i = 0; i < arenaUnits.length; i++) {
 const u = arenaUnits[i];
 const d = Math.hypot(u.x - e.x, u.y - e.y);
 if (d < minDist) { minDist = d; nearest = u; }
 }
 enemyTargetCache.set(e, { unit: nearest, dist: minDist });
 });
 }
 const unitTargetCache = new Map();
 if (enemies.length > 0) {
 arenaUnits.forEach(u => {
 if (u.role === 'sniper') {
 let maxDist = -1, target = null;
 for (let i = 0; i < enemies.length; i++) {
 const d = Math.hypot(enemies[i].x-u.x, enemies[i].y-u.y);
 if (d > maxDist) { maxDist = d; target = enemies[i]; }
 }
 unitTargetCache.set(u, { enemy: target, dist: maxDist });
 } else {
 let minDist = Infinity, target = null;
 for (let i = 0; i < enemies.length; i++) {
 const d = Math.hypot(enemies[i].x-u.x, enemies[i].y-u.y);
 if (d < minDist) { minDist = d; target = enemies[i]; }
 }
 unitTargetCache.set(u, { enemy: target, dist: minDist });
 }
 });
 }
 // Spawn kolejnych wrog√≥w dop√≥ki nie osiƒÖgniƒôto limitu rundy
 // Nie spawnuj je≈õli jest ju≈º du≈ºo na ekranie (cap na jednoczesnƒÖ liczbƒô)
 const maxOnScreen = Math.min(15 + Math.floor(G.wave * 0.8), 40);
 if (!bossPhase && G._waveSpawned < G._waveEnemyLimit && enemies.length < maxOnScreen) {
  const rate = 0.5 + G.upgrades.spawn_rate * 0.15 + G.researchBonuses.spawn_rate_res * 0.12;
  if (Math.random() < rawDt * rate) {  // rawDt ‚Äî niezale≈ºne od gameSpeed!
   const et = ENEMY_TYPES[getEnemyTypeForWave(G.wave)];
   const side = Math.random() < 0.5 ? -20 : w + 20;
   const y = 20 + Math.random() * (h - 40);
   enemies.push(makeEnemy(side, y, et, Math.pow(1.10, G.wave - 1)));
   G._waveSpawned++;
  }
 }
 if (bossPhase && G._waveSpawned < G._waveEnemyLimit && enemies.length < maxOnScreen) {
  if (Math.random() < rawDt * 0.3) {  // rawDt ‚Äî niezale≈ºne od gameSpeed!
   const et = ENEMY_TYPES[0];
   const side = Math.random() < 0.5 ? -20 : w + 20;
   const y = 20 + Math.random() * (h - 40);
   enemies.push(makeEnemy(side, y, et, Math.pow(1.10, G.wave - 1) * 0.6));
   G._waveSpawned++;
  }
 }
 const _nightmareEnemyMult = nightmareActive ? 2.0 : 1.0;
 enemies.forEach(e => {
 if (e.stun > 0) { e.stun -= dt; return; }
 if (e.hp <= 0) return;
 const cached = enemyTargetCache.get(e);
 if (!cached || !cached.unit) return;
 const nearest = cached.unit, minDist = cached.dist;
 if (magnetUnit && !e.isBoss && Math.random() < 0.008) {
 const dx = magnetUnit.x - e.x, dy = magnetUnit.y - e.y, len = Math.hypot(dx, dy) || 1;
 e.x += (dx / len) * e.speed * 4;
 e.y += (dy / len) * e.speed * 4;
 } else {
 const dx = nearest.x - e.x, dy = nearest.y - e.y, len = Math.hypot(dx, dy) || 1;
 e.x += (dx / len) * e.speed * 60 * dt;
 e.y += (dy / len) * e.speed * 60 * dt;
 }
 if (minDist < nearest.size + e.size - 2) {
 const nightmareEnemyMult = _nightmareEnemyMult;
 const _wv = G.wave;
 const baseEnemyDmg = _wv <= 50
   ? 3.5 * Math.pow(1.10, _wv - 1)
   : 76.6 * Math.pow(1.03, _wv - 50);
 const dmgToUnit = (e.isBoss ? baseEnemyDmg * 4.5 : baseEnemyDmg) * dt * nightmareEnemyMult;
 nearest.hp -= dmgToUnit;
 if (nearest.hp <= 0 && !nearest._dead) {
 if (_godMode) { nearest.hp = nearest.maxHp; }
 else {
 nearest._dead = true;
 const _didx = arenaUnits.indexOf(nearest);
 if (_didx !== -1) {
 arenaUnits.splice(_didx, 1);
 addLog(t('logUnitFell', tUnit(nearest.tier) + ' T' + nearest.tier), 'dmg');
 spawnKillParticle(nearest.x, nearest.y, '#888');
 }
 }
 }
 }
 });

 // ‚îÄ‚îÄ SEPARACJA: enemy nie wchodzi w inne enemy ani w slima ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const eLen = enemies.length;
 for (let i = 0; i < eLen; i++) {
  const a = enemies[i]; if (a.hp <= 0) continue;
  // enemy vs enemy
  for (let j = i+1; j < eLen; j++) {
   const b = enemies[j]; if (b.hp <= 0) continue;
   const ex=a.x-b.x, ey=a.y-b.y, d=Math.hypot(ex,ey)||0.01;
   const minD=a.size+b.size;
   if (d < minD) { const ov=(minD-d)*0.5, nx=ex/d, ny=ey/d; a.x+=nx*ov; a.y+=ny*ov; b.x-=nx*ov; b.y-=ny*ov; }
  }
  // enemy vs slime (zatrzymaj przy powierzchni)
  for (let k=0; k<arenaUnits.length; k++) {
   const u=arenaUnits[k];
   const ux=a.x-u.x, uy=a.y-u.y, ud=Math.hypot(ux,uy)||0.01;
   const uR=16+u.tier*3;
   const minU=a.size+uR*0.85;
   if (ud < minU) { const ov=minU-ud, nx=ux/ud, ny=uy/ud; a.x+=nx*ov*0.8; a.y+=ny*ov*0.8; }
  }
 }

 // ‚îÄ‚îÄ FOLLOW MOUSE ‚Äî slimi dƒÖ≈ºƒÖ do kursora ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 // Arena events
 if (G.fighting) tickArenaEvents(dt);
 if (_followMouse && !_dragUnit && (G.fighting || arenaUnits.length > 0)) {
  arenaUnits.forEach(u => {
   const dx = _mouseCanvasX - u.x, dy = _mouseCanvasY - u.y;
   const dist = Math.hypot(dx, dy) || 1;
   if (dist > 8) {
    const spd = Math.min(dist * 0.12, 5); // p≈Çynny ruch, max 5px/frame
    u.x += (dx / dist) * spd;
    u.y += (dy / dist) * spd;
   }
  });
 }

 arenaUnits.forEach(u => {
 if (enemies.length === 0) {
  // No enemies ‚Äî drift back to home position
  if (u.homeX !== undefined) {
   const dx = u.homeX - u.x, dy = u.homeY - u.y;
   const d = Math.hypot(dx, dy) || 1;
   if (d > 4) { u.x += (dx/d)*8*dt; u.y += (dy/d)*8*dt; }
  }
  return;
 }
 const cached = unitTargetCache.get(u);
 if (!cached || !cached.enemy) return;
 const target = cached.enemy, cachedDist = cached.dist;
 const style = u.formationMoveStyle || 'normal';
 const range = u.formationAttackRange || (u.role==='sniper' ? 180 : u.role==='leech' ? 120 : u.tier>=5 ? 140 : 90);
 const spd   = (u.formationMoveSpeed !== undefined ? u.formationMoveSpeed : 20) * dt;

 if (style === 'support') {
  // SUPPORT: never moves toward enemy, stays near home, provides passive aura
  if (u.homeX !== undefined) {
   const dx = u.homeX - u.x, dy = u.homeY - u.y;
   const d = Math.hypot(dx,dy)||1;
   if (d > 8) { u.x += (dx/d)*10*dt; u.y += (dy/d)*10*dt; }
  }
  // Support aura: nearby allies get regen
  if (Math.random() < dt * 0.3) {
   arenaUnits.forEach(ally => {
    if (ally === u) return;
    const ad = Math.hypot(ally.x-u.x, ally.y-u.y);
    if (ad < 120) {
     ally.hp = Math.min(ally.maxHp, ally.hp + ally.maxHp * 0.008);
     if (Math.random() < 0.15) particles.push({
      x: ally.x + (Math.random()-0.5)*10,
      y: ally.y + (Math.random()-0.5)*10,
      vx: 0, vy: -0.8, life: 0.5, color:'#4cd964', size:3, noGravity:true
     });
    }
   });
  }
  return;
 }

 if (style === 'ranged') {
  // BACK row: maintains attack range, retreats if enemy gets too close
  if (cachedDist < range * 0.55) {
   // Retreat away from enemy
   const dx = u.x - target.x, dy = u.y - target.y;
   const len = Math.hypot(dx,dy)||1;
   u.x += (dx/len)*18*dt;
   u.y += (dy/len)*18*dt;
  } else if (cachedDist > range * 0.85) {
   // Move closer to get in range
   const dx = target.x-u.x, dy = target.y-u.y, len = Math.hypot(dx,dy)||1;
   u.x += (dx/len)*spd; u.y += (dy/len)*spd;
  }
  // Stay in back half of arena
  const minX = canvas.width * 0.38;
  if (u.x < minX) u.x += (minX - u.x) * 0.08;
 } else if (style === 'aggressive') {
  // FRONT: charges enemies, first to engage
  if (cachedDist > range * 0.5) {
   const dx = target.x-u.x, dy = target.y-u.y, len = Math.hypot(dx,dy)||1;
   u.x += (dx/len)*spd; u.y += (dy/len)*spd;
   if (Math.random() < 0.08) {
    particles.push({ x:u.x, y:u.y, vx:(Math.random()-0.5)*0.5, vy:(Math.random()-0.5)*0.5,
     life:0.2, color:'#ff453a', size:2+u.tier*0.3, noGravity:true });
   }
  }
 } else {
  // MID: standard movement
  const isTankStuck = u.role === 'tank' && cachedDist > 120;
  if (!isTankStuck && cachedDist > range * 0.65) {
   const dx = target.x-u.x, dy = target.y-u.y, len = Math.hypot(dx,dy)||1;
   u.x += (dx/len)*spd; u.y += (dy/len)*spd;
   if (Math.random() < 0.08) {
    const c = ['','#4ade80','#60a5fa','#f472b6','#fb923c','#e879f9','#fff'][Math.min(u.tier,6)];
    particles.push({ x:u.x, y:u.y, vx:(Math.random()-0.5)*0.5, vy:(Math.random()-0.5)*0.5,
     life:0.2, color:c, size:2+u.tier*0.3, noGravity:true });
   }
  }
 }
 const margin = u.size||16;
 u.x = Math.max(margin, Math.min(canvas.width-margin, u.x));
 u.y = Math.max(margin, Math.min(canvas.height-margin, u.y));
 });
 const toxicField = getActiveEffect('toxic_field');
 if (toxicField) {
 enemies.forEach(e => {
 if (e.resist?.includes('dot')) return;
 e.hp -= toxicField.dotPerSec * dt;
 });
 }
 if (G.synergyBonuses.BIO?.hasSpecial) {
 arenaUnits.forEach(u => { u.hp = Math.min(u.maxHp, u.hp + 4 * dt); });
 }
 const critAura = getActiveEffect('crit_aura');
 const baseCritChance = 0.10 + (critAura ? critAura.critBonus : 0);
 const overclock = getActiveEffect('overclock');
 const _nightmareDpsMult = nightmareActive ? 0.60 : 1.0;
 arenaUnits.forEach(u => {
 u.attackTimer -= dt;
 if (u.attackTimer > 0) return;
 if (u.formationRow === 4) { u.attackTimer = 1; return; } // SUPPORT row nie atakuje
 const attackSpd = (u.attackSpeed || UNIT_TYPES[u.tier].speed) * (overclock ? overclock.speedMult : 1);
 u.attackTimer = 1 / attackSpd;
 const isAoE = u.tier === 5 || u.role === 'leech';
 const isGlitch = u.tier >= 6;
 const isSniper = u.role === 'sniper';
 const range = u.formationAttackRange || (isGlitch ? 180 : isAoE ? 140 : isSniper ? 200 : 90);
 const dmgPerHit = (u.dps / attackSpd) * _nightmareDpsMult;
 const critRoll = Math.random();
 const isCrit = critRoll < baseCritChance;
 let finalDmg = isCrit ? dmgPerHit * 2.5 : dmgPerHit;
 if (G.synergyBonuses.MECH?.hasSpecial) finalDmg *= 1.15;
 u.attackFlash = 0.3;
 u.attackBounce = 0.25;
 let attacked = false;
 enemies.forEach(e => {
 if (e.special === 'anti_support' && e.hp > 0) {
 const suppTarget = arenaUnits.find(u => u.role === 'support');
 if (suppTarget) {
 const d = Math.hypot(suppTarget.x-e.x, suppTarget.y-e.y);
 if (d < e.size + suppTarget.size + 10) {
 suppTarget.hp -= 15 * dt;
 }
 }
 }
 });
 enemies = enemies.filter(e => {
 if (e.hp <= 0) return false;
 const dist = Math.hypot(e.x - u.x, e.y - u.y);
 if (dist > range) return true;
 if (!isAoE && !isGlitch && attacked) return true;
 let dmg = finalDmg;
 if (isCrit && e.resist?.includes('crit')) dmg = dmgPerHit; 
 if (e.special === 'shield' && e.shieldHp > 0) {
 e.shieldHp -= dmg;
 if (e.shieldHp < 0) { dmg = -e.shieldHp; e.shieldHp = 0; } else dmg = 0;
 spawnAoERing(e.x, e.y, e.size + 8, '#3b82f6');
 }
 e.hp -= dmg;
 attacked = true;
 const pColor = ['','#4ade80','#60a5fa','#f472b6','#fb923c','#e879f9','#fff'][u.tier];
 if (!isAoE) spawnBullet(u.x, u.y, e.x, e.y, isCrit ? '#fff' : pColor);
 if (G.synergyBonuses.FIRE?.hasSpecial && !e.burning && !e.resist?.includes('dot')) {
 e.burning = 3.0; 
 e.burnDmg = dmg * 0.15;
 }
 // Weakness multiplier
 const attackerTags = UNIT_TYPES[u.tier]?.tags || [];
 if (e.weakTo && attackerTags.includes(e.weakTo) && e.weakMult) {
  dmg *= e.weakMult;
  if (!e._weakHit) {
   e._weakHit = true;
   addFloatDmg('WEAK!', e.x, e.y - 20, '#fff700', false);
   setTimeout(() => { if (e) e._weakHit = false; }, 800);
  }
 }
 if (isCrit && !e.resist?.includes('crit') && Math.floor(dmg) > 0) {
 spawnCritNumber(Math.floor(dmg), e.x, e.y, pColor);
 sfx.crit && sfx.crit();
 } else if (Math.floor(dmg) >= 1) {
 if (e.isBoss || floatingDmg.length < 12 || Math.random() < 0.35) {
  addFloatDmg(Math.floor(dmg), e.x, e.y, isGlitch ? '#fff' : pColor, e.isBoss);
 }
 }
 if (u.leechHeal > 0 && dmg > 0) {
 u.hp = Math.min(u.maxHp, u.hp + dmg * u.leechHeal);
 }
 // Passive abilities
 if (dmg > 0 && Math.random() < 0.08) applyUnitPassive(u, e, dmg);
 if (e.hp <= 0) { onEnemyKill(e, u); return false; }
 return true;
 });
 enemies.forEach(e => {
 if (e.burning > 0) {
 e.hp -= e.burnDmg * dt;
 e.burning -= dt;
 if (Math.random() < 0.1) particles.push({
 x: e.x + (Math.random()-0.5)*e.size, y: e.y,
 vx: (Math.random()-0.5)*1.5, vy: -1.5, life: 0.4,
 color: '#fb923c', size: 3, noGravity: false });
 }
 });
 if (isAoE) spawnAoERing(u.x, u.y, 35 + u.tier * 3, u.tier===5 ? '#e879f9' : '#4ade80');
 if (isGlitch && Math.random() < 0.3) {
 for (let k = 0; k < 4; k++) {
 const angle = Math.random() * Math.PI * 2;
 spawnBullet(u.x, u.y, u.x + Math.cos(angle)*range*0.8, u.y + Math.sin(angle)*range*0.8, '#fff');
 }
 }
 });
 for (let i = particles.length - 1; i >= 0; i--) {
 const p = particles[i];
 p.x += p.vx; p.y += p.vy;
 p.life -= dt;
 p.vy += (p.noGravity ? 0 : 28) * dt;
 if (p.life <= 0) particles.splice(i, 1);
 }
 for (let i = floatingDmg.length - 1; i >= 0; i--) {
 const f = floatingDmg[i];
 f.y -= 32 * dt; f.life -= dt;
 if (f.life <= 0) floatingDmg.splice(i, 1);
 }
 updateFood(dt);
}

// Notyfikacje jedzenia na canvasie areny (centrum)
let _foodNotifs = []; // {emoji, label, color, life, x, y, scale}

function showFoodNotif(emoji, label, color, fx, fy) {
 // Animowana notyfikacja startujƒÖca z miejsca jedzenia i lecƒÖca do g√≥ry
 _foodNotifs.push({
  emoji, label, color,
  x: fx, y: fy,
  life: 1.8, maxLife: 1.8,
  vy: -90, // px/s w g√≥rƒô
  scale: 0,
 });
}

function drawFoodNotifs(dt) {
 for (let i = _foodNotifs.length - 1; i >= 0; i--) {
  const n = _foodNotifs[i];
  n.life -= dt;
  n.y += n.vy * dt;
  n.vy *= 0.92; // spowalniaj
  // scale: pop in ‚Üí full ‚Üí fade
  const prog = 1 - n.life / n.maxLife;
  n.scale = prog < 0.15 ? prog / 0.15 : n.life > 0.4 ? 1 : n.life / 0.4;
  if (n.life <= 0) { _foodNotifs.splice(i, 1); continue; }
  const alpha = n.life > 0.4 ? 1 : n.life / 0.4;
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.translate(n.x, n.y);
  ctx.scale(n.scale, n.scale);
  // Glow background pill
  const pw = 110, ph = 36;
  ctx.shadowColor = n.color;
  ctx.shadowBlur = 20;
  ctx.fillStyle = 'rgba(10,5,30,0.88)';
  ctx.beginPath(); ctx.roundRect(-pw/2, -ph/2, pw, ph, ph/2); ctx.fill();
  ctx.strokeStyle = n.color;
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(-pw/2, -ph/2, pw, ph, ph/2); ctx.stroke();
  ctx.shadowBlur = 0;
  // Emoji
  ctx.font = '18px serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText(n.emoji, -pw/2 + 18, 0);
  // Label
  ctx.font = "bold 13px 'Fredoka One', sans-serif";
  ctx.fillStyle = n.color;
  ctx.shadowColor = n.color; ctx.shadowBlur = 8;
  ctx.fillText(n.label, pw/2 - 44, 0);
  ctx.shadowBlur = 0;
  ctx.restore();
 }
}


const FOOD_TYPES=[
 {id:"apple",emoji:"üçé",label:"+15% DPS",color:"#ff4444",dur:12,apply(){G._fDPS=(G._fDPS||0)+0.15;}},
 {id:"banana",emoji:"üçå",label:"+20% Speed",color:"#ffd700",dur:10,apply(){G._fSpd=(G._fSpd||0)+0.20;}},
 {id:"mush",emoji:"üçÑ",label:"+10% MaxHP",color:"#e879f9",dur:0,apply(){arenaUnits.forEach(u=>{const b=Math.floor(u.maxHp*.1);u.maxHp+=b;u.hp=Math.min(u.maxHp,u.hp+b);});}},
 {id:"star",emoji:"‚≠ê",label:"+30 Gold",color:"#fbbf24",dur:0,apply(){G.gold+=30;updateCurrencies();}},
 {id:"shield",emoji:"üõ°",label:"Shield 8s",color:"#60a5fa",dur:8,apply(){arenaUnits.forEach(u=>{u.shield=(u.shield||0)+u.maxHp*.3;});}},
 {id:"bolt",emoji:"‚ö°",label:"+30% AtkSpd",color:"#facc15",dur:12,apply(){G._fAtk=(G._fAtk||0)+0.30;}},
 {id:"heart",emoji:"‚ù§",label:"Heal 30%",color:"#f87171",dur:0,apply(){arenaUnits.forEach(u=>{u.hp=Math.min(u.maxHp,u.hp+u.maxHp*.3);});}},
 {id:"gem",emoji:"üíé",label:"+10 Bio",color:"#34d399",dur:0,apply(){G.biomass+=10;updateCurrencies();}},
];
function spawnFood(){
 if(foodItems.length>=4)return;
 const w=canvas.width,h=canvas.height,m=50,ft=FOOD_TYPES[Math.floor(Math.random()*FOOD_TYPES.length)],s=Math.floor(Math.random()*4);
 let x,y;
 if(s===0){x=m+Math.random()*(w-m*2);y=m+Math.random()*(h*.3);}
 else if(s===1){x=m+Math.random()*(w-m*2);y=h*.65+Math.random()*(h*.35-m);}
 else if(s===2){x=m+Math.random()*(w*.28);y=m+Math.random()*(h-m*2);}
 else{x=w*.72+Math.random()*(w*.28-m);y=m+Math.random()*(h-m*2);}
 foodItems.push({x,y,type:ft,life:16,pulse:Math.random()*6.28});
}
function updateFood(dt){
 if(!G.fighting)return;
 _foodSpawnTimer-=dt;
 if(_foodSpawnTimer<=0){_foodSpawnTimer=5+Math.random()*4;spawnFood();}
 for(let i=foodItems.length-1;i>=0;i--){
  const f=foodItems[i];f.life-=dt;f.pulse+=dt*2.8;
  if(f.life<=0){foodItems.splice(i,1);continue;}
  for(let k=0;k<arenaUnits.length;k++){
   if(Math.hypot(arenaUnits[k].x-f.x,arenaUnits[k].y-f.y)<30){
    f.type.apply();
    addLog("+ "+f.type.emoji+" "+f.type.label,"gold");
    showFoodNotif(f.type.emoji, f.type.label, f.type.color, f.x, f.y);
    sfx.foodPickup(f.type.color);
    // VFX: burst ring
    particles.push({x:f.x,y:f.y,vx:0,vy:0,life:0.5,color:f.type.color,size:32,isRing:true,radius:8});
    particles.push({x:f.x,y:f.y,vx:0,vy:0,life:0.35,color:'#ffffff',size:20,isRing:true,radius:4});
    // VFX: burst particles
    for(let p=0;p<20;p++){const a=Math.PI*2/20*p,sp=3+Math.random()*5;
     particles.push({x:f.x,y:f.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-1.5,life:.8+Math.random()*.3,color:f.type.color,size:2.5+Math.random()*3});}
    // VFX: screen flash overlay
    _foodFlash = {color: f.type.color, life: 0.25};
    if(f.type.dur>0)_foodBuffs.push({id:f.type.id,emoji:f.type.emoji,label:f.type.label,color:f.type.color,timeLeft:f.type.dur,duration:f.type.dur});
    foodItems.splice(i,1);break;
   }
  }
 }
 for(let i=_foodBuffs.length-1;i>=0;i--){
  _foodBuffs[i].timeLeft-=dt;
  if(_foodBuffs[i].timeLeft<=0){
   const b=_foodBuffs[i];
   if(b.id==="apple")G._fDPS=Math.max(0,(G._fDPS||0)-.15);
   if(b.id==="banana")G._fSpd=Math.max(0,(G._fSpd||0)-.20);
   if(b.id==="bolt")G._fAtk=Math.max(0,(G._fAtk||0)-.30);
   if(b.id==="shield")arenaUnits.forEach(u=>{u.shield=0;});
   addLog("Buff expired: "+b.emoji,"dmg");
   _foodBuffs.splice(i,1);
  }
 }
}
function drawFood(){
 foodItems.forEach(f=>{
  const by2=Math.sin(f.pulse)*5,al=f.life<3?f.life/3:1,sc=.88+Math.sin(f.pulse*1.4)*.10;
  ctx.save();ctx.globalAlpha=al;ctx.translate(f.x,f.y+by2);ctx.scale(sc,sc);
  const gr=ctx.createRadialGradient(0,0,4,0,0,22);
  gr.addColorStop(0,f.type.color+"99");gr.addColorStop(1,"transparent");
  ctx.fillStyle=gr;ctx.beginPath();ctx.arc(0,0,22,0,Math.PI*2);ctx.fill();
  ctx.font="22px serif";ctx.textAlign="center";ctx.textBaseline="middle";
  ctx.shadowColor=f.type.color;ctx.shadowBlur=f.life<4?18:8;
  ctx.fillText(f.type.emoji,0,0);
  ctx.shadowBlur=0;ctx.font="bold 8px Fredoka One,sans-serif";
  ctx.fillStyle="#fff";ctx.fillText(f.type.label,0,17);
  ctx.restore();
 });
 _foodBuffs.forEach((b,i)=>{
  const bx=8,by=8+i*20,pct=b.timeLeft/b.duration;
  ctx.globalAlpha=.82;
  ctx.fillStyle="rgba(0,0,0,.6)";ctx.beginPath();ctx.roundRect(bx,by,96,16,5);ctx.fill();
  ctx.fillStyle=b.color+"77";ctx.beginPath();ctx.roundRect(bx,by,96*pct,16,5);ctx.fill();
  ctx.globalAlpha=1;ctx.font="bold 8px Fredoka One,sans-serif";
  ctx.fillStyle="#fff";ctx.textAlign="left";ctx.textBaseline="middle";
  ctx.fillText(b.emoji+" "+b.label+" "+Math.ceil(b.timeLeft)+"s",bx+4,by+8);
 });
}
function drawFoodFlash(dt) {
 if (!_foodFlash) return;
 _foodFlash.life -= dt;
 if (_foodFlash.life <= 0) { _foodFlash = null; return; }
 const alpha = (_foodFlash.life / 0.25) * 0.18;
 ctx.save();
 ctx.globalAlpha = alpha;
 ctx.fillStyle = _foodFlash.color;
 ctx.fillRect(0, 0, canvas.width, canvas.height);
 ctx.restore();
}

function clearFood(){foodItems=[];_foodBuffs=[];_foodSpawnTimer=3;G._fDPS=0;G._fSpd=0;G._fAtk=0;_foodFlash=null;_foodNotifs=[];}

function onEnemyKill(e, killer) {
 G.kills++;
 G._waveKilled = (G._waveKilled || 0) + 1;
 // Kill streak
 G.killStreak = (G.killStreak || 0) + 1;
 if (G.killStreak === 10) {
  showNotif('üî• 10 KILL STREAK! +20% DPS', '#fb923c');
  G.streakBonusActive = 10;
  arenaUnits.forEach(u => { u.dps = Math.floor(u.dps * 1.2); });
  checkDailyProgress('streak', G.killStreak, G.killStreak);
 } else if (G.killStreak === 25) {
  showNotif('‚ö° 25 KILL STREAK! +GOLD RUSH', '#facc15');
  G.streakBonusActive = 25;
  G.gold += waveGoldReward(G.wave); updateCurrencies();
 } else if (G.killStreak === 50) {
  showNotif('üí• 50 KILL STREAK! ALL UNITS OVERCHARGED!', '#e879f9');
  G.streakBonusActive = 50;
  arenaUnits.forEach(u => { u.dps = Math.floor(u.dps * 1.5); u.attackSpeed = (u.attackSpeed || 1) * 1.3; });
 }
 checkDailyProgress('kills', 1);
 const goldMult = G.activeRelic === 'economy' ? 2.0 : 1;
 const goldEarned = Math.floor(e.reward * (1 + G.wave * 0.04) * goldMult);
 G.gold += goldEarned;
 G.biomass += Math.max(0, Math.floor(e.reward * 0.03));
 sfx.kill();
 if (e.isBoss) {
 G.research += Math.floor(e.reward * 0.04);
 sfx.waveEnd(true);
 showNotif(t('bossSlain', formatNum(goldEarned)), 'var(--orange)');
 addLog(t('logBossKilled', e.bossName, formatNum(goldEarned)), 'boss');
 spawnBossDeathExplosion(e.x, e.y, e.color);
 document.getElementById('pill-kills').className = 'stat-pill';
 // Boss zabity ‚Äî zatrzymaj spawn minion√≥w
 bossPhase = false;
 bossRef = null;
 G._waveEnemyLimit = 0; // brak nowych wrog√≥w
 } else if (killer && Math.random() < 0.15) {
 addLog(flavour(unitFlavourKey(killer.tier)), 'dmg');
 }
 addFloatDmg(`+${goldEarned}g`, e.x, e.y - 15, '#ffbe0b', false);
 sfx.gold();
 spawnKillParticle(e.x, e.y, e.color);
 document.getElementById('pill-kills').textContent = t('kills', G.kills);
 if (killer && (killer.role === 'exploder' || G.activeRelic === 'volatile')) {
 if (Math.random() < 0.4) {
 spawnAoERing(e.x, e.y, 60, '#f472b6');
 const splashDmg = killer.dps * 0.5;
 enemies.forEach(nearby => {
 if (Math.hypot(nearby.x-e.x, nearby.y-e.y) < 60) nearby.hp -= splashDmg;
 });
 }
 }
 if (killer && killer.tier === 3 && Math.random() < 0.35) {
 const et = ENEMY_TYPES[0];
 enemies.push(makeEnemy(e.x + (Math.random()-0.5)*20, e.y + (Math.random()-0.5)*20, et, 0.5));
 }
 updateCurrencies();
}
let _bgCanvas = null, _bgCtx = null, _bgW = 0, _bgH = 0;
function buildBgCanvas(w, h) {
 _bgCanvas = document.createElement('canvas');
 _bgCanvas.width = w; _bgCanvas.height = h;
 _bgCtx = _bgCanvas.getContext('2d');
 _bgCtx.strokeStyle = 'rgba(26,26,46,0.35)';
 _bgCtx.lineWidth = 1;
 for (let x = 0; x < w; x += 40) {
 _bgCtx.beginPath(); _bgCtx.moveTo(x,0); _bgCtx.lineTo(x,h); _bgCtx.stroke();
 }
 for (let y = 0; y < h; y += 40) {
 _bgCtx.beginPath(); _bgCtx.moveTo(0,y); _bgCtx.lineTo(w,y); _bgCtx.stroke();
 }
 const vig = _bgCtx.createRadialGradient(w/2,h/2,h*0.3, w/2,h/2,h*0.9);
 vig.addColorStop(0, 'transparent');
 vig.addColorStop(1, 'rgba(0,0,0,0.45)');
 _bgCtx.fillStyle = vig;
 _bgCtx.fillRect(0, 0, w, h);
 _bgW = w; _bgH = h;
}
function drawArena() {
 const w = canvas.width, h = canvas.height;
 ctx.clearRect(0, 0, w, h);
 if (!_bgCanvas || _bgW !== w || _bgH !== h) buildBgCanvas(w, h);
 ctx.drawImage(_bgCanvas, 0, 0);

 // ‚îÄ‚îÄ ZOOM TRANSFORM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ctx.save();
 const zx = w / 2 + _zoomPanX;
 const zy = h / 2 + _zoomPanY;
 ctx.translate(zx, zy);
 ctx.scale(_arenaZoom, _arenaZoom);
 ctx.translate(-zx, -zy);
 // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

 if (particles.length > 0) {
 ctx.shadowBlur = 5;
 particles.forEach(p => {
 if (p.isRing) return; 
 ctx.globalAlpha = Math.max(0, p.life);
 ctx.fillStyle = p.color;
 ctx.shadowColor = p.color;
 ctx.beginPath();
 ctx.arc(p.x, p.y, Math.max(0.5, p.size * p.life), 0, Math.PI * 2);
 ctx.fill();
 });
 ctx.shadowBlur = 0;
 particles.forEach(p => {
 if (!p.isRing) return;
 ctx.globalAlpha = Math.max(0, p.life);
 ctx.strokeStyle = p.color;
 ctx.lineWidth = p.size;
 ctx.beginPath();
 ctx.arc(p.x, p.y, p.radius * (2 - p.life), 0, Math.PI * 2);
 ctx.stroke();
 });
 ctx.globalAlpha = 1;
 }
 enemies.forEach(e => {
 if (e.hp <= 0) return;
 drawEnemy(e);
 });
 arenaUnits.forEach(u => drawUnit(u));
 drawFood();
 drawFoodFlash(_lastDt);
 drawFoodNotifs(_lastDt);
 drawHealPulses(_lastDt);
 if (floatingDmg.length > 0) {
 ctx.shadowBlur = 4;
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 floatingDmg.forEach(f => {
 ctx.globalAlpha = Math.max(0, f.life);
 ctx.fillStyle = f.color;
 ctx.shadowColor = f.color;
 ctx.font = `bold ${f.crit ? 18 : f.big ? 14 : 10}px Orbitron,monospace`;
 ctx.fillText(f.text, f.x, f.y);
 });
 ctx.shadowBlur = 0;
 ctx.globalAlpha = 1;
 }

 ctx.restore(); // end zoom transform
}
function drawEnemy(e) {
 const isBoss = e.isBoss;
 const r = e.size;
 if (isBoss) {
 const hpPct = Math.max(0, e.hp / e.maxHp);
 const barH = 12, barW = canvas.width - 40, barX = 20, barY = 8;
 ctx.fillStyle = 'rgba(0,0,0,0.7)';
 ctx.beginPath(); ctx.roundRect(barX, barY, barW, barH, 6); ctx.fill();
 const barColor = hpPct > 0.6 ? '#22c55e' : hpPct > 0.3 ? '#f59e0b' : '#ef4444';
 ctx.fillStyle = barColor;
 ctx.shadowColor = barColor; ctx.shadowBlur = 6;
 if (hpPct > 0) {
 ctx.beginPath(); ctx.roundRect(barX, barY, barW * hpPct, barH, 6); ctx.fill();
 }
 ctx.shadowBlur = 0;
 ctx.font = 'bold 8px "Fredoka One", sans-serif';
 ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
 ctx.fillStyle = '#fff';
 ctx.fillText(`‚ò† ${e.bossName} ${Math.ceil(hpPct * 100)}%`, barX + 6, barY + barH * 0.5);
 } else {
 const bw = r * 2.8, bh = 4;
 const hpPct = Math.max(0, e.hp / e.maxHp);
 // Weakness tag
 if (e.weakTo && !e._weakTagDrawn) {
  const wdef = SYNERGY_DEFS[e.weakTo];
  if (wdef) {
   ctx.save();
   ctx.font = `${r * 0.85}px serif`;
   ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
   ctx.globalAlpha = 0.85;
   ctx.fillText(wdef.icon, e.x + r * 0.9, e.y - r * 0.85);
   ctx.restore();
  }
 }
 // HP bar background ‚Äî rounded, styled
 const barX = e.x - bw/2, barY = e.y - r - 10;
 ctx.save();
 ctx.beginPath();
 ctx.roundRect(barX - 1, barY - 1, bw + 2, bh + 2, 3);
 ctx.fillStyle = 'rgba(0,0,0,0.45)';
 ctx.fill();
 ctx.beginPath();
 ctx.roundRect(barX, barY, bw, bh, 2);
 ctx.fillStyle = 'rgba(160,50,50,0.65)';
 ctx.fill();
 if (hpPct > 0) {
  const hpColor = hpPct > 0.6 ? '#ef4444' : hpPct > 0.3 ? '#f97316' : '#ff2222';
  const hpGlow  = hpPct > 0.6 ? '#ff000060' : '#ff660040';
  ctx.beginPath();
  ctx.roundRect(barX, barY, bw * hpPct, bh, 2);
  ctx.fillStyle = hpColor;
  ctx.shadowColor = hpGlow;
  ctx.shadowBlur = 6;
  ctx.fill();
  ctx.shadowBlur = 0;
 }
 // Mini name label for mini-boss
 if (e.isMiniB) {
  ctx.font = 'bold 8px "Fredoka One",sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
  ctx.fillStyle = e.color;
  ctx.shadowColor = e.color; ctx.shadowBlur = 6;
  ctx.fillText('‚ö† ' + e.name, e.x, barY - 2);
  ctx.shadowBlur = 0;
 }
 ctx.restore();
 }
 ctx.shadowColor = e.color;
 ctx.shadowBlur = isBoss ? 30 : 12;
 if (isBoss) {
 const now = Date.now() / 1000;
 const hpPct2 = e.hp / e.maxHp;
 const pulse = 0.5 + 0.5 * Math.sin(now * 3);
 const aura = ctx.createRadialGradient(e.x, e.y, r * 0.5, e.x, e.y, r * 2.4);
 aura.addColorStop(0, e.color + '55');
 aura.addColorStop(1, 'transparent');
 ctx.fillStyle = aura;
 ctx.shadowBlur = 0;
 ctx.beginPath(); ctx.arc(e.x, e.y, r * 2.4, 0, Math.PI * 2); ctx.fill();
 ctx.lineCap = 'round';
 for (let k = 0; k < 6; k++) {
 const baseAngle = (Math.PI * 2 / 6) * k + now * 0.4;
 const wriggle = Math.sin(now * 2.5 + k * 1.2) * 0.3;
 const tentLen = r * (1.6 + Math.sin(now * 3 + k) * 0.18);
 const mid1x = e.x + Math.cos(baseAngle + wriggle * 0.5) * r * 1.1;
 const mid1y = e.y + Math.sin(baseAngle + wriggle * 0.5) * r * 1.1;
 const midx = e.x + Math.cos(baseAngle + wriggle) * r * (1.3 + pulse * 0.1);
 const midy = e.y + Math.sin(baseAngle + wriggle) * r * (1.3 + pulse * 0.1);
 const endx = e.x + Math.cos(baseAngle + wriggle * 1.4) * tentLen;
 const endy = e.y + Math.sin(baseAngle + wriggle * 1.4) * tentLen;
 ctx.strokeStyle = e.color + 'bb';
 ctx.lineWidth = r * (0.22 - k * 0.01);
 ctx.shadowColor = e.color;
 ctx.shadowBlur = 12;
 ctx.beginPath();
 ctx.moveTo(e.x + Math.cos(baseAngle) * r * 0.85, e.y + Math.sin(baseAngle) * r * 0.85);
 ctx.bezierCurveTo(mid1x, mid1y, midx, midy, endx, endy);
 ctx.stroke();
 }
 ctx.shadowColor = e.color;
 ctx.shadowBlur = 30 + pulse * 20;
 const bodyGrad = ctx.createRadialGradient(
 e.x - r * 0.25, e.y - r * 0.3, r * 0.1,
 e.x, e.y, r * 1.05
 );
 bodyGrad.addColorStop(0, lighten(e.color, 0.3));
 bodyGrad.addColorStop(0.5, e.color);
 bodyGrad.addColorStop(1, e.color2 || '#111');
 ctx.fillStyle = bodyGrad;
 ctx.beginPath(); ctx.arc(e.x, e.y, r, 0, Math.PI * 2); ctx.fill();
 ctx.shadowBlur = 0;
 ctx.strokeStyle = lighten(e.color, 0.25);
 ctx.lineWidth = 2.5;
 ctx.setLineDash([6, 4]);
 ctx.beginPath();
 for (let k = 0; k < 6; k++) {
 const a = (Math.PI / 3) * k + now * 0.8;
 const px = e.x + Math.cos(a) * r * 1.08;
 const py = e.y + Math.sin(a) * r * 1.08;
 k === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
 }
 ctx.closePath(); ctx.stroke();
 ctx.setLineDash([]);
 ctx.strokeStyle = e.color + 'aa';
 ctx.lineWidth = 1.5;
 ctx.setLineDash([3,5]);
 ctx.beginPath();
 for (let k = 0; k < 6; k++) {
 const a = (Math.PI / 3) * k - now * 1.4;
 const px = e.x + Math.cos(a) * r * 0.72;
 const py = e.y + Math.sin(a) * r * 0.72;
 k === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
 }
 ctx.closePath(); ctx.stroke();
 ctx.setLineDash([]);
 const eyePositions = [
 { ox: -r*0.28, oy: -r*0.15, er: r*0.18 },
 { ox: r*0.28, oy: -r*0.15, er: r*0.18 },
 { ox: 0, oy: r*0.12, er: r*0.14 },
 ];
 eyePositions.forEach(({ ox, oy, er }) => {
 ctx.fillStyle = 'rgba(0,0,0,0.7)';
 ctx.beginPath(); ctx.arc(e.x + ox, e.y + oy, er, 0, Math.PI * 2); ctx.fill();
 const irisC = hpPct2 > 0.5 ? '#ff0000' : '#ff6600';
 ctx.fillStyle = irisC;
 ctx.shadowColor = irisC; ctx.shadowBlur = 8;
 ctx.beginPath(); ctx.arc(e.x + ox, e.y + oy, er * 0.65, 0, Math.PI * 2); ctx.fill();
 ctx.fillStyle = '#000';
 ctx.shadowBlur = 0;
 ctx.beginPath(); ctx.arc(e.x + ox + Math.sin(now)*er*0.2, e.y + oy + Math.cos(now*0.7)*er*0.2, er * 0.3, 0, Math.PI * 2); ctx.fill();
 ctx.fillStyle = 'rgba(255,255,255,0.8)';
 ctx.beginPath(); ctx.arc(e.x + ox - er*0.22, e.y + oy - er*0.22, er * 0.15, 0, Math.PI * 2); ctx.fill();
 });
 ctx.shadowBlur = 0;
 ctx.beginPath();
 ctx.ellipse(e.x - r*0.28, e.y - r*0.35, r*0.18, r*0.10, -0.6, 0, Math.PI*2);
 ctx.fillStyle = 'rgba(255,255,255,0.25)'; ctx.fill();
 ctx.shadowBlur = 0;
 const hpBar = Math.ceil(hpPct2 * 100);
 ctx.font = `bold ${Math.max(9, r * 0.28)}px "Fredoka One", sans-serif`;
 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
 ctx.fillStyle = '#fff';
 ctx.shadowColor = e.color; ctx.shadowBlur = 6;
 ctx.fillText(e.bossName, e.x, e.y + r + 16);
 ctx.shadowBlur = 0;
 ctx.font = `bold ${Math.max(8, r * 0.22)}px "Nunito", sans-serif`;
 ctx.fillStyle = hpPct2 > 0.5 ? '#4ade80' : hpPct2 > 0.25 ? '#fb923c' : '#ef4444';
 ctx.fillText(`${hpBar}% HP`, e.x, e.y + r + 30);
 if (hpPct2 < 0.25 && Math.sin(now * 10) > 0.6) {
 ctx.fillStyle = 'rgba(255,0,0,0.08)';
 ctx.beginPath(); ctx.arc(e.x, e.y, r * 1.2, 0, Math.PI * 2); ctx.fill();
 }
 ctx.shadowBlur = 0;
 } else {
 const now2 = Date.now() / 1000;
 if (!e._phase) e._phase = Math.random() * Math.PI * 2;
 const ph = e._phase;
 const ename = e.name || '';
 const hpPct3 = Math.max(0, e.hp / e.maxHp);
 ctx.save();
 ctx.translate(e.x, e.y);

 if (ename === 'Crawler') {
  const sq = 1 + Math.sin(now2*8+ph)*0.15;
  ctx.scale(sq, 1/sq);
  ctx.shadowColor=e.color; ctx.shadowBlur=8;
  ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  for(let i=0;i<6;i++){
   const a=(Math.PI/3)*i+now2*4;
   ctx.strokeStyle=e.color+'bb'; ctx.lineWidth=1.5;
   ctx.beginPath(); ctx.moveTo(Math.cos(a)*r*0.8,Math.sin(a)*r*0.8);
   ctx.lineTo(Math.cos(a)*r*1.4,Math.sin(a)*r*1.4); ctx.stroke();
  }
 } else if (ename === 'Speeder') {
  const angle=Math.atan2(e.vy||0, e.vx||(e.x<canvas.width/2?1:-1));
  ctx.rotate(angle); ctx.scale(1.4,0.7);
  ctx.shadowColor=e.color; ctx.shadowBlur=14;
  const tg=ctx.createLinearGradient(-r*2.5,0,0,0);
  tg.addColorStop(0,'transparent'); tg.addColorStop(1,e.color+'66');
  ctx.fillStyle=tg; ctx.beginPath(); ctx.ellipse(-r*1.5,0,r*2,r*0.5,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
 } else if (ename === 'Bruiser') {
  const pulse=1+Math.sin(now2*2.5+ph)*0.08;
  ctx.shadowColor=e.color; ctx.shadowBlur=12;
  ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(0,0,r*pulse,0,Math.PI*2); ctx.fill();
  for(let i=0;i<5;i++){
   const a=(Math.PI*2/5)*i+now2*0.6;
   ctx.fillStyle=e.color; ctx.beginPath();
   ctx.moveTo(Math.cos(a)*r*pulse, Math.sin(a)*r*pulse);
   ctx.lineTo(Math.cos(a+0.25)*r*pulse*0.7, Math.sin(a+0.25)*r*pulse*0.7);
   ctx.lineTo(Math.cos(a)*r*pulse*1.55, Math.sin(a)*r*pulse*1.55);
   ctx.lineTo(Math.cos(a-0.25)*r*pulse*0.7, Math.sin(a-0.25)*r*pulse*0.7);
   ctx.closePath(); ctx.fill();
  }
 } else if (ename === 'Tank') {
  ctx.shadowColor=e.color; ctx.shadowBlur=20;
  ctx.rotate(Math.sin(now2*0.8+ph)*0.04);
  ctx.strokeStyle=e.color+'55'; ctx.lineWidth=4;
  ctx.beginPath(); ctx.arc(0,0,r*1.35,0,Math.PI*2); ctx.stroke();
  ctx.fillStyle=e.color; ctx.beginPath();
  for(let i=0;i<6;i++){const a=(Math.PI/3)*i-Math.PI/6; i===0?ctx.moveTo(Math.cos(a)*r,Math.sin(a)*r):ctx.lineTo(Math.cos(a)*r,Math.sin(a)*r);}
  ctx.closePath(); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.1)'; ctx.beginPath(); ctx.arc(-r*0.2,-r*0.25,r*0.4,0,Math.PI*2); ctx.fill();
 } else if (ename === 'Slasher') {
  ctx.rotate(now2*3+ph); ctx.shadowColor=e.color; ctx.shadowBlur=16;
  for(let i=0;i<4;i++){
   ctx.save(); ctx.rotate((Math.PI/2)*i); ctx.fillStyle=e.color;
   ctx.beginPath(); ctx.ellipse(r*0.6,0,r*0.85,r*0.28,0,0,Math.PI*2); ctx.fill(); ctx.restore();
  }
  ctx.fillStyle=lighten(e.color,0.2); ctx.beginPath(); ctx.arc(0,0,r*0.45,0,Math.PI*2); ctx.fill();
 } else if (ename === 'Phantom') {
  const flicker=0.55+Math.sin(now2*7+ph)*0.3;
  ctx.globalAlpha=flicker; ctx.shadowColor=e.color; ctx.shadowBlur=22;
  ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=flicker*0.25; ctx.beginPath(); ctx.arc(-e.speed*2,0,r*0.7,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha=1;
 } else if (ename === 'Nullifier') {
  ctx.shadowColor=e.color; ctx.shadowBlur=8;
  ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#fff8'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,r*0.65,0,Math.PI*2); ctx.stroke();
  const cr=now2*(-1.2); ctx.strokeStyle='#fffa'; ctx.lineWidth=2.5;
  ctx.beginPath(); ctx.moveTo(Math.cos(cr)*r*0.65,Math.sin(cr)*r*0.65);
  ctx.lineTo(Math.cos(cr+Math.PI)*r*0.65,Math.sin(cr+Math.PI)*r*0.65); ctx.stroke();
 } else if (ename === 'Shielded') {
  ctx.fillStyle=e.color; ctx.shadowColor=e.color; ctx.shadowBlur=14;
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  const sa=now2*2+ph;
  ctx.strokeStyle='#60a5facc'; ctx.lineWidth=3; ctx.shadowColor='#60a5fa'; ctx.shadowBlur=12;
  ctx.beginPath(); ctx.arc(0,0,r*1.4,sa,sa+Math.PI*1.3); ctx.stroke();
  ctx.beginPath(); ctx.arc(0,0,r*1.4,sa+Math.PI,sa+Math.PI*2.3); ctx.stroke();
 } else if (ename === 'Rusher') {
  const angle2=Math.atan2(e.vy||0,e.vx||(e.x<canvas.width/2?1:-1));
  ctx.rotate(angle2);
  for(let i=0;i<3;i++){
   const fx=-r*(1.2+i*0.45)+Math.sin(now2*12+i*2.1)*r*0.2;
   const fy=Math.sin(now2*9+ph+i)*r*0.25;
   ctx.shadowColor='#fb923c'; ctx.shadowBlur=12;
   ctx.fillStyle='rgba(251,146,60,'+(0.7-i*0.2)+')';
   ctx.beginPath(); ctx.arc(fx,fy,r*(0.45-i*0.1),0,Math.PI*2); ctx.fill();
  }
  ctx.shadowColor=e.color; ctx.shadowBlur=10; ctx.fillStyle=e.color;
  ctx.beginPath();
  ctx.moveTo(r*1.1,0); ctx.lineTo(-r*0.6,-r*0.7); ctx.lineTo(-r*0.2,0); ctx.lineTo(-r*0.6,r*0.7);
  ctx.closePath(); ctx.fill();
 } else if (ename === 'Breaker') {
  const pulse2=1+Math.sin(now2*4+ph)*0.1;
  ctx.shadowColor=e.color; ctx.shadowBlur=18;
  ctx.fillStyle=e.color; ctx.beginPath(); ctx.arc(0,0,r*pulse2,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#fff9'; ctx.lineWidth=r*0.22; ctx.lineCap='round'; ctx.shadowBlur=6;
  const xr=r*0.48;
  ctx.beginPath(); ctx.moveTo(-xr,-xr); ctx.lineTo(xr,xr); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(xr,-xr); ctx.lineTo(-xr,xr); ctx.stroke();
 } else {
  ctx.shadowColor=e.color; ctx.shadowBlur=10;
  const g=ctx.createRadialGradient(-r*0.3,-r*0.3,r*0.1,0,0,r);
  g.addColorStop(0,lighten(e.color,0.3)); g.addColorStop(1,e.color);
  ctx.fillStyle=g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
 }

 // Oczy dla wiƒôkszo≈õci typ√≥w
 if (ename!=='Slasher'&&ename!=='Speeder'&&ename!=='Tank') {
  ctx.shadowBlur=0;
  ctx.fillStyle='rgba(0,0,0,0.75)';
  ctx.beginPath(); ctx.arc(-r*0.26,-r*0.18,r*0.17,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc( r*0.26,-r*0.18,r*0.17,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#ff2020';
  ctx.beginPath(); ctx.arc(-r*0.26,-r*0.18,r*0.09,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc( r*0.26,-r*0.18,r*0.09,0,Math.PI*2); ctx.fill();
 }
 ctx.restore(); ctx.shadowBlur=0;
 }
 ctx.shadowBlur = 0;
}
function drawUnit(u) {
 const t = u.date || (u.date = Math.random() * 1000);
 const now = Date.now() / 1000;
 const wobble = Math.sin(now * 2.5 + t) * 0.06; 
 const bounce = u.attackBounce > 0 ? 1 + u.attackBounce * 0.35 : 1;
 if (u.attackBounce > 0) u.attackBounce -= 0.04;
 const baseR = 16 + u.tier * 3;
 const r = baseR * bounce;
 const x = u.x, y = u.y;
 const[_bT,_bB]=getSkinColors(u.tier);
 {
 const hpPct = Math.max(0, u.hp / u.maxHp);
 const BAR_W = r * 2.1; // szeroko≈õƒá = dok≈Çadnie obiekt (r*2 = ≈õrednica + 5%)
 const BAR_H = 8; 
 const RAD = BAR_H / 2;
 const BAR_X = x - BAR_W / 2;
 const BAR_Y = y - r - BAR_H - 4; // przyklejony tu≈º nad g≈ÇowƒÖ
 ctx.save();
 ctx.shadowColor = 'rgba(0,0,0,0.7)';
 ctx.shadowBlur = 10;
 ctx.shadowOffsetY = 3;
 ctx.beginPath();
 ctx.roundRect(BAR_X - 2, BAR_Y - 2, BAR_W + 4, BAR_H + 4, RAD + 2);
 ctx.fillStyle = 'rgba(0,0,0,0.0)'; 
 ctx.fill();
 ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
 ctx.beginPath();
 ctx.roundRect(BAR_X - 1.5, BAR_Y - 1.5, BAR_W + 3, BAR_H + 3, RAD + 1.5);
 ctx.fillStyle = 'rgba(10,5,25,0.9)';
 ctx.fill();
 ctx.strokeStyle = 'rgba(255,255,255,0.18)';
 ctx.lineWidth = 1.2;
 ctx.stroke();
 ctx.beginPath();
 ctx.roundRect(BAR_X, BAR_Y, BAR_W, BAR_H, RAD);
 ctx.fillStyle = 'rgba(30,15,60,0.85)';
 ctx.fill();
 if (hpPct > 0) {
 const fillW = BAR_W * hpPct;
 const [c1, c2, glow] = hpPct > 0.55
 ? ['#6fff90', '#22dd55', '#33ff77']
 : hpPct > 0.28
 ? ['#ffe95a', '#ffaa00', '#ffcc00']
 : ['#ff6060', '#dd1111', '#ff3333'];
 const fillGrad = ctx.createLinearGradient(BAR_X, BAR_Y, BAR_X + fillW, BAR_Y);
 fillGrad.addColorStop(0, c1);
 fillGrad.addColorStop(0.6, c2);
 fillGrad.addColorStop(1, c2);
 ctx.save();
 ctx.beginPath();
 ctx.roundRect(BAR_X, BAR_Y, BAR_W, BAR_H, RAD);
 ctx.clip();
 ctx.fillStyle = fillGrad;
 ctx.fillRect(BAR_X, BAR_Y, fillW, BAR_H);
 const shineGrad = ctx.createLinearGradient(BAR_X, BAR_Y, BAR_X, BAR_Y + BAR_H * 0.55);
 shineGrad.addColorStop(0, 'rgba(255,255,255,0.38)');
 shineGrad.addColorStop(1, 'rgba(255,255,255,0)');
 ctx.fillStyle = shineGrad;
 ctx.fillRect(BAR_X, BAR_Y, fillW, BAR_H);
 ctx.globalAlpha = 0.10;
 for (let seg = 1; seg < 4; seg++) {
 const sx = BAR_X + BAR_W * seg * 0.25;
 ctx.fillStyle = 'rgba(0,0,0,0.6)';
 ctx.fillRect(sx - 0.5, BAR_Y, 1, BAR_H);
 }
 ctx.globalAlpha = 1;
 ctx.restore();
 ctx.save();
 ctx.shadowColor = glow;
 ctx.shadowBlur = 12 + 6 * Math.sin(Date.now() / 400);
 ctx.beginPath();
 ctx.roundRect(BAR_X, BAR_Y, fillW, BAR_H, RAD);
 ctx.strokeStyle = glow + '55';
 ctx.lineWidth = 1.5;
 ctx.stroke();
 ctx.restore();
 }
 ctx.font = `bold ${Math.round(BAR_H * 0.88)}px "Fredoka One", sans-serif`;
 ctx.textAlign = 'right';
 ctx.textBaseline = 'middle';
 ctx.fillStyle = '#1e3a5f';
 ctx.shadowBlur = 0;
 ctx.fillText(`${Math.ceil(hpPct * 100)}%`, BAR_X + BAR_W - 3, BAR_Y + BAR_H * 0.52);
 ctx.restore();
 }

 // ‚ïê‚ïê‚ïê SLIME BODY REDESIGN ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 ctx.save();
 ctx.translate(x, y);
 const sk = activeSkin;
 const tier = u.tier;
 const hpR = Math.max(0, u.hp / u.maxHp);
 const bR = r; // alias

 // ‚îÄ‚îÄ Per-tier config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const TD = [null,
  {sp:0,te:0,rn:0,crown:false,wings:false,orb:0}, // T1
  {sp:0,te:0,rn:1,crown:false,wings:false,orb:0}, // T2
  {sp:3,te:0,rn:1,crown:false,wings:false,orb:0}, // T3
  {sp:4,te:2,rn:1,crown:false,wings:false,orb:1}, // T4
  {sp:5,te:2,rn:2,crown:false,wings:true, orb:2}, // T5
  {sp:0,te:3,rn:2,crown:false,wings:true, orb:3}, // T6
  {sp:6,te:3,rn:2,crown:true, wings:true, orb:3}, // T7
  {sp:8,te:4,rn:3,crown:true, wings:true, orb:4}, // T8
  {sp:0,te:6,rn:3,crown:true, wings:true, orb:5}, // T9
  {sp:8,te:6,rn:4,crown:true, wings:true, orb:6}, // T10
 ];
 const td = TD[Math.min(tier,10)] || TD[1];

 // ‚îÄ‚îÄ AURA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const auraAmt = [0,.3,.4,.5,.6,.7,.9,1,1.2,1.5,2][Math.min(tier,10)];
 if (auraAmt > 0) {
  const aS = bR*(1.5+Math.sin(now*1.8+t)*0.14);
  const aG = ctx.createRadialGradient(0,0,bR*0.5,0,0,aS);
  const aA = Math.floor(auraAmt*(u.mutant?1.4:1)*0.18*255).toString(16).padStart(2,'0');
  aG.addColorStop(0,_bT+aA); aG.addColorStop(0.6,_bT+'18'); aG.addColorStop(1,'transparent');
  ctx.fillStyle=aG; ctx.beginPath(); ctx.arc(0,0,aS,0,Math.PI*2); ctx.fill();
 }

 // ‚îÄ‚îÄ WINGS (T5+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (td.wings) {
  const wf = Math.sin(now*4+t);
  const wSpread = bR*(1.85+wf*0.35), wH = bR*(1.15+wf*0.15);
  for (const side of [-1,1]) {
   ctx.save(); ctx.scale(side,1);
   const wG = ctx.createRadialGradient(bR*0.4,-bR*0.3,0,bR*0.8,-bR*0.2,wSpread);
   wG.addColorStop(0,_bT+'cc'); wG.addColorStop(0.5,_bT+'44'); wG.addColorStop(1,'transparent');
   ctx.fillStyle=wG; ctx.beginPath();
   ctx.moveTo(bR*0.3,-bR*0.1);
   ctx.bezierCurveTo(bR*0.8,-bR*(0.9+wf*0.2),wSpread,-wH,wSpread*0.85,-bR*0.1);
   ctx.bezierCurveTo(wSpread*0.7,bR*0.4,bR*0.5,bR*0.3,bR*0.3,bR*0.15);
   ctx.closePath(); ctx.fill();
   ctx.strokeStyle=_bT+'77'; ctx.lineWidth=1;
   ctx.beginPath(); ctx.moveTo(bR*0.35,0);
   ctx.bezierCurveTo(bR*0.7,-bR*0.5,wSpread*0.6,-wH*0.6,wSpread*0.75,-bR*0.1); ctx.stroke();
   ctx.restore();
  }
 }

 // ‚îÄ‚îÄ TENTACLES (T4+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (td.te > 0) {
  ctx.lineCap='round';
  for (let k=0;k<td.te;k++) {
   const bA = (Math.PI*2/td.te)*k + Math.PI*0.4 + now*0.3;
   const wr = Math.sin(now*2.5+k*1.3+t)*0.35;
   const tL = bR*(1.4+Math.sin(now*2+k)*0.2);
   const mx = Math.cos(bA+wr*0.5)*bR, my = Math.sin(bA+wr*0.5)*bR;
   const ex = Math.cos(bA+wr)*tL, ey = Math.sin(bA+wr)*tL;
   const tG = ctx.createLinearGradient(mx*0.4,my*0.4,ex,ey);
   tG.addColorStop(0,_bT+'cc'); tG.addColorStop(1,_bB+'33');
   ctx.strokeStyle=tG; ctx.lineWidth=bR*(0.24-k*0.015);
   ctx.shadowColor=_bT; ctx.shadowBlur=8;
   ctx.beginPath(); ctx.moveTo(Math.cos(bA)*bR*0.7,Math.sin(bA)*bR*0.7);
   ctx.quadraticCurveTo(mx,my,ex,ey); ctx.stroke();
   ctx.fillStyle=lighten(_bT,0.25); ctx.shadowBlur=6;
   ctx.beginPath(); ctx.arc(ex,ey,bR*0.13,0,Math.PI*2); ctx.fill();
  }
  ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ SPIKES (T3,T4,T7+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (td.sp > 0) {
  const sRot = now*(tier>=8?0.8:0.3)+t;
  ctx.shadowColor=_bT; ctx.shadowBlur=10;
  for (let k=0;k<td.sp;k++) {
   const a=(Math.PI*2/td.sp)*k+sRot;
   const sL=bR*(1.45+Math.sin(now*3+k*0.9)*0.18), sW=bR*0.17;
   ctx.save(); ctx.rotate(a); ctx.fillStyle=tier>=9?_bT:lighten(_bT,0.25);
   ctx.beginPath(); ctx.moveTo(0,-bR*0.75); ctx.lineTo(-sW,-bR*0.82);
   ctx.lineTo(0,-sL); ctx.lineTo(sW,-bR*0.82); ctx.closePath(); ctx.fill();
   ctx.restore();
  }
  ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ ORBIT PARTICLES (T4+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (td.orb > 0) {
  for (let k=0;k<td.orb;k++) {
   const oA=(Math.PI*2/td.orb)*k + now*(1.5+tier*0.1);
   const oR=bR*(1.55+(k%2)*0.3), oSz=bR*(0.1+0.04*tier);
   ctx.shadowColor=_bT; ctx.shadowBlur=12;
   ctx.fillStyle=k%2===0?_bT:lighten(_bT,0.3);
   ctx.globalAlpha=0.75+Math.sin(now*3+k)*0.2;
   ctx.beginPath(); ctx.arc(Math.cos(oA)*oR,Math.sin(oA)*oR*0.6,oSz,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ RINGS (T2+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (td.rn > 0) {
  for (let rk=0;rk<td.rn;rk++) {
   const rRot=now*(0.6+rk*0.4)*(rk%2===0?1:-1);
   const rR=bR*(1.26+rk*0.22);
   ctx.setLineDash([4+rk*2,3+rk]); ctx.lineDashOffset=rRot*20;
   ctx.strokeStyle=_bT+(rk===0?'aa':'55'); ctx.lineWidth=1.5-rk*0.3;
   ctx.shadowColor=_bT; ctx.shadowBlur=5;
   ctx.save(); ctx.rotate(rRot*0.5); ctx.scale(1,0.45+rk*0.1);
   ctx.beginPath(); ctx.arc(0,0,rR,0,Math.PI*2); ctx.stroke();
   ctx.restore();
  }
  ctx.setLineDash([]); ctx.lineDashOffset=0; ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ DRIP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const dG = ctx.createLinearGradient(0,-bR*0.2,0,bR*0.9);
 dG.addColorStop(0,_bT+'aa'); dG.addColorStop(1,_bB+'22');
 ctx.fillStyle=dG; ctx.shadowColor=_bT; ctx.shadowBlur=tier>=7?28:tier>=4?18:10;
 ctx.beginPath(); ctx.ellipse(0,bR*0.3,bR*(0.82-wobble*0.08),bR*(0.5+wobble*0.25),0,0,Math.PI*2); ctx.fill();

 // ‚îÄ‚îÄ MAIN BODY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const bG = ctx.createRadialGradient(-bR*0.28,-bR*0.32,bR*0.04,0,0,bR*1.1);
 bG.addColorStop(0,lighten(_bT,u.mutant?0.55:0.38));
 bG.addColorStop(0.4,_bT); bG.addColorStop(0.85,_bB); bG.addColorStop(1,_bB);
 ctx.fillStyle=bG; ctx.shadowColor=_bT;
 ctx.shadowBlur=u.mutant?28:tier>=8?24:tier>=5?18:12;
 ctx.beginPath(); ctx.ellipse(0,0,bR*(1+wobble*0.1),bR*(1-wobble*0.05),0,0,Math.PI*2); ctx.fill();

 // Rim light
 ctx.strokeStyle=lighten(_bT,0.5)+'44'; ctx.lineWidth=2.5; ctx.shadowBlur=0;
 ctx.beginPath(); ctx.ellipse(0,0,bR*(1+wobble*0.1),bR*(1-wobble*0.05),0,0,Math.PI*2); ctx.stroke();

 // Gloss
 ctx.fillStyle='rgba(255,255,255,0.55)';
 ctx.beginPath(); ctx.ellipse(-bR*0.27,-bR*0.3,bR*0.22,bR*0.13,-0.5,0,Math.PI*2); ctx.fill();
 ctx.fillStyle='rgba(255,255,255,0.18)';
 ctx.beginPath(); ctx.ellipse(bR*0.12,-bR*0.18,bR*0.1,bR*0.06,0.4,0,Math.PI*2); ctx.fill();

 // ‚îÄ‚îÄ CROWN (T7+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (td.crown) {
  const cY=-bR*(1.05+Math.sin(now*1.2+t)*0.04), cW=bR*0.88, cH=bR*0.44, cPts=5;
  ctx.fillStyle=tier>=9?'#ffd700':'#e879f9';
  ctx.shadowColor=tier>=9?'#ffaa00':'#c026d3'; ctx.shadowBlur=14;
  ctx.beginPath();
  for (let k=0;k<=cPts*2;k++) {
   const a=(k/(cPts*2))*Math.PI-Math.PI*0.5, isPt=k%2===0;
   const px=Math.cos(a)*cW*(isPt?1:0.82), py=cY-cH*(isPt?1:0);
   k===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
  }
  ctx.lineTo(cW*0.9,cY+cH*0.2); ctx.lineTo(-cW*0.9,cY+cH*0.2); ctx.closePath(); ctx.fill();
  for (let k=0;k<cPts;k++) {
   const a=((k/(cPts-1))-0.5)*Math.PI;
   ctx.fillStyle=k%2===0?'#ff6fef':'#fff'; ctx.shadowColor='#ff00cc'; ctx.shadowBlur=8;
   ctx.beginPath(); ctx.arc(Math.cos(a)*cW*0.78,cY-cH*0.38,bR*0.07,0,Math.PI*2); ctx.fill();
  }
  ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ ANTENNAE (T2+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (tier >= 2) {
  ctx.strokeStyle=_bT; ctx.lineWidth=2.5; ctx.shadowColor=_bT; ctx.shadowBlur=8;
  const ants = tier>=3
   ? [[-bR*0.28,-bR*0.88,-bR*0.43,-bR*1.45,-1],[bR*0.28,-bR*0.88,bR*0.43,-bR*1.45,1]]
   : [[0,-bR*0.9,0,-bR*1.48,0]];
  ants.forEach(([sx2,sy2,ex2,ey2,sd],ai) => {
   const tipWave = Math.sin(now*3+ai+t)*bR*0.07;
   ctx.beginPath(); ctx.moveTo(sx2,sy2);
   ctx.quadraticCurveTo(sx2+sd*bR*0.12,-bR*1.18,ex2+tipWave,ey2); ctx.stroke();
   ctx.fillStyle=lighten(_bT,0.4); ctx.shadowBlur=14;
   const tr=bR*(0.09+0.04*Math.abs(Math.sin(now*4+ai)));
   ctx.beginPath(); ctx.arc(ex2+tipWave,ey2,tr,0,Math.PI*2); ctx.fill();
  });
  ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ ENERGY SPARKS (T5+) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (tier >= 5) {
  const sparkColors=['','','','','','#e879f9','#ffffff','#00e5ff','#00e5ff','#ff5500','#ff5500'];
  const sc=sparkColors[Math.min(tier,10)];
  for (let k=0;k<3;k++) {
   const a=(Math.PI*2/3)*k - Math.PI/2 + now*1.5;
   const dist=bR*(1.5+Math.sin(now*4+k*2)*0.28);
   ctx.strokeStyle=sc; ctx.lineWidth=2.5;
   ctx.shadowColor=sc; ctx.shadowBlur=14;
   ctx.beginPath(); ctx.moveTo(Math.cos(a)*bR,Math.sin(a)*bR);
   ctx.lineTo(Math.cos(a)*dist,Math.sin(a)*dist); ctx.stroke();
  }
  ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ EYES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const eyeY2=-bR*0.12, eSpread=bR*0.33;
 const eR=bR*(tier<=2?0.22:0.26), pR=eR*0.55;
 const eCols=['','#1a7a00','#1060b0','#8c006b','#7a3000','#4400b0','#cc0066','#0088aa','#880000','#550077','#cc3300'];
 const eCol=u.mutant?'#ff006e':(eCols[Math.min(tier,10)]||'#333');
 const iPulse=tier>=6?0.4+0.6*Math.abs(Math.sin(now*(5+tier*0.5))):0;
 const eyeXs=tier>=8?[-eSpread,0,eSpread]:[-eSpread,eSpread];
 const eyeYs=tier>=8?[-bR*0.18,-bR*0.05,-bR*0.18]:[eyeY2,eyeY2];

 eyeXs.forEach((ex4,ei) => {
  const ey3=eyeYs[ei];
  ctx.fillStyle='rgba(255,255,255,0.96)'; ctx.shadowBlur=0;
  ctx.beginPath(); ctx.ellipse(ex4,ey3,eR,eR*(1.08+wobble*0.15),0,0,Math.PI*2); ctx.fill();
  if (iPulse>0){ctx.shadowColor=eCol; ctx.shadowBlur=10*iPulse;}
  ctx.fillStyle=eCol;
  const px2=ex4+Math.sin(now*0.7)*eR*0.18, py2=ey3+Math.cos(now*0.5)*eR*0.15;
  ctx.beginPath(); ctx.arc(px2,py2,pR*(1+iPulse*0.3),0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0; ctx.fillStyle='#000';
  ctx.beginPath(); ctx.arc(px2,py2,pR*0.42,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.9)';
  ctx.beginPath(); ctx.arc(ex4-eR*0.22,ey3-eR*0.25,eR*0.17,0,Math.PI*2); ctx.fill();
 });

 // ‚îÄ‚îÄ MOUTH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 const mY=bR*(tier>=8?0.22:0.3);
 ctx.shadowBlur=0; ctx.strokeStyle=hpR<0.3?'#ff6060':'#2a0a0a';
 ctx.lineWidth=bR*0.055; ctx.lineCap='round';
 ctx.beginPath();
 if (hpR<0.3) {
  ctx.arc(0,mY+bR*0.14,bR*0.2,Math.PI*0.15,Math.PI*0.85);
 } else if (u.attackBounce>0.1) {
  ctx.arc(0,mY,bR*0.2,0.1,Math.PI-0.1);
  ctx.fillStyle='#660000'; ctx.fill();
  if (tier>=6) { // teeth
   ctx.fillStyle='#fff';
   for (let tk=0;tk<3;tk++) {
    const tx=(tk-1)*bR*0.13;
    ctx.beginPath(); ctx.moveTo(tx-bR*0.05,mY); ctx.lineTo(tx+bR*0.05,mY); ctx.lineTo(tx,mY+bR*0.1); ctx.closePath(); ctx.fill();
   }
  }
 } else {
  ctx.arc(0,mY-bR*0.07,bR*0.2,Math.PI*0.1,Math.PI*0.9);
 }
 ctx.stroke();

 // ‚îÄ‚îÄ MUTANT AURA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.mutant) {
  const mp=0.5+0.5*Math.sin(now*5);
  ctx.strokeStyle=`rgba(255,0,110,${0.55+mp*0.4})`;
  ctx.lineWidth=2.8; ctx.setLineDash([5,4]);
  ctx.shadowColor='#ff006e'; ctx.shadowBlur=14;
  ctx.beginPath(); ctx.arc(0,0,bR+6+mp*3,0,Math.PI*2); ctx.stroke();
  ctx.setLineDash([]);
  for (let mk=0;mk<4;mk++) {
   const ma=now*3+mk*Math.PI*0.5, md=bR*(1.3+Math.sin(now*5+mk)*0.2);
   ctx.shadowBlur=10; ctx.fillStyle=`rgba(255,0,110,${0.6+mp*0.3})`;
   ctx.beginPath(); ctx.arc(Math.cos(ma)*md,Math.sin(ma)*md,bR*0.1,0,Math.PI*2); ctx.fill();
  }
  ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ TANK AURA (row 0) ‚Äî blue shield ring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.formationRow === 0) {
  const tp = 0.5 + 0.5 * Math.sin(now * 1.5 + t);
  ctx.strokeStyle = `rgba(90,200,250,${0.3 + tp * 0.25})`;
  ctx.lineWidth = 2.5; ctx.shadowColor = '#5ac8fa'; ctx.shadowBlur = 10 + tp * 6;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.28, 0, Math.PI * 2); ctx.stroke();
  ctx.globalAlpha = 0.06 + tp * 0.05;
  ctx.fillStyle = '#5ac8fa';
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.2, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  // Cooldown arc for shield (8s)
  const tankProg = Math.min(1, (window._rowTicks?.tank || 0) / 8);
  ctx.strokeStyle = 'rgba(90,200,250,0.7)'; ctx.lineWidth = 2;
  ctx.shadowColor = '#5ac8fa'; ctx.shadowBlur = 5;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.42, -Math.PI/2, -Math.PI/2 + tankProg * Math.PI * 2); ctx.stroke();
  ctx.shadowBlur = 0;
 }

 // ‚îÄ‚îÄ BRUISER AURA (row 2) ‚Äî orange flame ring ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.formationRow === 2) {
  const bp = 0.5 + 0.5 * Math.sin(now * 2.2 + t);
  ctx.strokeStyle = `rgba(251,146,60,${0.35 + bp * 0.3})`;
  ctx.lineWidth = 2; ctx.shadowColor = '#fb923c'; ctx.shadowBlur = 10 + bp * 8;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.25 + bp * 2, 0, Math.PI * 2); ctx.stroke();
  ctx.globalAlpha = 0.08 + bp * 0.05;
  ctx.fillStyle = '#fb923c';
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.15, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  // Taunt countdown arc (6s)
  const bruiserProg = Math.min(1, (window._rowTicks?.bruiser || 0) / 6);
  ctx.strokeStyle = 'rgba(251,146,60,0.7)'; ctx.lineWidth = 2;
  ctx.shadowColor = '#fb923c'; ctx.shadowBlur = 5;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.40, -Math.PI/2, -Math.PI/2 + bruiserProg * Math.PI * 2); ctx.stroke();
  ctx.shadowBlur = 0;
 }

 // ‚îÄ‚îÄ ASSASSIN AURA (row 3) ‚Äî purple stealth shimmer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.formationRow === 3) {
  const ap = 0.5 + 0.5 * Math.sin(now * 3 + t);
  // Stealth flash on burst
  if (u._stealthFlash > 0) {
   ctx.globalAlpha = u._stealthFlash;
   ctx.fillStyle = '#bf5af2';
   ctx.shadowColor = '#bf5af2'; ctx.shadowBlur = 30;
   ctx.beginPath(); ctx.arc(0, 0, bR * 1.5, 0, Math.PI * 2); ctx.fill();
   u._stealthFlash = Math.max(0, u._stealthFlash - 0.04);
   ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  }
  ctx.strokeStyle = `rgba(191,90,242,${0.2 + ap * 0.25})`;
  ctx.lineWidth = 1.5; ctx.setLineDash([3, 4]);
  ctx.shadowColor = '#bf5af2'; ctx.shadowBlur = 8;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.3, now * 0.5, now * 0.5 + Math.PI * 2); ctx.stroke();
  ctx.setLineDash([]);
  // Burst cooldown arc (10s)
  const assassinProg = Math.min(1, (window._rowTicks?.assassin || 0) / 10);
  ctx.strokeStyle = 'rgba(191,90,242,0.6)'; ctx.lineWidth = 2;
  ctx.shadowColor = '#bf5af2'; ctx.shadowBlur = 4;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.44, -Math.PI/2, -Math.PI/2 + assassinProg * Math.PI * 2); ctx.stroke();
  ctx.shadowBlur = 0;
 }

 // ‚îÄ‚îÄ SUPPORT HEAL AURA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.formationRow === 4) {
  const sp = 0.5 + 0.5 * Math.sin(now * 1.8 + t);
  const sp2 = 0.5 + 0.5 * Math.sin(now * 1.8 + t + Math.PI);
  // Outer pulsing ring
  ctx.strokeStyle = `rgba(76,217,100,${0.3 + sp * 0.3})`;
  ctx.lineWidth = 2; ctx.shadowColor = '#4cd964'; ctx.shadowBlur = 14 + sp * 8;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.35 + sp * 4, 0, Math.PI * 2); ctx.stroke();
  // Second ring offset
  ctx.strokeStyle = `rgba(76,217,100,${0.15 + sp2 * 0.2})`;
  ctx.lineWidth = 1.2;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.6 + sp2 * 5, 0, Math.PI * 2); ctx.stroke();
  // Inner glow fill
  ctx.globalAlpha = 0.08 + sp * 0.06;
  ctx.fillStyle = '#4cd964'; ctx.shadowBlur = 20;
  ctx.beginPath(); ctx.arc(0, 0, bR * 1.2, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = 1;
  // Orbiting cross particles
  for (let si = 0; si < 3; si++) {
   const sa = now * 1.2 + si * Math.PI * 2 / 3;
   const sd = bR * 1.5;
   ctx.globalAlpha = 0.5 + 0.4 * Math.sin(now * 2 + si * 2);
   ctx.font = `bold ${Math.floor(bR * 0.28)}px sans-serif`;
   ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
   ctx.fillStyle = '#4cd964'; ctx.shadowColor = '#4cd964'; ctx.shadowBlur = 8;
   ctx.fillText('+', Math.cos(sa) * sd, Math.sin(sa) * sd);
  }
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  // Cooldown arc ‚Äî pokazuje postƒôp do nastƒôpnego heala
  const tickProg = ((G._supportTick || 0) % 5) / 5;
  ctx.strokeStyle = `rgba(76,217,100,0.6)`;
  ctx.lineWidth = 2.5; ctx.shadowColor = '#4cd964'; ctx.shadowBlur = 6;
  ctx.beginPath();
  ctx.arc(0, 0, bR * 1.48, -Math.PI / 2, -Math.PI / 2 + tickProg * Math.PI * 2);
  ctx.stroke();
  ctx.shadowBlur = 0;
 }

 // ‚îÄ‚îÄ ELITE GLOW ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.elite) {
  const ep=0.5+0.5*Math.sin(now*3);
  ctx.strokeStyle=`rgba(255,215,0,${0.5+ep*0.4})`;
  ctx.lineWidth=3; ctx.shadowColor='#ffd700'; ctx.shadowBlur=16+ep*12;
  ctx.beginPath(); ctx.arc(0,0,bR*1.22,0,Math.PI*2); ctx.stroke();
  for (let ek=0;ek<4;ek++) {
   const ea=now*1.5+ek*Math.PI*0.5, ed=bR*1.5;
   ctx.fillStyle=`rgba(255,215,0,${0.7+ep*0.2})`; ctx.shadowBlur=12;
   ctx.beginPath(); ctx.arc(Math.cos(ea)*ed,Math.sin(ea)*ed,bR*0.12,0,Math.PI*2); ctx.fill();
  }
  ctx.shadowBlur=0;
 }

 // ‚îÄ‚îÄ ATTACK FLASH ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.attackFlash>0) {
  u.attackFlash-=0.04;
  const af=Math.max(0,u.attackFlash);
  ctx.strokeStyle=`rgba(255,255,255,${af*2.2})`;
  ctx.lineWidth=2; ctx.shadowBlur=0;
  ctx.beginPath(); ctx.arc(0,0,bR*(1+(0.3-af)*2.5),0,Math.PI*2); ctx.stroke();
 }

 // ‚îÄ‚îÄ SKIN OVERLAYS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (sk==='neon') {
  const np=0.5+0.5*Math.sin(now*4+t);
  ctx.globalAlpha=0.25+np*0.3; ctx.strokeStyle=_bT; ctx.lineWidth=2;
  ctx.shadowColor=_bT; ctx.shadowBlur=18+np*12;
  ctx.beginPath(); ctx.arc(0,0,bR*1.2,0,Math.PI*2); ctx.stroke();
  ctx.globalAlpha=1; ctx.shadowBlur=0;
 }
 if (sk==='blood') {
  const dn=2+(tier%3);
  for (let d=0;d<dn;d++) {
   const dx=(d-dn/2+0.5)*bR*0.45, dl=bR*(0.4+0.2*Math.sin(now*1.5+d*2.1));
   const dg2=ctx.createLinearGradient(dx,bR*0.5,dx,bR*0.5+dl);
   dg2.addColorStop(0,'#cc0000bb'); dg2.addColorStop(1,'#cc000000');
   ctx.fillStyle=dg2; ctx.beginPath(); ctx.ellipse(dx,bR*0.5+dl*0.5,bR*0.07,dl*0.55,0,0,Math.PI*2); ctx.fill();
   ctx.fillStyle='#cc0000'; ctx.beginPath(); ctx.arc(dx,bR*0.5+dl,bR*0.09,0,Math.PI*2); ctx.fill();
  }
 }
 if (sk==='ice') {
  const kN=4+tier;
  ctx.strokeStyle='#c0f0ff'; ctx.lineWidth=1.2; ctx.shadowColor='#a0e8ff'; ctx.shadowBlur=6;
  for (let k=0;k<kN;k++) {
   const a=(k/kN)*Math.PI*2+now*0.5, dist=bR*1.28, kL=bR*0.22;
   const kx=Math.cos(a)*dist, ky=Math.sin(a)*dist;
   ctx.globalAlpha=0.5+0.3*Math.sin(now*3+k*1.3);
   ctx.beginPath(); ctx.moveTo(kx-Math.cos(a)*kL,ky-Math.sin(a)*kL); ctx.lineTo(kx+Math.cos(a)*kL,ky+Math.sin(a)*kL); ctx.stroke();
   ctx.beginPath(); ctx.moveTo(kx-Math.sin(a)*kL*0.5,ky+Math.cos(a)*kL*0.5); ctx.lineTo(kx+Math.sin(a)*kL*0.5,ky-Math.cos(a)*kL*0.5); ctx.stroke();
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0;
 }
 if (sk==='gold') {
  for (let s2=0;s2<5+tier;s2++) {
   const a=(s2/(5+tier))*Math.PI*2+now*0.9, dist=bR*(1+0.35*Math.abs(Math.sin(now*1.2+s2)));
   ctx.globalAlpha=0.4+0.5*Math.sin(now*3+s2);
   ctx.fillStyle=s2%2===0?'#ffd700':'#fff'; ctx.shadowColor='#ffd700'; ctx.shadowBlur=7;
   ctx.beginPath(); ctx.arc(Math.cos(a)*dist,Math.sin(a)*dist,bR*0.07,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0;
 }
 if (sk==='shadow') {
  for (let p2=0;p2<6+tier;p2++) {
   const a=(p2/(6+tier))*Math.PI*2, dist2=bR*(0.82+0.45*Math.sin(now*0.6+p2*0.7));
   ctx.globalAlpha=0.35+0.3*Math.sin(now*2+p2);
   ctx.fillStyle=p2%3===0?'#9900ff':'#222244'; ctx.shadowColor='#9900ff'; ctx.shadowBlur=8;
   ctx.beginPath(); ctx.arc(Math.cos(a+now*0.4)*dist2,Math.sin(a+now*0.4)*dist2,bR*0.09,0,Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha=1; ctx.shadowBlur=0;
 }
 if (sk==='cyber') {
  ctx.globalAlpha=0.18; ctx.fillStyle=_bT;
  ctx.fillRect(-bR,-bR+((now*50)%(bR*2)),bR*2,2);
  ctx.globalAlpha=0.5+0.3*Math.sin(now*3); ctx.strokeStyle=_bT; ctx.lineWidth=1.2;
  ctx.shadowColor=_bT; ctx.shadowBlur=6;
  const bkS=bR*0.32;
  [[-1,-1],[1,-1],[1,1],[-1,1]].forEach(([sx4,sy4])=>{
   const bx=sx4*bR*0.95, by=sy4*bR*0.9;
   ctx.beginPath(); ctx.moveTo(bx,by+sy4*bkS); ctx.lineTo(bx,by); ctx.lineTo(bx+sx4*bkS,by); ctx.stroke();
  });
  ctx.globalAlpha=1; ctx.shadowBlur=0;
 }
 // ‚îÄ‚îÄ BUFF / SYNERGY VISUAL INDICATORS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 ctx.restore(); // pop the translate(x,y) context
 ctx.save();
 {
  const baseR2 = 16 + u.tier * 3;
  const now2 = Date.now() / 1000;

  // 1. Synergy ring ‚Äî colored outer ring showing active synergy
  const synTags2 = UNIT_TYPES[u.tier]?.tags || [];
  let synColor = null;
  synTags2.forEach(tag => {
   const bon = G.synergyBonuses?.[tag];
   if (bon && bon.count >= 2) synColor = SYNERGY_DEFS[tag]?.color || null;
  });
  if (synColor) {
   const pulse2 = 0.55 + 0.45 * Math.abs(Math.sin(now2 * 1.8 + u.x * 0.01));
   ctx.save();
   ctx.globalAlpha = pulse2;
   ctx.beginPath();
   ctx.arc(u.x, u.y, baseR2 + 4.5, 0, Math.PI * 2);
   ctx.strokeStyle = synColor;
   ctx.lineWidth = 2.5;
   ctx.shadowColor = synColor;
   ctx.shadowBlur = 10;
   ctx.stroke();
   ctx.restore();
  }

  // 2. Active buff chip icons ‚Äî shown above the HP bar, left-aligned row
  const chipIcons = [];
  if (G.activeEffects) {
   G.activeEffects.forEach(e => {
    const m = { crit_aura:'‚ú¶', overclock:'‚öô', shield_wave:'üõ°', toxic_field:'‚ò†', meteor:'‚òÑ' }[e.id];
    const c = { crit_aura:'#facc15', overclock:'#60a5fa', shield_wave:'#93c5fd', toxic_field:'#a3e635', meteor:'#fb923c' }[e.id];
    if (m) chipIcons.push({ icon: m, color: c });
   });
  }
  if (u.shield && u.shield > 0) chipIcons.push({ icon: 'üõ°', color: '#93c5fd' });
  // Synergy chip icons for this unit's tags
  (UNIT_TYPES[u.tier]?.tags || []).forEach(tag => {
   const def = SYNERGY_DEFS[tag];
   const bon = G.synergyBonuses?.[tag];
   if (def && bon && bon.count >= 2) chipIcons.push({ icon: def.icon, color: def.color, isSyn: true });
  });

  if (chipIcons.length > 0) {
   const chipR = 8;
   const spacing = chipR * 2.2;
   const totalW = chipIcons.length * spacing;
   // Position: centred above the HP bar
   const hpBarY = u.y - baseR2 - 8 - 4;  // same as HP bar top
   const iconsY = hpBarY - chipR - 5;
   let ix = u.x - totalW / 2 + chipR;
   chipIcons.slice(0, 5).forEach((ci, ci_i) => {
    const pulse = ci.isSyn ? (0.75 + 0.25 * Math.sin(now2 * 2 + ci_i * 1.2)) : 1;
    ctx.save();
    ctx.globalAlpha = pulse;
    // Dark pill background
    ctx.beginPath();
    ctx.arc(ix, iconsY, chipR, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.72)';
    ctx.shadowColor = ci.color;
    ctx.shadowBlur = 7;
    ctx.fill();
    // Colored border
    ctx.strokeStyle = ci.color;
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.shadowBlur = 0;
    // Icon
    ctx.font = `${chipR * 1.2}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(ci.icon, ix, iconsY + 0.5);
    ctx.restore();
    ix += spacing;
   });
  }

  // 3. Mutant spark on top
  if (u.mutant) {
   const mx = u.x + baseR2 * 0.6;
   const my = u.y - baseR2 * 0.85;
   const mp = 0.7 + 0.3 * Math.sin(now2 * 5 + u.y);
   ctx.save();
   ctx.globalAlpha = mp;
   ctx.font = `${baseR2 * 0.7}px serif`;
   ctx.textAlign = 'center';
   ctx.textBaseline = 'middle';
   ctx.shadowColor = '#e879f9';
   ctx.shadowBlur = 10;
   ctx.fillText('‚ö°', mx, my);
   ctx.restore();
  }
 }
 // ‚îÄ‚îÄ FORMATION ROLE BADGE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 if (u.formationLabel && u.formationColor) {
  const baseR3 = 16 + u.tier * 3;
  const badgeY = u.y + baseR3 + 10;
  const fLabel = u.formationLabel;
  const fColor = u.formationColor;
  const badgeW = fLabel.length * 4.5 + 6;
  ctx.save();
  ctx.globalAlpha = 0.72;
  ctx.beginPath();
  ctx.roundRect(u.x - badgeW/2, badgeY - 5, badgeW, 10, 3);
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fill();
  ctx.strokeStyle = fColor;
  ctx.lineWidth = 1;
  ctx.shadowColor = fColor;
  ctx.shadowBlur = 6;
  ctx.stroke();
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.fillStyle = fColor;
  ctx.font = 'bold 6.5px "Fredoka One", sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(fLabel, u.x, badgeY);
  ctx.restore();
 }
 ctx.restore();
 ctx.shadowBlur = 0;
}
function lighten(hex, amt) {
 const n = parseInt(hex.slice(1), 16);
 const r = Math.min(255, (n >> 16) + Math.round(255 * amt));
 const g = Math.min(255, ((n >> 8) & 0xff) + Math.round(255 * amt));
 const b = Math.min(255, (n & 0xff) + Math.round(255 * amt));
 return `rgb(${r},${g},${b})`;
}
function spawnKillParticle(x, y, color) {
 const count = 14;
 for (let i = 0; i < count; i++) {
 const angle = (Math.PI * 2 / count) * i;
 const spd = 2 + Math.random() * 5;
 particles.push({ x, y, vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd - 1.5, life: 0.7 + Math.random()*0.4, color, size: 2 + Math.random()*3 });
 }
}
function spawnBossDeathExplosion(x, y, color) {
 for (let i = 0; i < 60; i++) {
 const angle = Math.random() * Math.PI * 2;
 const spd = 2 + Math.random() * 9;
 particles.push({ x, y, vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd - 2, life: 1 + Math.random(), color: [color, '#fff', '#ffbe0b'][i%3], size: 2 + Math.random()*5 });
 }
 particles.push({ x, y, vx: 0, vy: 0, life: 0.8, color, size: 3, isRing: true, radius: 60, noGravity: true });
}
function spawnBullet(x1, y1, x2, y2, color) {
 const dx = x2 - x1, dy = y2 - y1, len = Math.hypot(dx, dy) || 1;
 particles.push({ x: x1, y: y1, vx: (dx/len)*9, vy: (dy/len)*9, life: 0.22, color, size: 2.5, noGravity: true });
}
function spawnCritNumber(dmg, x, y, color) {
 if (floatingDmg.filter(f => f.crit).length >= 4) return;
 const text = `‚ú¶CRIT ${formatNum(dmg)}!`;
 floatingDmg.push({ text, x, y: y - 12, color, life: 1, big: true, crit: true });
 for (let i = 0; i < 8; i++) {
 const a = Math.random() * Math.PI * 2;
 particles.push({ x, y, vx: Math.cos(a)*5, vy: Math.sin(a)*5-2, life: 0.5, color: '#fff', size: 2.5, noGravity: false });
 }
}
function spawnAoERing(x, y, radius, color) {
 particles.push({ x, y, vx: 0, vy: 0, life: 0.35, color, size: 2, isRing: true, radius, noGravity: true });
}
// ‚îÄ‚îÄ UNIT PASSIVE ABILITIES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function applyUnitPassive(u, e, dmg) {
 switch(u.tier) {
  case 2: // SPITTER ‚Äî snare: slow on hit
   if (!e.slowed) { e.slowed = true; e.speed *= 0.6; setTimeout(() => { if(e) { e.speed /= 0.6; e.slowed = false; }}, 1200); }
   break;
  case 3: // SPLITTER ‚Äî acid: stacking DOT
   if (!e.acid) { e.acid = 0; }
   e.acid = Math.min(e.acid + dmg * 0.08, dmg * 0.4);
   e.burning = Math.max(e.burning || 0, 1.5); e.burnDmg = (e.burnDmg || 0) + dmg * 0.05;
   break;
  case 4: // MAGNET ‚Äî stun pulse (rare)
   if (Math.random() < 0.12) {
    const prevSpeed = e.speed; e.speed = 0;
    setTimeout(() => { if(e) e.speed = prevSpeed; }, 600);
    spawnAoERing(e.x, e.y, 40, '#60a5fa');
   }
   break;
  case 5: // REACTOR ‚Äî chain blast
   if (Math.random() < 0.15) {
    enemies.forEach(nearby => {
     if (nearby !== e && Math.hypot(nearby.x-e.x, nearby.y-e.y) < 55) {
      nearby.hp -= dmg * 0.3;
      spawnAoERing(e.x, e.y, 55, '#f97316');
     }
    });
   }
   break;
  case 6: // ANOMALY ‚Äî glitch: random debuff
   if (Math.random() < 0.10) { e.speed *= 0.75; e.glitched = true; }
   break;
  case 7: // PHANTOM ‚Äî phase mark: next hit deals 2x
   if (!e.phaseMarked && Math.random() < 0.18) { e.phaseMarked = true; e._phaseDmgMult = 2.0; }
   break;
  case 8: // COLOSSUS ‚Äî shockwave stomp
   if (Math.random() < 0.08) {
    enemies.forEach(nearby => {
     if (Math.hypot(nearby.x-e.x, nearby.y-e.y) < 70) { nearby.speed = Math.max(0.1, nearby.speed * 0.5); setTimeout(()=>{if(nearby)nearby.speed/=0.5;},800); }
    });
    spawnAoERing(u.x, u.y, 70, '#94a3b8');
   }
   break;
  case 9: // VOIDLING ‚Äî corrupt: reduce maxHP
   if (!e.corrupted && Math.random() < 0.12) { e.corrupted = true; e.maxHp *= 0.85; e.hp = Math.min(e.hp, e.maxHp); }
   break;
  case 10: // OMEGA ‚Äî rally: boost nearby allies
   if (Math.random() < 0.05) {
    arenaUnits.forEach(ally => { if (ally !== u) { ally._rallyBoost = (ally._rallyBoost||0) + 1; ally.dps = Math.floor(ally.dps * 1.01); } });
   }
   break;
 }
}

// ‚îÄ‚îÄ RELIC UPGRADE TREE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const RELIC_UPGRADES = {
 berserker: [
  { level:1, cost:5,  name:'RAGE CORE I',    desc:'+15% more DPS on top of relic bonus', apply(){ G.relicUpgradeMult = (G.relicUpgradeMult||1) * 1.15; } },
  { level:2, cost:12, name:'RAGE CORE II',   desc:'+25% DPS, units heal 5% on kill',     apply(){ G.relicUpgradeMult = (G.relicUpgradeMult||1) * 1.25; G.berserkerLeech = true; } },
  { level:3, cost:25, name:'BLOOD FRENZY',   desc:'+40% DPS, each kill +2% stacking DPS up to 3 waves', apply(){ G.relicUpgradeMult = (G.relicUpgradeMult||1) * 1.40; G.berserkerFrenzy = true; } },
 ],
 fortress: [
  { level:1, cost:5,  name:'IRON WALL I',    desc:'+20% more HP',       apply(){ G.relicHpBonus = (G.relicHpBonus||1) * 1.20; } },
  { level:2, cost:12, name:'IRON WALL II',   desc:'+40% HP + regen',    apply(){ G.relicHpBonus = (G.relicHpBonus||1) * 1.40; G.fortressRegen = true; } },
  { level:3, cost:25, name:'BASTION',        desc:'+60% HP + reflect 10% dmg taken', apply(){ G.relicHpBonus = (G.relicHpBonus||1) * 1.60; G.fortressReflect = true; } },
 ],
 catalyst: [
  { level:1, cost:5,  name:'CATALYST I',     desc:'Mutant chance +10%',  apply(){ G.relicMutantBonus = (G.relicMutantBonus||0) + 0.10; } },
  { level:2, cost:12, name:'CATALYST II',    desc:'Mutants gain +50% AoE splash', apply(){ G.relicMutantBonus = (G.relicMutantBonus||0) + 0.10; G.mutantAoe = true; } },
  { level:3, cost:25, name:'HYPER MUTANT',   desc:'All mutants become elites', apply(){ G.hyperMutant = true; } },
 ],
 economy: [
  { level:1, cost:5,  name:'GOLD FEVER I',   desc:'+25% gold from all sources', apply(){ G.relicGoldBonus = (G.relicGoldBonus||1) * 1.25; } },
  { level:2, cost:12, name:'GOLD FEVER II',  desc:'+50% gold + interest on idle gold', apply(){ G.relicGoldBonus = (G.relicGoldBonus||1) * 1.50; G.goldInterest = true; } },
  { level:3, cost:25, name:'MIDAS TOUCH',    desc:'Units bought give back 30% cost on kill', apply(){ G.midasTouch = true; } },
 ],
 synergy: [
  { level:1, cost:5,  name:'SYN ENGINE I',   desc:'Synergy bonus +20%', apply(){ G.relicSynBonus = (G.relicSynBonus||1) * 1.20; } },
  { level:2, cost:12, name:'SYN ENGINE II',  desc:'Combo effects trigger at 2 units instead of 3', apply(){ G.relicSynBonus = (G.relicSynBonus||1) * 1.20; G.synergyComboReq = 2; } },
  { level:3, cost:25, name:'OMNI SYNERGY',   desc:'All 4 synergies always active at 50% strength', apply(){ G.omniSynergy = true; } },
 ],
 volatile: [
  { level:1, cost:5,  name:'VOLATILE I',     desc:'Explosions deal +30% damage', apply(){ G.relicExplosion = (G.relicExplosion||1) * 1.30; } },
  { level:2, cost:12, name:'VOLATILE II',    desc:'Chain explosions have 40% chance', apply(){ G.relicExplosion = (G.relicExplosion||1) * 1.30; G.chainExplosion = true; } },
  { level:3, cost:25, name:'SUPERNOVA',      desc:'Death explosion radius doubled', apply(){ G.supernovaExplosion = true; } },
 ],
};
function getRelicUpgradeLevel() { return G.relicUpgradeLevel || 0; }
function canUpgradeRelic() {
 if (!G.activeRelic) return false;
 const lvl = getRelicUpgradeLevel();
 const upgrades = RELIC_UPGRADES[G.activeRelic];
 if (!upgrades || lvl >= upgrades.length) return false;
 return G.research >= upgrades[lvl].cost;
}
function doRelicUpgrade() {
 if (!canUpgradeRelic()) return;
 const lvl = getRelicUpgradeLevel();
 const upg = RELIC_UPGRADES[G.activeRelic][lvl];
 G.research -= upg.cost;
 upg.apply();
 G.relicUpgradeLevel = lvl + 1;
 updateCurrencies();
 showNotif(`‚öó ${upg.name}!`, '#c084fc');
 renderRelicUpgrade();
 saveGame();
}
function renderRelicUpgrade() {
 const el = document.getElementById('relic-upgrade-panel');
 if (!el || !G.activeRelic) { if(el) el.style.display='none'; return; }
 const lvl = getRelicUpgradeLevel();
 const upgrades = RELIC_UPGRADES[G.activeRelic];
 if (!upgrades) { el.style.display='none'; return; }
 el.style.display = 'block';
 const next = upgrades[lvl];
 if (!next) { el.innerHTML = '<div style="text-align:center;font-size:10px;color:#a78bfa;padding:6px">‚öó RELIC FULLY UPGRADED ‚úì</div>'; return; }
 const canAfford = G.research >= next.cost;
 el.innerHTML = `
  <div style="font-size:9px;letter-spacing:1px;color:rgba(255,255,255,0.4);margin-bottom:4px">RELIC UPGRADE ${lvl+1}/3</div>
  <div style="font-size:11px;color:#c084fc;font-weight:700;margin-bottom:2px">${next.name}</div>
  <div style="font-size:10px;color:rgba(255,255,255,0.6);margin-bottom:6px">${next.desc}</div>
  <button onclick="doRelicUpgrade()" style="
   width:100%;padding:6px;border-radius:8px;border:none;cursor:pointer;
   font-family:'Fredoka One',sans-serif;font-size:11px;letter-spacing:0.5px;
   background:${canAfford?'linear-gradient(135deg,#7c3aed,#a855f7)':'rgba(255,255,255,0.08)'};
   color:${canAfford?'#fff':'rgba(255,255,255,0.3)'};
   ${canAfford?'box-shadow:0 0 12px rgba(168,85,247,0.4)':''}
  ">${canAfford?'‚öó UPGRADE':'üîí NEED '+next.cost+' RES'}</button>
 `;
}

function addFloatDmg(text, x, y, color, big = false) {
 if (floatingDmg.length >= 25) floatingDmg.splice(0, floatingDmg.length - 24);
 floatingDmg.push({ text: text.toString(), x, y: y - 12, color, life: 1, big });
}
function endWave(victory) {
 G.fighting = false;
 G.killStreak = 0;
 G.streakBonusActive = false;
 clearFood();
 cancelAnimationFrame(animFrame);
 floatingDmg = [];
 particles = [];
 enemies = [];
 bossRef = null;
 clearNightmareDebuff();
 drawArena();
 const kc = document.getElementById('kill-counter');
 if (kc) { kc.textContent = '‚ò† 0 / 0'; kc.style.color = 'rgba(255,255,255,0.35)'; kc.style.borderColor = 'rgba(255,255,255,0.08)'; }
 document.getElementById('enemy-count').textContent = t('enemies', 0);
 document.getElementById('pill-kills').className = 'stat-pill';
 if (victory) {
 const bonus = waveGoldReward(G.wave);
 const bioBonus = Math.floor(G.wave * 0.7);
 const resBonus = Math.floor(G.wave * 0.3);
 G.gold += bonus;
 G.biomass += bioBonus;
 G.research += resBonus;
 addLog(t('logWaveCleared', G.wave, formatNum(bonus), formatNum(bioBonus), formatNum(resBonus)), 'gold');
 showWaveClearedBanner(G.wave, formatNum(bonus));
 sfx.waveEnd(true);
 if (G.wave > G.bestWave) G.bestWave = G.wave;
 if (G.kills > G.bestKills) G.bestKills = G.kills;
 checkDailyProgress('reach_wave', 1);
 if (isNightmareWave(G.wave)) {
 setTimeout(() => openLeaderboard(), 1500);
 }
 const wasLastWave = false; // niesko≈Ñczona gra ‚Äî nie ma ostatniej fali
 G.wave = G.wave + 1;
 tickActiveEffects();
 // ‚îÄ‚îÄ MERGE LAB HINT ‚Äî pokazuje siƒô raz po wave 15 ‚îÄ‚îÄ
 if (G.wave === 16 && !G._labHintSeen) {
  G._labHintSeen = true;
  setTimeout(showMergeLabHint, 1200);
 }
 // ‚îÄ‚îÄ SHARE/FEEDBACK HINT ‚Äî co 30 wave ‚îÄ‚îÄ
 if (G.wave % 30 === 1 && G.wave > 1) {
  setTimeout(showShareHint, 1200);
 }
 if (wasLastWave) {
 triggerWinScreen();
 return;
 }
 if (G.wave % 5 === 0 && !isBossWave(G.wave)) {
 setTimeout(showWaveEventPopup, 400);
 }
 } else {
 addLog(t('logWaveTimeout', G.wave), 'dmg');
 showNotif(t('waveIncomplete'), 'var(--pink)');
 sfx.waveEnd(false);
 updateRewardButtons();
 }
 document.getElementById('wave-num').textContent = G.wave;
 document.getElementById('wave-label-full').textContent = isNightmareWave(G.wave) ? `üíÄ NIGHTMARE WAVE ${G.wave}` : isBossWave(G.wave) ? t('bossWaveLbl', G.wave) : t('waveLbl', G.wave);
 updateCurrencies();
 renderGrid();
 renderUpgrades();
 renderRelicUpgrade();
 renderDailyChallenge();
 const btn = document.getElementById('btn-start');
 const nextBoss = isBossWave(G.wave);
 btn.className = 'btn-start' + (nextBoss && !G.fighting ? ' boss-wave' : '');
 btn.textContent = nextBoss ? t('btnBossWave', G.wave) : t('btnWave', G.wave);
 btn.disabled = false;
 if (G.autoMerge) {
 for (let k = 0; k < 3; k++) setTimeout(tryAutoMerge, k * 250);
 }
 arenaUnits = [];
 particles = [];
 drawArena();
 ambientTransition('idle');
 saveGame();
}
const UPGRADES = [
 { id: 'automerge_unlock', icon:'üî¨', name: 'Auto-Merge Lab',
 desc: 'Automatically merges matching units in real time.',
 cost: { bio: 40 }, check: () => !G.upgrades.automerge_unlock,
 apply: () => { G.upgrades.automerge_unlock = true; G.autoMerge = true;
 document.getElementById('btn-auto').className = 'btn btn-automerge active';
 setTimeout(tryAutoMerge, 100); }
 },
 { id: 'start_tier', icon:'ü•ö', name: 'Evolved Spawn',
 desc: 'All purchased blobs start at Tier 2 instead of T1.',
 cost: { gold: 900, bio: 80 }, check: () => !G.upgrades.start_tier,
 apply: () => G.upgrades.start_tier = true },
 { id: 'mass_merge', icon:'‚ö°', name: 'Mass Merge Protocol',
 desc: 'Auto-merge triggers chain reactions ‚Äî merge cascades through all tiers.',
 cost: { gold: 2000, bio: 200 }, check: () => !G.upgrades.mass_merge,
 apply: () => { G.upgrades.mass_merge = true; setTimeout(tryAutoMerge, 100); }
 },
 { id: 'idle_boost_1', icon:'üí∞', name: 'Idle Efficiency I', desc: '+10% idle gold rate.',
 cost: { bio: 25 }, check: () => G.upgrades.idle_boost < 1,
 apply: () => { G.upgrades.idle_boost = 1; G.idleEfficiency = Math.min(0.46, G.idleEfficiency + 0.10); } },
 { id: 'idle_boost_2', icon:'üí∞', name: 'Idle Efficiency II', desc: '+10% idle gold rate.',
 cost: { bio: 70 }, check: () => G.upgrades.idle_boost < 2,
 apply: () => { G.upgrades.idle_boost = 2; G.idleEfficiency = Math.min(0.46, G.idleEfficiency + 0.10); } },
 { id: 'idle_boost_3', icon:'üí∞', name: 'Idle Efficiency III', desc: '+10% idle gold rate. Max tier.',
 cost: { bio: 180 }, check: () => G.upgrades.idle_boost < 3,
 apply: () => { G.upgrades.idle_boost = 3; G.idleEfficiency = Math.min(0.46, G.idleEfficiency + 0.10); } },
 { id: 'dps_boost_1', icon:'‚öîÔ∏è', name: 'Combat Serum I', desc: '+30% unit DPS.',
 cost: { gold: 150 }, check: () => G.upgrades.dps_boost < 1, apply: () => G.upgrades.dps_boost = 1 },
 { id: 'dps_boost_2', icon:'‚öîÔ∏è', name: 'Combat Serum II', desc: '+30% unit DPS.',
 cost: { gold: 480, bio: 40 }, check: () => G.upgrades.dps_boost < 2, apply: () => G.upgrades.dps_boost = 2 },
 { id: 'dps_boost_3', icon:'‚öîÔ∏è', name: 'Combat Serum III', desc: '+30% unit DPS. Max tier.',
 cost: { gold: 1400, bio: 120 }, check: () => G.upgrades.dps_boost < 3, apply: () => G.upgrades.dps_boost = 3 },
 { id: 'merge_luck_1', icon:'üß¨', name: 'Mutation Serum I', desc: '+3.5% mutation chance on merge.',
 cost: { gold: 80 }, check: () => G.upgrades.merge_luck < 1, apply: () => G.upgrades.merge_luck = 1 },
 { id: 'merge_luck_2', icon:'üß¨', name: 'Mutation Serum II', desc: '+3.5% mutation chance on merge.',
 cost: { gold: 250 }, check: () => G.upgrades.merge_luck < 2, apply: () => G.upgrades.merge_luck = 2 },
 { id: 'merge_luck_3', icon:'üß¨', name: 'Mutation Serum III', desc: '+3.5% mutation chance. Max tier.',
 cost: { gold: 700 }, check: () => G.upgrades.merge_luck < 3, apply: () => G.upgrades.merge_luck = 3 },
 { id: 'gold_boost_1', icon:'‚ú®', name: 'Gold Catalyst I', desc: '+20% gold from wave rewards.',
 cost: { gold: 300, bio: 30 }, check: () => G.upgrades.gold_boost < 1, apply: () => G.upgrades.gold_boost = 1 },
 { id: 'gold_boost_2', icon:'‚ú®', name: 'Gold Catalyst II', desc: '+20% gold from wave rewards.',
 cost: { gold: 900, bio: 80 }, check: () => G.upgrades.gold_boost < 2, apply: () => G.upgrades.gold_boost = 2 },
 { id: 'elite_chance_1', icon:'üëë', name: 'Elite Protocol I', desc: '+5% chance blobs spawn as Elite.',
 cost: { gold: 600, bio: 60 }, check: () => G.upgrades.elite_chance < 1, apply: () => G.upgrades.elite_chance = 1 },
 { id: 'elite_chance_2', icon:'üëë', name: 'Elite Protocol II', desc: '+5% elite spawn chance.',
 cost: { gold: 1800, bio: 150 }, check: () => G.upgrades.elite_chance < 2, apply: () => G.upgrades.elite_chance = 2 },
];
const RESEARCH_UPGRADES = [
 { id: 'r_merge_1', icon:'üß¨', name: 'Recombination I', desc: '+5% mutation chance (permanent across all runs).',
 cost: { research: 3 }, check: () => G.researchBonuses.merge_chance < 1,
 apply: () => G.researchBonuses.merge_chance = 1 },
 { id: 'r_merge_2', icon:'üß¨', name: 'Recombination II', desc: '+5% mutation chance (permanent). Max tier.',
 cost: { research: 8 }, check: () => G.researchBonuses.merge_chance < 2,
 apply: () => G.researchBonuses.merge_chance = 2 },
 { id: 'r_mutation_1', icon:'ü¶†', name: 'Chaos Gene I', desc: '+5% global mutation amp (permanent).',
 cost: { research: 5 }, check: () => G.researchBonuses.mutation_chance < 1,
 apply: () => G.researchBonuses.mutation_chance = 1 },
 { id: 'r_mutation_2', icon:'ü¶†', name: 'Chaos Gene II', desc: '+5% global mutation amp. Max tier.',
 cost: { research: 12 }, check: () => G.researchBonuses.mutation_chance < 2,
 apply: () => G.researchBonuses.mutation_chance = 2 },
 { id: 'r_offline_1', icon:'üò¥', name: 'Dormant Protocol I', desc: '+10% offline gold earnings.',
 cost: { research: 4 }, check: () => G.researchBonuses.offline_pct < 1,
 apply: () => { G.researchBonuses.offline_pct = 1; G.idleEfficiency = Math.min(0.46, G.idleEfficiency + 0.10); } },
 { id: 'r_offline_2', icon:'üò¥', name: 'Dormant Protocol II', desc: '+10% offline gold earnings. Max tier.',
 cost: { research: 10 }, check: () => G.researchBonuses.offline_pct < 2,
 apply: () => { G.researchBonuses.offline_pct = 2; G.idleEfficiency = Math.min(0.46, G.idleEfficiency + 0.10); } },
 { id: 'r_spawn_1', icon:'üëæ', name: 'Enemy Magnet I', desc: 'Denser enemy spawns ‚Üí more gold per wave.',
 cost: { research: 6 }, check: () => G.researchBonuses.spawn_rate_res < 1,
 apply: () => G.researchBonuses.spawn_rate_res = 1 },
 { id: 'r_spawn_2', icon:'üëæ', name: 'Enemy Magnet II', desc: 'Max spawn density. Boss waves get +50% enemies.',
 cost: { research: 16 }, check: () => G.researchBonuses.spawn_rate_res < 2,
 apply: () => G.researchBonuses.spawn_rate_res = 2 },
 { id: 'r_gold_1', icon:'üíé', name: 'Alchemic Formula I', desc: '+15% gold from ALL sources permanently.',
 cost: { research: 7 }, check: () => G.researchBonuses.gold_mult < 1,
 apply: () => G.researchBonuses.gold_mult = 1 },
 { id: 'r_dps_1', icon:'üî•', name: 'Overdrive Protocol', desc: '+25% DPS bonus (permanent, stacks with upgrades).',
 cost: { research: 9 }, check: () => G.researchBonuses.dps_research < 1,
 apply: () => G.researchBonuses.dps_research = 1 },
];
let boughtUpgrades = new Set();
let boughtResearch = new Set();
const RESEARCH_DURATION = 120; 

// ‚îÄ‚îÄ BIO SHOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const BIO_SHOP = [
 // ‚îÄ‚îÄ PERMANENTNE ‚îÄ‚îÄ
 { id:'bio_dps1',    cat:'permanent', name:'Organic Boost I',   icon:'üí™', desc:'+15% DPS for all units (permanent)',          cost: 80,   max: 1, apply: () => { G.bioDPS = (G.bioDPS||0) + 0.15; } },
 { id:'bio_dps2',    cat:'permanent', name:'Organic Boost II',  icon:'üí™', desc:'+25% DPS for all units (permanent)',          cost: 250,  max: 1, req:'bio_dps1', apply: () => { G.bioDPS = (G.bioDPS||0) + 0.25; } },
 { id:'bio_dps3',    cat:'permanent', name:'Organic Boost III', icon:'üí™', desc:'+40% DPS for all units (permanent)',          cost: 600,  max: 1, req:'bio_dps2', apply: () => { G.bioDPS = (G.bioDPS||0) + 0.40; } },
 { id:'bio_hp1',     cat:'permanent', name:'Thick Membrane I',  icon:'üõ°', desc:'+20% HP for all units (permanent)',           cost: 60,   max: 1, apply: () => { G.bioHP = (G.bioHP||0) + 0.20; } },
 { id:'bio_hp2',     cat:'permanent', name:'Thick Membrane II', icon:'üõ°', desc:'+35% HP for all units (permanent)',           cost: 200,  max: 1, req:'bio_hp1', apply: () => { G.bioHP = (G.bioHP||0) + 0.35; } },
 { id:'bio_gold1',   cat:'permanent', name:'Bio Synthesis',     icon:'‚öó', desc:'+20% gold from every wave (permanent)',       cost: 150,  max: 1, apply: () => { G.bioGold = (G.bioGold||0) + 0.20; } },
 { id:'bio_gold2',   cat:'permanent', name:'Advanced Synthesis',icon:'‚öó', desc:'+35% gold from every wave (permanent)',       cost: 400,  max: 1, req:'bio_gold1', apply: () => { G.bioGold = (G.bioGold||0) + 0.35; } },
 { id:'bio_merge1',  cat:'permanent', name:'Cell Division',     icon:'‚¨°', desc:'+15% chance for free merge (permanent)',      cost: 120,  max: 1, apply: () => { G.bioMerge = (G.bioMerge||0) + 0.15; } },
 { id:'bio_spawn1',  cat:'permanent', name:'Rapid Growth',      icon:'‚ö°', desc:'Units spawn 20% faster (permanent)',          cost: 180,  max: 1, apply: () => { G.bioSpawn = (G.bioSpawn||0) + 0.20; } },
 { id:'bio_elite1',  cat:'permanent', name:'Elite Strain',      icon:'‚≠ê', desc:'+10% chance for Elite unit on purchase',      cost: 350,  max: 1, apply: () => { G.bioElite = (G.bioElite||0) + 0.10; } },

 { id:'bio_buff_dps',   cat:'buff', name:'Adrenaline Surge', icon:'üî•', desc:'+50% DPS for the next 3 waves',                    cost: 40, max: 99, apply: () => { G.activeEffects.push({ id:'bio_adrenaline', waves:3, dpsMult:0.5, label:'üî• ADRENALINE +50%DPS' }); showNotif('üî• Adrenaline Surge! +50% DPS for 3 waves', '#fb923c'); } },
 { id:'bio_buff_shield',cat:'buff', name:'Bio Shield',       icon:'üõ°', desc:'Shield absorbs 40% HP for all units (1 wave)',      cost: 55, max: 99, apply: () => { if(arenaUnits?.length) arenaUnits.forEach(u => { u.shield = (u.shield||0) + u.maxHp * 0.4; }); showNotif('üõ° Bio Shield active!', '#5ac8fa'); } },
 { id:'bio_buff_gold',  cat:'buff', name:'Gold Rush',        icon:'üí∞', desc:'2√ó gold for the next 2 waves',                     cost: 70, max: 99, apply: () => { G.activeEffects.push({ id:'bio_goldrush', waves:2, goldMult:2.0, label:'üí∞ GOLD RUSH 2√ó' }); showNotif('üí∞ Gold Rush! 2√ó gold for 2 waves', '#ffd60a'); } },
 { id:'bio_buff_speed', cat:'buff', name:'Overdrive',        icon:'‚ö°', desc:'2√ó attack speed for 2 waves',                      cost: 60, max: 99, apply: () => { G.activeEffects.push({ id:'bio_overdrive', waves:2, speedMult:2.0, label:'‚ö° OVERDRIVE 2√óATK' }); if(arenaUnits?.length) arenaUnits.forEach(u => u.attackSpeed = (u.attackSpeed||1)*2); showNotif('‚ö° Overdrive! 2√ó attack for 2 waves', '#bf5af2'); } },
 { id:'bio_buff_heal',  cat:'buff', name:'Regeneration',     icon:'üíö', desc:'Instantly restore 50% HP to all units',             cost: 35, max: 99, apply: () => { if(arenaUnits?.length) arenaUnits.forEach(u => { u.hp = Math.min(u.maxHp, u.hp + u.maxHp * 0.5); }); showNotif('üíö Regeneration! +50% HP restored', '#4cd964'); } },
 { id:'bio_buff_mutant',cat:'buff', name:'Mutation Serum',   icon:'üß¨', desc:'A random grid unit becomes a Mutant',               cost: 90, max: 99, apply: () => {
  const eligible = grid.map((u,i)=>({u,i})).filter(({u})=>u && !u.mutant);
  if (!eligible.length) { showNotif('No units available to mutate!','#ff453a'); return; }
  const {u,i} = eligible[Math.floor(Math.random()*eligible.length)];
  u.mutant = true;
  // Aktualizuj te≈º arenaUnits je≈õli trwa walka
  const au = arenaUnits.find(a => a.gridIdx === i);
  if (au) {
   au.mutant = true;
   au.dps = Math.floor(au.dps * 2.2); // mutant bonus DPS
  }
  _lastGridFingerprint=''; renderGrid();
  showNotif('üß¨ Mutant created! T'+u.tier+' unit mutated!','#bf5af2');
 }},
];
let boughtBioShop = new Set();

function renderBioShop() {
 const el = document.getElementById('bioshop-list');
 if (!el) return;
 el.innerHTML = '';

 // Bio balance header
 const hdr = document.createElement('div');
 hdr.style.cssText = 'padding:8px 10px;font-family:Fredoka One,sans-serif;font-size:13px;color:#4cd964;border-bottom:1px solid rgba(76,217,100,0.2);margin-bottom:6px;display:flex;align-items:center;gap:6px;';
 hdr.innerHTML = `üß¨ <span>BIOMASS: <strong id="bio-shop-balance">${Math.floor(G.biomass)}</strong></span>`;
 el.appendChild(hdr);

 // Kategorie
 const cats = [
  { id:'permanent', label:'‚≠ê PERMANENT' },
  { id:'buff',      label:'‚ö° BUFFS (one-time use)' },
 ];

 cats.forEach(cat => {
  const items = BIO_SHOP.filter(i => i.cat === cat.id);
  const catHdr = document.createElement('div');
  catHdr.style.cssText = 'padding:4px 10px 2px;font-family:Fredoka One,sans-serif;font-size:10px;letter-spacing:1px;color:rgba(255,255,255,0.4);margin-top:4px;';
  catHdr.textContent = cat.label;
  el.appendChild(catHdr);

  items.forEach(item => {
   const owned = boughtBioShop.has(item.id) && item.max === 1;
   const reqMet = !item.req || boughtBioShop.has(item.req);
   const canAfford = G.biomass >= item.cost;
   const div = document.createElement('div');
   div.className = 'upgrade-item' + (owned ? ' bought' : canAfford && reqMet && !owned ? ' can-buy' : '') + (!reqMet ? ' locked' : '');

   div.innerHTML = `
    <div class="upgrade-icon">${item.icon}</div>
    <div class="upgrade-body">
     <div class="upgrade-name">${item.name}${owned ? ' ‚úì' : ''}</div>
     <div class="upgrade-desc">${item.desc}</div>
     <div class="upgrade-cost">
      <span class="cost-bio${canAfford ? '' : ' cant'}">üß¨ ${item.cost} BIO</span>
      ${!reqMet ? '<span style="font-size:9px;color:rgba(255,255,255,0.3)"> ¬∑ Unlock previous first</span>' : ''}
     </div>
    </div>
    <button class="btn-shop-buy${owned?' owned':''}${!canAfford&&!owned?' cant-afford':''}" ${owned||!reqMet?'disabled':''} onclick="buyBioShop('${item.id}')">
     ${owned ? '‚úì' : 'BUY'}
    </button>
   `;
   el.appendChild(div);
  });
 });
}

function buyBioShop(id) {
 const item = BIO_SHOP.find(i => i.id === id);
 if (!item) return;
 if (item.max === 1 && boughtBioShop.has(id)) return;
 if (item.req && !boughtBioShop.has(item.req)) { showNotif('Unlock the previous upgrade first!', '#ff453a'); return; }
 if (G.biomass < item.cost) { showNotif(`üß¨ Need ${item.cost} BIO!`, '#4cd964'); return; }
 G.biomass -= item.cost;
 if (item.max === 1) boughtBioShop.add(id);
 item.apply();
 updateCurrencies();
 _lastGridFingerprint = ''; // force grid visual update
 renderBioShop();
 saveGame();
 sfx.buy();
}


let activeResearch = null; 
let researchQueue = []; 
function startResearch(u) {
 if (boughtResearch.has(u.id) || !u.check()) return;
 if (G.research < (u.cost.research || 0)) {
 showNotif('Not enough Research Points!', 'var(--purple)'); return;
 }
 if (activeResearch) {
 if (researchQueue.find(q => q.id === u.id)) return;
 researchQueue.push(u);
 showNotif(`üî¨ Queued: ${u.name}`, 'var(--purple)');
 renderUpgrades();
 return;
 }
 G.research -= (u.cost.research || 0);
 activeResearch = { id: u.id, startTime: Date.now(), duration: RESEARCH_DURATION, u };
 updateCurrencies();
 showNotif(`üî¨ Research started: ${u.name} (2 min)`, 'var(--purple)');
 addLog(`Research: ${u.name} started (2 min)`, 'blue');
 sfx.merge(3);
 renderUpgrades();
 saveGame();
}
function tickResearch() {
 if (!activeResearch) return;
 const elapsed = (Date.now() - activeResearch.startTime) / 1000;
 if (elapsed >= activeResearch.duration) {
 const u = activeResearch.u;
 u.apply();
 boughtResearch.add(u.id);
 showNotif(`‚úÖ Research complete: ${u.name}!`, 'var(--green)');
 addLog(`Research complete: ${u.name}!`, 'gold');
 sfx.prestige();
 activeResearch = null;
 if (researchQueue.length > 0) {
 const next = researchQueue.shift();
 if (!boughtResearch.has(next.id) && next.check()) {
 if (G.research >= (next.cost.research || 0)) {
 G.research -= (next.cost.research || 0);
 activeResearch = { id: next.id, startTime: Date.now(), duration: RESEARCH_DURATION, u: next };
 showNotif(`üî¨ Research started: ${next.name}`, 'var(--purple)');
 } else {
 showNotif(`‚ùå Not enough RES for queued: ${next.name}`, '#ff6b6b');
 }
 }
 updateCurrencies();
 }
 renderUpgrades();
 saveGame();
 }
}
function getResearchProgress() {
 if (!activeResearch) return null;
 const elapsed = (Date.now() - activeResearch.startTime) / 1000;
 const pct = Math.min(1, elapsed / activeResearch.duration);
 const remaining = Math.max(0, activeResearch.duration - elapsed);
 return { pct, remaining, id: activeResearch.id, name: activeResearch.u.name };
}
function formatResearchTime(secs) {
 const m = Math.floor(secs / 60);
 const s = Math.floor(secs % 60);
 return `${m}:${s.toString().padStart(2,'0')}`;
}
function renderUpgrades() {
 const list = document.getElementById('upgrade-list');
 list.innerHTML = '';
 UPGRADES.forEach(u => {
 const purchased = boughtUpgrades.has(u.id); 
 const unlocked = u.check(); 
 const done = purchased || !unlocked; 
 const affordable = G.gold >= (u.cost.gold||0) && G.biomass >= (u.cost.bio||0);
 const canBuy = !done && affordable;
 const locked = !done && !affordable; 
 const div = document.createElement('div');
 div.className = 'upgrade-item'
 + (purchased ? ' bought' : '')
 + (!purchased && !unlocked ? ' tier-locked' : '')
 + (canBuy ? ' can-buy' : '')
 + (locked ? ' locked' : '');
 let costStr = '';
 if (u.cost.gold) costStr += `<span class="cost-gold${G.gold < (u.cost.gold||0) ? ' cant' : ''}">‚öó ${u.cost.gold}g</span> `;
 if (u.cost.bio) costStr += `<span class="cost-bio${G.biomass < (u.cost.bio||0) ? ' cant' : ''}">üß¨ ${u.cost.bio} BIO</span>`;
 const _ui = tUpgrade(UPGRADES.indexOf(u));
 div.innerHTML = `
 <div class="upgrade-icon">${u.icon||'üî¨'}</div>
 <div class="upgrade-body">
 <div class="upgrade-name">${purchased ? '‚úì ' : ''}${_ui ? _ui.name : u.name}</div>
 <div class="upgrade-desc">${_ui ? _ui.desc : u.desc}</div>
 <div class="upgrade-cost">${purchased
 ? "<span style='color:var(--dim);font-size:9px'>PURCHASED</span>"
 : !unlocked
 ? "<span style='color:var(--dim);font-size:9px'>üîí Buy previous tier first</span>"
 : costStr}</div>
 </div>`;
 if (canBuy) div.onclick = () => purchaseUpgrade(u);
 list.appendChild(div);
 });
 const rlist = document.getElementById('research-list');
 rlist.innerHTML = '';
 const prog = getResearchProgress();
 if (prog) {
 const pct = Math.round(prog.pct * 100);
 const bar = document.createElement('div');
 bar.className = 'research-active-bar';
 bar.innerHTML = `
 <div class="research-active-label">
 üî¨ <strong>${prog.name}</strong>
 <span class="research-timer">${formatResearchTime(prog.remaining)}</span>
 </div>
 <div class="research-progress-track">
 <div class="research-progress-fill" style="width:${pct}%"></div>
 </div>`;
 rlist.appendChild(bar);
 }
 if (researchQueue.length > 0) {
 const queueEl = document.createElement('div');
 queueEl.className = 'research-queue-label';
 queueEl.textContent = `üìã Queue: ${researchQueue.map(q => q.name).join(' ‚Üí ')}`;
 rlist.appendChild(queueEl);
 }
 RESEARCH_UPGRADES.forEach(u => {
 const bought = boughtResearch.has(u.id) || !u.check();
 const isActive = activeResearch?.id === u.id;
 const isQueued = researchQueue.some(q => q.id === u.id);
 const affordable2 = G.research >= (u.cost.research||0);
 const canStart = !bought && !isActive && !isQueued && affordable2;
 const canQueue = !bought && !isActive && !isQueued && activeResearch && affordable2;
 const div = document.createElement('div');
 div.className = 'upgrade-item research-item'
 + (bought ? ' bought' : '')
 + (isActive ? ' research-active-item' : '')
 + (isQueued ? ' research-queued' : '')
 + (!bought && !isActive && !isQueued && !affordable2 ? ' locked' : '')
 + (canStart && !activeResearch ? ' can-buy' : '');
 let statusHtml = '';
 if (bought) statusHtml = `<span class="res-badge res-done">‚úì DONE</span>`;
 else if (isActive) statusHtml = `<span class="res-badge res-running">‚è≥ IN PROGRESS</span>`;
 else if (isQueued) statusHtml = `<span class="res-badge res-queued">üìã QUEUED</span>`;
 else statusHtml = `<span class="cost-research${affordable2 ? '' : ' cant'}">üî¨ ${u.cost.research} RES</span>`;
 const _ri = tResearch(RESEARCH_UPGRADES.indexOf(u));
 div.innerHTML = `
 <div class="upgrade-icon">${u.icon||'üî¨'}</div>
 <div class="upgrade-body">
 <div class="upgrade-name">${bought?'‚úì ':''}${_ri ? _ri.name : u.name}</div>
 <div class="upgrade-desc">${_ri ? _ri.desc : u.desc}
 <span style="color:var(--dim);font-size:9px"> ¬∑ 2 min</span>
 </div>
 <div class="upgrade-cost">${statusHtml}</div>
 </div>`;
 if (!bought && !isActive && !isQueued) {
 div.onclick = () => startResearch(u);
 }
 rlist.appendChild(div);
 });
}
function purchaseUpgrade(u) {
 initAudio();
 if (!u.check()) return;
 if (G.gold < (u.cost.gold||0) || G.biomass < (u.cost.bio||0)) return;
 G.gold -= (u.cost.gold||0);
 G.biomass -= (u.cost.bio||0);
 u.apply();
 boughtUpgrades.add(u.id);
 addLog(t('logPurchased', tUpgrade(UPGRADES.indexOf(u))?.name || u.name), 'merge');
 showNotif(t('upgradeBought', tUpgrade(UPGRADES.indexOf(u))?.name || u.name), 'var(--blue)');
 sfx.merge(3);
 updateCurrencies();
 renderUpgrades();
 renderGrid();
}
function purchaseResearch(u) {
 initAudio();
 if (!u.check() || G.research < (u.cost.research||0)) return;
 G.research -= (u.cost.research||0);
 u.apply();
 boughtResearch.add(u.id);
 addLog(t('logResearch', tResearch(RESEARCH_UPGRADES.indexOf(u))?.name || u.name), 'merge');
 showNotif(t('researchBought', tResearch(RESEARCH_UPGRADES.indexOf(u))?.name || u.name), 'var(--purple)');
 sfx.merge(5);
 updateCurrencies();
 renderUpgrades();
}
function getPrestigeGain() {
 return Math.floor(5 + G.wave * 3 + G.kills * 0.12 + G.prestige * 2);
}
function doPrestige() {
 initAudio();
 if (G.wave < 5) { showNotif(t('reachWave5'), 'var(--pink)'); return; }
 const gain = getPrestigeGain();
 if (!confirm(`PRESTIGE?\n\n+${gain} Research Points (permanent)\n\nResets: gold, grid, wave, upgrades\nKeeps: research bonuses + prestige multiplier\n\nProceed?`)) return;
 promptLeaderboard();
 G.research += gain;
 G.prestige++;
 G.totalRuns++;
 if (G.wave > G.bestWave) G.bestWave = G.wave;
 if (G.kills > G.bestKills) G.bestKills = G.kills;
 G.gold = 30 + G.prestige * 15;
 G.biomass = 0;
 G.bioDPS = 0; G.bioHP = 0; G.bioGold = 0;
 G.bioMerge = 0; G.bioSpawn = 0; G.bioElite = 0;
 G.wave = 1;
 G.kills = 0;
 G.fighting = false;
 G.activeRelic = null;
 G.relicSeen = false;
 G.activeEffects = [];
 G.idleEfficiency = 0.06 + G.researchBonuses.offline_pct * 0.10;
 grid = Array(GRID_SIZE).fill(null);
 boughtUpgrades = new Set();
 boughtBioShop = new Set();
 _lastGridFingerprint = ''; // force full grid rebuild
 G.upgrades = { automerge_unlock: false, idle_boost: 0, merge_luck: 0, spawn_rate: 0, dps_boost: 0, start_tier: false };
 G.autoMerge = false;
 enemies = []; arenaUnits = []; particles = []; floatingDmg = [];
 if (animFrame) cancelAnimationFrame(animFrame);
 sfx.prestige();
 addLog(t('logPrestige', G.prestige, gain), 'wave');
 showNotif(`‚ö° PRESTIGE ${G.prestige}! +${gain} RESEARCH`, 'var(--purple)');
 document.getElementById('prestige-num').textContent = G.prestige;
 document.getElementById('wave-num').textContent = 1;
 document.getElementById('wave-label-full').textContent = t('waveLbl', 1);
 document.getElementById('btn-start').textContent = t('btnStartWave');
 document.getElementById('btn-start').className = 'btn-start';
 document.getElementById('btn-start').disabled = false;
 document.getElementById('btn-auto').className = 'btn btn-automerge';
 updateCurrencies();
 renderGrid();
 renderUpgrades();
 renderSynergyBar();
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 saveGame();
 setTimeout(showRelicPicker, 600);
}
function startIdleLoop() {
 setInterval(() => {
 if (G.totalDPS > 0 && !G.fighting) {
 const mult = x2Active ? 2 : 1;
 const earned = idleGoldPerSec() * mult;
 if (earned >= 0.1) {
 G.gold += earned;
 G.biomass += earned * 0.04;
 popCurrency('gold');
 updateCurrencies();
 renderUpgrades();
 }
 }
 if (G.fighting) applyRowSupportEffects();
 if (G.fighting) applyRowActiveEffects();
 }, 1000);
}
let popCooldown = {};
function popCurrency(name) {
 if (popCooldown[name]) return;
 popCooldown[name] = true;
 const el = document.querySelector(`.currency.${name}`);
 if (el) { el.classList.add('pop'); setTimeout(() => el.classList.remove('pop'), 320); }
 setTimeout(() => delete popCooldown[name], 1500);
}
function popSlime() { popCurrency('slime'); }
function checkIdleEarnings() {
 const now = Date.now();
 const offMs = now - (G.lastSave || now);
 if (offMs > 30000 && G.totalDPS > 0) {
 const secs = Math.min(offMs / 1000, 600); 
 const earned = Math.floor(idleGoldPerSec() * secs * 0.10); 
 if (earned > 0) {
 document.getElementById('idle-amount').textContent = `+${formatNum(earned)} GOLD`;
 document.getElementById('idle-popup').style.display = 'block';
 window._idleEarned = earned;
 }
 }
 G.lastSave = now;
}
function collectIdle() {
 G.gold += (window._idleEarned || 0);
 updateCurrencies();
 document.getElementById('idle-popup').style.display = 'none';
 window._idleEarned = 0;
}
// ‚îÄ‚îÄ LOG PANEL TOGGLE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _logCollapsed = false;
function toggleLogPanel() {
  const panel = document.getElementById('log-collapsible');
  const btn   = document.getElementById('log-toggle-btn');
  _logCollapsed = !_logCollapsed;
  panel.classList.toggle('collapsed', _logCollapsed);
  btn.textContent = _logCollapsed ? '‚ñº LOG' : '‚ñ≤ LOG';
}

function showWaveClearedBanner(wave, gold) {
  const el = document.getElementById('wave-cleared-banner');
  document.getElementById('wcb-wave-num').textContent = 'WAVE ' + wave;
  document.getElementById('wcb-gold').textContent = '+' + gold + ' GOLD';
  el.classList.remove('show');
  void el.offsetWidth; // reflow
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2400);
}

function showMergeLabHint() {
  // Utw√≥rz overlay je≈õli nie istnieje
  const existing = document.getElementById('lab-hint-overlay');
  if (existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'lab-hint-overlay';
  overlay.style.cssText = `
    position:fixed; inset:0; z-index:9500;
    background:rgba(0,0,0,0.75); backdrop-filter:blur(4px);
    display:flex; align-items:center; justify-content:center;
    animation: fadeIn 0.3s ease;
  `;

  overlay.innerHTML = `
    <div style="
      background: linear-gradient(135deg, rgba(20,10,50,0.98) 0%, rgba(30,15,70,0.98) 100%);
      border: 1px solid rgba(191,90,242,0.5);
      border-radius: 20px; padding: 32px 28px; max-width: 340px; width: 90%;
      box-shadow: 0 0 60px rgba(191,90,242,0.25), 0 20px 60px rgba(0,0,0,0.7);
      text-align:center; position:relative;
    ">
      <div style="font-size:48px; margin-bottom:12px; filter:drop-shadow(0 0 16px #bf5af2);">‚öó</div>
      <div style="
        font-family:'Fredoka One',sans-serif; font-size:22px; color:#bf5af2;
        letter-spacing:2px; margin-bottom:6px; text-shadow: 0 0 20px rgba(191,90,242,0.6);
      ">MERGE LAB UNLOCKED</div>
      <div style="
        font-size:11px; color:rgba(255,255,255,0.4); letter-spacing:2px;
        text-transform:uppercase; margin-bottom:16px;
      ">Special crafting system</div>
      <div style="
        font-size:13px; color:rgba(255,255,255,0.75); line-height:1.6;
        margin-bottom:20px; padding: 0 4px;
      ">
        Combine specific units to forge <strong style="color:#ffd700">legendary creatures</strong>
        with unique abilities ‚Äî like the <strong style="color:#ff6b35">Inferno Slug</strong>,
        <strong style="color:#4cd964">Bio Titan</strong> or
        <strong style="color:#5ac8fa">Mech Overlord</strong>.<br><br>
        Tap <strong style="color:#bf5af2">‚öó LAB</strong> to discover all recipes!
      </div>
      <div style="display:flex; gap:10px; justify-content:center;">
        <button onclick="document.getElementById('lab-hint-overlay').remove(); openMergeLab();" style="
          padding:12px 22px; border-radius:12px; border:none; cursor:pointer;
          background:linear-gradient(135deg,#bf5af2,#7c3aed);
          color:#fff; font-family:'Fredoka One',sans-serif; font-size:15px;
          letter-spacing:1px; box-shadow:0 4px 0 #5b21b6, 0 6px 20px rgba(191,90,242,0.4);
          transition:transform 0.1s;
        " onmousedown="this.style.transform='translateY(3px)'" onmouseup="this.style.transform=''">
          ‚öó OPEN LAB
        </button>
        <button onclick="document.getElementById('lab-hint-overlay').remove();" style="
          padding:12px 18px; border-radius:12px; border:1px solid rgba(255,255,255,0.15);
          cursor:pointer; background:rgba(255,255,255,0.05);
          color:rgba(255,255,255,0.5); font-family:'Fredoka One',sans-serif; font-size:13px;
          transition:all 0.15s;
        " onmouseover="this.style.background='rgba(255,255,255,0.1)'"
           onmouseout="this.style.background='rgba(255,255,255,0.05)'">
          Later
        </button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  sfx.prestige?.();
}

function showShareHint() {
  const existing = document.getElementById('share-hint-overlay');
  if (existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'share-hint-overlay';
  overlay.style.cssText = `
    position:fixed; inset:0; z-index:9500;
    background:rgba(0,0,0,0.75); backdrop-filter:blur(4px);
    display:flex; align-items:center; justify-content:center;
    animation: fadeIn 0.3s ease;
  `;

  overlay.innerHTML = `
    <div style="
      background: linear-gradient(135deg, rgba(15,8,40,0.98) 0%, rgba(25,12,60,0.98) 100%);
      border: 1px solid rgba(255,215,0,0.35);
      border-radius: 20px; padding: 32px 28px; max-width: 360px; width: 90%;
      box-shadow: 0 0 60px rgba(255,215,0,0.15), 0 20px 60px rgba(0,0,0,0.7);
      text-align:center; position:relative;
    ">
      <div style="font-size:52px; margin-bottom:12px; line-height:1;">üß¨</div>
      <div style="
        font-family:'Fredoka One',sans-serif; font-size:21px; color:#ffd700;
        letter-spacing:1.5px; margin-bottom:6px;
        text-shadow: 0 0 20px rgba(255,215,0,0.5);
      ">YOU REACHED WAVE ${G.wave - 1}!</div>
      <div style="
        font-size:11px; color:rgba(255,255,255,0.35); letter-spacing:2px;
        text-transform:uppercase; margin-bottom:18px;
      ">that's seriously impressive üëÄ</div>
      <div style="
        font-size:13.5px; color:rgba(255,255,255,0.8); line-height:1.7;
        margin-bottom:8px; padding: 0 4px;
      ">
        If you're enjoying <strong style="color:#ffd700">Slime Arena</strong>,
        we'd love to hear what you think! üí¨<br><br>
        Your feedback ‚Äî good or bad ‚Äî is genuinely
        <strong style="color:#4cd964">priceless</strong> to us.
        It shapes what gets built next.<br><br>
        <span style="color:rgba(255,255,255,0.45); font-size:12px;">
          Even just sharing it with one friend means the world üôè
        </span>
      </div>

      <div style="
        margin: 18px 0 22px;
        background: rgba(255,255,255,0.04);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px; padding: 14px 16px;
        font-size:12px; color:rgba(255,255,255,0.5); font-style:italic; line-height:1.5;
      ">
        "Reached wave 30 in Slime Arena! üß¨‚öîÔ∏è This game is unexpectedly addictive..."
        <br><span style="font-size:10px; opacity:0.5;">‚Äî suggested tweet / message üòÑ</span>
      </div>

      <div style="display:flex; flex-direction:column; gap:9px;">
        <button onclick="
          try { navigator.clipboard.writeText('I just reached Wave ${G.wave - 1} in Slime Arena! üß¨‚öîÔ∏è This game is unexpectedly addictive ‚Äî give it a try!'); }
          catch(e) {}
          this.textContent = '‚úì Copied to clipboard!';
          this.style.background = 'linear-gradient(135deg,#4cd964,#26a843)';
          setTimeout(() => document.getElementById('share-hint-overlay')?.remove(), 1800);
        " style="
          padding:13px 22px; border-radius:12px; border:none; cursor:pointer;
          background:linear-gradient(135deg,#ffd700,#f59e0b);
          color:#1a0a00; font-family:'Fredoka One',sans-serif; font-size:15px;
          letter-spacing:0.5px; box-shadow:0 4px 0 #b45309, 0 6px 20px rgba(255,215,0,0.3);
          transition:transform 0.1s;
        " onmousedown="this.style.transform='translateY(3px)'" onmouseup="this.style.transform=''">
          üìã Copy &amp; Share
        </button>
        <button onclick="document.getElementById('share-hint-overlay').remove();" style="
          padding:11px 18px; border-radius:12px;
          border:1px solid rgba(255,255,255,0.12);
          cursor:pointer; background:rgba(255,255,255,0.04);
          color:rgba(255,255,255,0.4); font-family:'Fredoka One',sans-serif; font-size:13px;
          transition:all 0.15s;
        " onmouseover="this.style.background='rgba(255,255,255,0.09)'"
           onmouseout="this.style.background='rgba(255,255,255,0.04)'">
          Maybe later ‚Äî back to slaying üó°
        </button>
      </div>
    </div>
  `;

  document.body.appendChild(overlay);
  overlay.addEventListener('click', e => { if (e.target === overlay) overlay.remove(); });
  sfx.prestige?.();
}

function formatNum(n) {
 n = Number(n);
 if (!isFinite(n) || isNaN(n)) return '0';
 n = Math.floor(n);
 if (n >= 1e9) return (n/1e9).toFixed(2) + 'B';
 if (n >= 1e6) return (n/1e6).toFixed(2) + 'M';
 if (n >= 1000) return (n/1000).toFixed(1) + 'K';
 return n.toString();
}
function updateCurrencies() {
 if (!isFinite(G.gold) || isNaN(G.gold)) G.gold = 0;
 if (!isFinite(G.biomass) || isNaN(G.biomass)) G.biomass = 0;
 if (!isFinite(G.research) || isNaN(G.research)) G.research = 0;
 document.getElementById('gold-val').textContent = formatNum(G.gold);
 document.getElementById('bio-val').textContent = formatNum(G.biomass);
 document.getElementById('res-val').textContent = formatNum(G.research);
 const sv = document.getElementById('slime-val');
 if (sv) sv.textContent = formatNum(G.slime || 0);
 document.getElementById('prestige-gain').textContent = getPrestigeGain();
 document.getElementById('btn-prestige').disabled = G.wave < 5;
 const bw = document.getElementById('stat-best-wave');
 const bk = document.getElementById('stat-best-kills');
 const br = document.getElementById('stat-runs');
 if (bw) bw.textContent = G.bestWave || '‚Äî';
 if (bk) bk.textContent = G.bestKills ? formatNum(G.bestKills) : '‚Äî';
 if (br) br.textContent = G.totalRuns || 0;
 updatePrestigeBar();
 renderActiveBuffs();
}
const BUFF_META = {
 crit_aura: { icon: '‚ú¶', label: 'CRIT AURA', desc: '+25% crit chance for all units', pl: 'AURA KRYTA' },
 meteor: { icon: '‚òÑ', label: 'METEOR', desc: 'Meteors hit enemies at wave start', pl: 'METEORY' },
 shield_wave: { icon: 'üõ°', label: 'BARRIER', desc: 'Units have a damage-absorbing shield', pl: 'BARIERA' },
 overclock: { icon: '‚öô', label: 'OVERCLOCK', desc: 'Attack speed +50%', pl: 'OVERCLOCK' },
 toxic_field: { icon: '‚ò†', label: 'TOXIC FIELD', desc: 'Enemies take 5 DOT/s', pl: 'POLE TRUCIZNY' },
};
function renderActiveBuffs() {
 const el = document.getElementById('active-buffs');
 if (!el) return;
 const items = [];
 G.activeEffects.forEach(e => {
 const m = BUFF_META[e.id];
 if (!m) return;
 items.push({ id: e.id, meta: m, waves: e.waves, permanent: false });
 });
 if (G.activeRelic) {
 const r = RELICS.find(r => r.id === G.activeRelic);
 if (r) {
 const rMeta = tRelic(RELICS.indexOf(r));
 items.push({
 id: 'relic_' + G.activeRelic,
 meta: { icon: '‚öó', label: (rMeta?.name || r.name).replace(/^[\S]+ /, ''), desc: rMeta?.desc || r.desc },
 waves: null, permanent: true
 });
 }
 }
 const existingIds = new Set([...el.querySelectorAll('.buff-chip')].map(c => c.dataset.id));
 const newIds = new Set(items.map(i => i.id));
 el.querySelectorAll('.buff-chip').forEach(chip => {
 if (!newIds.has(chip.dataset.id)) chip.remove();
 });
 items.forEach((item, idx) => {
 let chip = el.querySelector(`.buff-chip[data-id="${item.id}"]`);
 if (chip) {
 if (!item.permanent) {
 const waveEl = chip.querySelector('.buff-chip-waves');
 if (waveEl) waveEl.textContent = item.waves + 'W';
 const ttSpan = chip.querySelector('.buff-tooltip span:last-child');
 if (ttSpan) ttSpan.textContent = `‚è± ${item.waves} wave${item.waves !== 1 ? 's' : ''} remaining`;
 }
 } else {
 const wavesLabel = item.permanent
 ? `<span class="buff-chip-waves" style="background:rgba(191,90,242,0.3);color:#e879f9">‚àû RUN</span>`
 : `<span class="buff-chip-waves">${item.waves}W</span>`;
 const tooltipDesc = item.permanent
 ? `<strong>${item.meta.label}</strong><br>${item.meta.desc}<br><span style="color:#e879f9;font-size:9px">‚ú¶ Active for entire run</span>`
 : `<strong>${item.meta.label}</strong><br>${item.meta.desc}<br><span style="color:rgba(255,255,255,0.45);font-size:9px">‚è± ${item.waves} wave${item.waves !== 1 ? 's' : ''} remaining</span>`;
 const colorClass = item.permanent ? '' : `buff-${item.id}`;
 const permStyle = item.permanent ? 'background:rgba(191,90,242,0.1);border-color:rgba(191,90,242,0.4);color:#e879f9;' : '';
 chip = document.createElement('div');
 chip.className = `buff-chip ${colorClass} new-buff`;
 chip.dataset.id = item.id;
 chip.dataset.tooltip = tooltipDesc;
 chip.setAttribute('style', permStyle);
 chip.innerHTML = `
 <span class="buff-chip-icon">${item.meta.icon}</span>
 <span class="buff-chip-name">${item.meta.label}</span>
 ${wavesLabel}`;
 el.appendChild(chip);
 chip.addEventListener('animationend', () => chip.classList.remove('new-buff'), { once: true });
 }
 });
}
(function() {
 const TT = document.getElementById('buff-global-tooltip');
 const TT_W = 200; 
 document.addEventListener('mouseover', e => {
 const chip = e.target.closest('.buff-chip[data-tooltip]');
 if (!chip) return;
 TT.innerHTML = chip.dataset.tooltip;
 const r = chip.getBoundingClientRect();
 TT.style.opacity = '0';
 TT.style.visibility = 'hidden';
 TT.classList.add('visible'); 
 const ttH = TT.offsetHeight;
 TT.classList.remove('visible');
 TT.style.visibility = '';
 let left = r.left + r.width / 2 - TT_W / 2;
 let top = r.top - ttH - 8;
 if (top < 8) top = r.bottom + 8;
 left = Math.max(8, Math.min(left, window.innerWidth - TT_W - 8));
 TT.style.left = left + 'px';
 TT.style.top = top + 'px';
 TT.classList.add('visible');
 });
 document.addEventListener('mouseout', e => {
 const chip = e.target.closest('.buff-chip[data-tooltip]');
 if (!chip) return;
 TT.classList.remove('visible');
 });
})();
function addLog(msg, type) {
 const log = document.getElementById('battle-log');
 const div = document.createElement('div');
 div.className = 'log-' + type;
 div.textContent = '> ' + msg;
 log.appendChild(div);
 if (log.children.length > 60) log.removeChild(log.firstChild);
 log.scrollTop = log.scrollHeight;
}
const _notifQueue = [];
function showNotif(msg, color = 'var(--green)') {
 let area = document.getElementById('notif-area');
 if (!area) {
  area = document.createElement('div');
  area.id = 'notif-area';
  const arena = document.getElementById('panel-arena') || document.body;
  arena.appendChild(area);
 }
 const el = document.createElement('div');
 el.className = 'notif';
 el.style.cssText = `border-color:${color};color:${color};`;
 el.textContent = msg;
 area.appendChild(el);
 setTimeout(() => { el.remove(); }, 2300);
}
function switchTab(name) {
 if (name === 'upgrades' && itutActive && ITUT_STEPS[itutStepIdx]?.wait === 'upgrade_tab') {
 itutUpgradeTabClicked = true;
 }
 document.querySelectorAll('.tab').forEach((t, i) => {
 t.classList.toggle('active',
  (i===0 && name==='upgrades') ||
  (i===1 && name==='research') ||
  (i===2 && name==='bioshop'));
 });
 document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
 document.getElementById('tab-' + name).classList.add('active');
 if (name === 'bioshop') renderBioShop();
}
// ‚îÄ‚îÄ SAVE KEY VERSIONING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Key contains version - new game version = new save slot
// BUT: old save is auto-migrated on first run
// Player keeps progress, developer can test fresh
const GAME_VERSION  = '0.23';
const SAVE_KEY      = 'sal_v023';          // Slime Arena Lab v0.23
const SAVE_KEYS_OLD = ['auto_arena_v3', 'auto_arena_v2', 'auto_arena_v1'];

let _memSave = null;
function _storageAvailable(type) {
 try {
   const s = window[type];
   const test = '__aa_test__';
   s.setItem(test, '1');
   s.removeItem(test);
   return true;
 } catch(e) { return false; }
}
const _hasLocal   = _storageAvailable('localStorage');
const _hasSession = _storageAvailable('sessionStorage');

function _saveRaw(json) {
 _memSave = json;
 if (_hasLocal)   { try { localStorage.setItem(SAVE_KEY, json); } catch(e) {} }
 else if (_hasSession) { try { sessionStorage.setItem(SAVE_KEY, json); } catch(e) {} }
}

function _loadRaw() {
 // 1. Check current key (sal_v023)
 if (_hasLocal)   { try { const r = localStorage.getItem(SAVE_KEY);   if (r) return r; } catch(e) {} }
 if (_hasSession) { try { const r = sessionStorage.getItem(SAVE_KEY); if (r) return r; } catch(e) {} }

 // 2. Migrate from old keys -> move player save to new key
 if (_hasLocal) {
   for (const oldKey of SAVE_KEYS_OLD) {
     try {
       const old = localStorage.getItem(oldKey);
       if (old) {
         // Move to new key and delete old
         localStorage.setItem(SAVE_KEY, old);
         localStorage.removeItem(oldKey);
         console.log('[SAL] Save migrated from', oldKey, '‚Üí', SAVE_KEY);
         return old;
       }
     } catch(e) {}
   }
 }

 return _memSave;
}

function _deleteRaw() {
 _memSave = null;
 if (_hasLocal) {
   try {
     localStorage.removeItem(SAVE_KEY);
     SAVE_KEYS_OLD.forEach(k => localStorage.removeItem(k));
   } catch(e) {}
 }
 if (_hasSession) { try { sessionStorage.removeItem(SAVE_KEY); } catch(e) {} }
}
function _updateSaveIndicator(ok) {
 const el = document.getElementById('save-indicator');
 if (!el) return;
 if (!_hasLocal && !_hasSession) {
 el.textContent = t('savesMemOnly');
 el.style.color = '#fbbf24';
 } else if (ok) {
 el.textContent = t('saved');
 el.style.color = 'rgba(255,255,255,0.25)';
 clearTimeout(el._t);
 el._t = setTimeout(() => { el.textContent = ''; }, 3000);
 }
}
let _cheatClicks = 0, _cheatTimer = null;
function _cheatClickCount() {
  _cheatClicks++;
  clearTimeout(_cheatTimer);
  if (_cheatClicks >= 10) {
    _cheatClicks = 0;
    toggleCheatPanel();
  } else {
    _cheatTimer = setTimeout(() => { _cheatClicks = 0; }, 5000);
  }
}
function toggleCheatPanel() {
 document.getElementById('cheat-panel').classList.toggle('open');
}
function cheatGodMode() {
  _godMode = !_godMode;
  const btn = document.getElementById('cheat-god-btn');
  if (_godMode) {
    btn.textContent = 'GOD ON';
    btn.style.background = 'linear-gradient(135deg,#ff4444,#aa0000)';
    btn.style.color = '#fff';
    btn.style.border = '1px solid #ff4444';
  } else {
    btn.textContent = 'GOD OFF';
    btn.style.background = 'rgba(255,68,68,0.2)';
    btn.style.color = '#ff8888';
    btn.style.border = '1px solid rgba(255,68,68,0.5)';
  }
  showNotif(_godMode ? '‚ò† GOD MODE ON ‚Äî immortal!' : '‚ò† God Mode OFF', _godMode ? '#ff4444' : 'var(--dim)');
}
function cheatGold(amount) {
 G.gold += amount;
 updateCurrencies();
 showNotif('+' + formatNum(amount) + ' GOLD', 'var(--yellow)');
}
function cheatBio(amount) {
 G.biomass += amount;
 updateCurrencies();
 showNotif('+' + amount + ' BIOMASS', 'var(--green)');
}
function cheatRes(amount) {
 G.research += amount;
 updateCurrencies();
 renderUpgrades();
 showNotif('+' + amount + ' RESEARCH', '#818cf8');
}
function cheatSkipWave(count) {
 count = count || 1;
 if (G.fighting) { showNotif('Finish current wave first!', 'var(--pink)'); return; }
 G.wave = Math.min(G.wave + count, G.wave + count);
 document.getElementById('wave-num').textContent = G.wave;
 const btn = document.getElementById('btn-start');
 const boss = isBossWave(G.wave), nm = isNightmareWave(G.wave);
 btn.className = 'btn-start' + (nm ? ' nightmare-wave' : boss ? ' boss-wave' : '');
 btn.textContent = nm ? t('btnNightmare', G.wave) : boss ? t('btnBossWave', G.wave) : t('btnWave', G.wave);
 document.getElementById('wave-label-full').textContent = nm ? 'NIGHTMARE WAVE ' + G.wave : boss ? t('bossWaveLbl', G.wave) : t('waveLbl', G.wave);
 showNotif('WAVE skipped to ' + G.wave, 'var(--blue)');
 addLog('[DEV] Wave skipped to ' + G.wave, 'wave');
}
function cheatFillGrid() {
 if (G.fighting) { showNotif('Finish current wave first!', 'var(--pink)'); return; }
 for (let i = 0; i < GRID_SIZE; i++) {
  const playable = G.activeRelic === 'fortress' ? i < 12 : isSlotPlayable(i);
  if (playable && !grid[i]) grid[i] = { tier: 1, mutant: false };
 }
 renderGrid(); updateCurrencies();
 showNotif('Grid filled with T1 blobs!', 'var(--green)');
}
function cheatMaxAll() {
 G.gold += 999999;
 G.biomass += 9999;
 G.research += 9999;
 updateCurrencies();
 renderUpgrades();
 showNotif('MAX OUT - all resources added!', 'var(--yellow)');
}
function saveGame() {
 if (window.__resetInProgress) return;
 try {
 const json = JSON.stringify({
 G, grid,
 boughtUpgrades: [...boughtUpgrades],
 boughtResearch: [...boughtResearch],
 boughtBioShop: [...boughtBioShop],
 shopOwned, activeSkin,
 slime: G.slime,
 activeResearch: activeResearch ? {
 id: activeResearch.id,
 startTime: activeResearch.startTime,
 duration: activeResearch.duration
 } : null,
 researchQueue: researchQueue.map(u => u.id),
 _wm: atob('RXN0ZWxJVF9kZDc1NzFhMzA2MjA='),
 _copy: atob('wqkgMjAyNSBFc3RlbCBJVCBNYXRldXN6IFJ1c25hay4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTklQOiA2MzIyMDM4OTUx'),
 _v: '0.23'
 });
 _saveRaw(json);
 _updateSaveIndicator(true);
 } catch(e) {}
}
function loadGame() {
 try {
 const raw = _loadRaw();
 if (!raw) return;
 const data = JSON.parse(raw);
 if (data._wm && !data._wm.startsWith('EstelIT')) {
 console.warn('Save data from unknown source ‚Äî possible tampering');
 }
 Object.assign(G, data.G);
 G.activeRelic = G.activeRelic ?? null;
 G.relicSeen = G.relicSeen ?? false;
 G.activeEffects = G.activeEffects ?? [];
 G.synergyBonuses = G.synergyBonuses ?? {};
 G.lives = G.lives ?? LIVES_MAX;
 G.livesLastRegen = G.livesLastRegen ?? [0, 0, 0];
 getLivesState(); // od≈õwie≈º regeneracjƒô po przerwie offline
 G.fighting = false;
 G.waveStartedWithUnits = false;
 grid = data.grid;
 boughtUpgrades = new Set(data.boughtUpgrades || []);
 boughtResearch = new Set(data.boughtResearch || []);
 boughtBioShop  = new Set(data.boughtBioShop  || []);
 if (data.shopOwned) Object.assign(shopOwned, data.shopOwned);
 if (data.slime !== undefined) G.slime = data.slime; else G.slime = G.slime || 0;
 if (data.activeResearch) {
 const ru = RESEARCH_UPGRADES.find(u => u.id === data.activeResearch.id);
 if (ru && !boughtResearch.has(ru.id)) {
 activeResearch = { id: ru.id, startTime: data.activeResearch.startTime, duration: data.activeResearch.duration, u: ru };
 }
 }
 if (data.researchQueue) {
 researchQueue = data.researchQueue
 .map(id => RESEARCH_UPGRADES.find(u => u.id === id))
 .filter(u => u && !boughtResearch.has(u.id));
 }
 if (data.activeSkin) { activeSkin = data.activeSkin; applySkin(activeSkin); }
 _lastGridFingerprint = ''; // force full grid rebuild after load
 if (data.shopOwned) Object.assign(shopOwned, data.shopOwned);
 document.getElementById('wave-num').textContent = G.wave;
 document.getElementById('wave-label-full').textContent = isNightmareWave(G.wave) ? `üíÄ NIGHTMARE WAVE ${G.wave}` : isBossWave(G.wave) ? t('bossWaveLbl', G.wave) : t('waveLbl', G.wave);
 if (shopOwned.speed2x) document.getElementById('btn-speed').style.borderColor = 'var(--purple)';
 const btn = document.getElementById('btn-start');
 btn.disabled = false;
 btn.className = 'btn-start' + (isNightmareWave(G.wave) ? ' nightmare-wave' : isBossWave(G.wave) ? ' boss-wave' : '');
 btn.textContent = isNightmareWave(G.wave) ? t('btnNightmare', G.wave) : isBossWave(G.wave) ? t('btnBossWave', G.wave) : t('btnWave', G.wave);
 document.getElementById('wave-timer').textContent = '‚Äî';
 document.getElementById('wave-timer').className = 'wave-timer';
 if (G.tutorialSeen) document.getElementById('tutorial-overlay').classList.remove('visible');
 addLog(`Save loaded. [${_hasLocal ? 'localStorage' : _hasSession ? 'sessionStorage' : 'memory'}]`, 'wave');
 } catch(e) { addLog('Save load failed: ' + e.message, 'dmg'); }
}
setInterval(saveGame, 12000);
const FLAVOUR = {
 kill: [
 'nomnom.', 'dissolved.', 'eliminated.', 'splattered.', 'vaporized.',
 'consumed.', 'deleted.', 'neutralized.', 'gone.', 'oops.',
 ],
 blobKill: ['BLOB smashes!', 'BLOB hungry!', 'Slimy end.'],
 spitterKill: ['SPITTER scores!', 'Long-range deletion.', 'Spit and forget.'],
 splitterKill:['SPLITTER divides!', 'Mitosis of doom.', 'Two for one.'],
 magnetKill: ['MAGNET attracted it too close.', 'Resistance is futile.', 'Pulled apart.'],
 reactorKill: ['REACTOR goes nuclear!', 'Chain reaction!', 'Meltdown confirmed.'],
 anomalyKill: ['ANOMALY glitches reality.', 'ERROR: enemy removed.', 'Physics optional.'],
 wave: [
 'The experiment escalates.', 'They keep coming.', 'Lab containment failing.',
 'Subjects growing restless.', 'Another wave breached the perimeter.',
 ],
 merge: [
 'Evolution in progress.', 'Biomass restructured.', 'Tier acquired.',
 'Growing stronger.', 'The lab hums with power.',
 ],
};
function flavour(key) {
 const arr = FLAVOUR[key];
 if (!arr || !arr.length) return '';
 return arr[Math.floor(Math.random() * arr.length)];
}
function unitFlavourKey(tier) {
 return ['','blobKill','spitterKill','splitterKill','magnetKill','reactorKill','anomalyKill'][tier] || 'kill';
}
function triggerWinScreen() {
 const screen = document.getElementById('win-screen');
 document.getElementById('ws-kills').textContent = formatNum(G.kills);
 document.getElementById('ws-gold').textContent = formatNum(G.gold);
 document.getElementById('ws-res').textContent = getPrestigeGain();
 screen.classList.add('visible');
 sfx.prestige();
 ambientTransition('win');
 addLog(`‚ïî‚ïê‚ïê WAVE ${G.wave - 1} CLEARED! CONTAINMENT BREACH! ‚ïê‚ïê‚ïó`, 'boss');
}
function winPrestige() {
 document.getElementById('win-screen').classList.remove('visible');
 doPrestige();
}
function winContinue() {
 document.getElementById('win-screen').classList.remove('visible');
 G.wave = 1;
 G.prestige++;
 G.totalRuns++;
 G.kills = 0;
 enemies = []; arenaUnits = []; particles = []; floatingDmg = [];
 if (animFrame) cancelAnimationFrame(animFrame);
 showNotif('NEW CYCLE BEGINS ‚Äî ENEMIES EVOLVED', 'var(--orange)');
 addLog(`--- NEW CYCLE √ó${G.prestige} ‚Äî enemies are stronger ---`, 'boss');
 document.getElementById('prestige-num').textContent = G.prestige;
 document.getElementById('wave-num').textContent = 1;
 document.getElementById('wave-label-full').textContent = t('waveLbl', 1);
 document.getElementById('wave-timer').textContent = '‚Äî';
 document.getElementById('wave-timer').className = 'wave-timer';
 
 
 document.getElementById('enemy-count').textContent = t('enemies', 0);
 const btn = document.getElementById('btn-start');
 btn.className = 'btn-start';
 btn.textContent = '‚ñ∂ WAVE 1';
 btn.disabled = false;
 document.getElementById('btn-auto').className = 'btn btn-automerge' + (G.autoMerge ? ' active' : '');
 ambientTransition('idle');
 updateCurrencies();
 renderGrid();
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 drawArena();
 saveGame();
}
const REWARD_CD = { bio: 0, gold: 0, res: 0 };
const REWARD_CD_SEC = { bio: 120, gold: 180, res: 300 };
let x2Active = false, x2Timer = 0;
function rewardBio() {
 if (REWARD_CD.bio > 0) return;
 const amount = Math.floor(30 + G.wave * 3 + G.prestige * 10);
 G.biomass += amount;
 showNotif(`üß¨ +${amount} BIOMASS!`, 'var(--green)');
 addLog(`Ad reward: +${amount} Biomass`, 'merge');
 sfx.merge(2);
 updateCurrencies();
 popCurrency('bio');
 REWARD_CD.bio = REWARD_CD_SEC.bio;
 updateRewardButtons();
 startRewardCooldown('bio');
 saveGame();
}
function rewardGold() {
 if (REWARD_CD.gold > 0) return;
 const amount = Math.max(1, Math.floor(waveGoldReward(G.wave || 1) * 3));
 G.gold = (G.gold || 0) + amount;
 showNotif(`‚öó +${formatNum(amount)} GOLD!`, 'var(--yellow)');
 addLog(`Ad reward: +${formatNum(amount)} Gold`, 'gold');
 sfx.merge(3);
 updateCurrencies();
 popCurrency('gold');
 REWARD_CD.gold = REWARD_CD_SEC.gold;
 updateRewardButtons();
 startRewardCooldown('gold');
 saveGame();
}
function rewardRes() {
 if (REWARD_CD.res > 0) return;
 const amount = Math.floor(2 + G.prestige * 1.5);
 G.research += amount;
 showNotif(`üî¨ +${amount} RESEARCH!`, 'var(--purple)');
 addLog(`Ad reward: +${amount} Research`, 'blue');
 sfx.prestige();
 updateCurrencies();
 popCurrency('research');
 REWARD_CD.res = REWARD_CD_SEC.res;
 updateRewardButtons();
 startRewardCooldown('res');
 saveGame();
}
function startRewardCooldown(key) {
 const interval = setInterval(() => {
 REWARD_CD[key] = Math.max(0, REWARD_CD[key] - 1);
 updateRewardButtons();
 if (REWARD_CD[key] <= 0) clearInterval(interval);
 }, 1000);
}
function fmtCD(secs) {
 if (secs <= 0) return 'watch ad';
 const m = Math.floor(secs / 60), s = secs % 60;
 return m > 0 ? `${m}m ${s}s cooldown` : `${s}s cooldown`;
}
function updateRewardButtons() {
 const bioBtn = document.getElementById('rwd-bio');
 const goldBtn = document.getElementById('rwd-gold');
 const resBtn = document.getElementById('rwd-res');
 if (bioBtn) {
 bioBtn.disabled = REWARD_CD.bio > 0;
 document.getElementById('rwd-bio-cd').textContent =
 REWARD_CD.bio > 0 ? fmtCD(REWARD_CD.bio) : `+${Math.floor(30 + G.wave * 3 + G.prestige * 10)} BIO`;
 }
 if (goldBtn) {
 goldBtn.disabled = REWARD_CD.gold > 0;
 document.getElementById('rwd-gold-cd').textContent =
 REWARD_CD.gold > 0 ? fmtCD(REWARD_CD.gold) : `+${formatNum(Math.floor(waveGoldReward(G.wave) * 3))} G`;
 }
 if (resBtn) {
 resBtn.disabled = REWARD_CD.res > 0;
 document.getElementById('rwd-res-cd').textContent =
 REWARD_CD.res > 0 ? fmtCD(REWARD_CD.res) : `+${Math.floor(2 + G.prestige * 1.5)} RES`;
 }
}
setInterval(() => {
 tickResearch();
 if (activeResearch) renderUpgrades();
 tickLivesRegen();
 if (x2Active) {
 x2Timer--;
 if (x2Timer <= 0) {
 x2Active = false;
 x2Timer = 0;
 showNotif('2√ó INCOME ENDED', 'var(--dim)');
 addLog('2√ó income expired.', 'dmg');
 }
 updateRewardButtons();
 updateX2Banner();
 }
}, 1000);
function resetSave() {
 if (!confirm('RESET ALL PROGRESS?\n\nThis deletes everything permanently.\nNo undo.')) return;
 window.__resetInProgress = true;

 // Keep only premium (Slime, skins, shop)
 const _savedSlime = G.slime || 0; // Slime stays - premium currency

 // Clear ALL storage keys
 _memSave = null;
 if (_hasLocal) {
   try {
     [SAVE_KEY, ...SAVE_KEYS_OLD].forEach(k => localStorage.removeItem(k));
   } catch(e) {}
 }
 if (_hasSession) { try { sessionStorage.removeItem(SAVE_KEY); } catch(e) {} }

 if (animFrame) cancelAnimationFrame(animFrame);
 animFrame = null;

 Object.assign(G, {
   gold: 80, biomass: 0, research: 0, slime: _savedSlime,
   bioDPS: 0, bioHP: 0, bioGold: 0, bioMerge: 0, bioSpawn: 0, bioElite: 0,
   wave: 1, prestige: 0, kills: 0, totalDPS: 0,
   idleEfficiency: 0.30,
   autoMerge: false, fighting: false,
   waveTime: 0, waveMaxTime: 30, bossSpawning: false,
   lastSave: Date.now(),
   bestWave: 1, bestKills: 0, totalRuns: 0,
   tutorialSeen: false, relicSeen: false,
   activeRelic: null, activeEffects: [],
   synergyBonuses: {},
   upgrades: { automerge_unlock: false, idle_boost: 0, merge_luck: 0,
     spawn_rate: 0, dps_boost: 0, start_tier: false,
     gold_boost: 0, hp_boost: 0, elite_chance: 0, mass_merge: false },
   researchBonuses: { merge_chance: 0, offline_pct: 0, mutation_chance: 0,
     spawn_rate_res: 0, gold_mult: 0, dps_research: 0,
     elite_res: 0, blob_hp: 0, wave_speed: 0, prestige_boost: 0 },
 });

 grid = Array(GRID_SIZE).fill(null);
 enemies = []; arenaUnits = []; particles = []; floatingDmg = [];
 boughtUpgrades = new Set();
 boughtResearch  = new Set();
 activeResearch  = null;
 researchQueue   = [];

 shopOwned  = { noads: false, speed2x: false, skins: false, slots4: false, slots8: false };
 _lastGridFingerprint = '';
 activeSkin = 'neon';

 gameSpeed = 1; x2Active = false; x2Timer = 0;
 REWARD_CD.bio = 0; REWARD_CD.gold = 0; REWARD_CD.res = 0;

 grid[0] = { tier: 1, mutant: false };
 grid[1] = { tier: 1, mutant: false };

 window.__resetInProgress = false;
 applySkin(''); // reset to default skin
 saveGame(); // save clean state
 updateSpeedBtn();
 document.getElementById('prestige-num').textContent = '0';
 document.getElementById('wave-num').textContent = '1';
 document.getElementById('wave-label-full').textContent = t('waveLbl', 1);
 document.getElementById('wave-timer').textContent = '‚Äî';
 document.getElementById('wave-timer').className = 'wave-timer';
 
 
 document.getElementById('enemy-count').textContent = 'ENEMIES: 0';
 document.getElementById('pill-kills').textContent = 'KILLS: 0';
 document.getElementById('pill-kills').className = 'stat-pill';
 const btn = document.getElementById('btn-start');
 btn.textContent = '‚ñ∂ WAVE 1';
 btn.className = 'btn-start';
 btn.disabled = false;
 document.getElementById('btn-auto').className = 'btn btn-automerge';
 document.getElementById('lose-screen').classList.remove('visible');
 document.getElementById('win-screen').classList.remove('visible');
 document.getElementById('relic-overlay').classList.remove('open');
 document.getElementById('event-overlay').classList.remove('open');
 const logEl = document.getElementById('battle-log');
 if (logEl) logEl.innerHTML = '';
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 updateCurrencies();
 renderGrid();
 renderUpgrades();
 renderSynergyBar();
 updateRewardButtons();
 drawArena();
 ambientTransition('idle');
 addLog(t('logSaveReset'), 'wave');
 showNotif(t('saveWiped'), 'var(--green)');
 initDailyChallenge();
 document.getElementById('tutorial-overlay').classList.add('visible');

 shopOwned = { noads: false, speed2x: false, skins: false, slots4: false, slots8: false };
 activeSkin = 'neon';
 window.__resetInProgress = false;
 applySkin('');
 saveGame();
}
let ambientNodes = [];
let ambientMode = 'idle';
let ambientRunning = false;
let ambientBeat = 0;
let melodyPhrase = 0;
let padChord = 0;
const AMBIENT_CFG = {
 idle: { bpm: 88, feel: 'bouncy', melody: [523,587,659,784,880,1047,1175], bass: [130,165,196,261], pad: [[261,329,392],[220,277,330],[196,247,294],[174,220,261]], percVol: 0.02 },
 battle: { bpm: 128, feel: 'urgent', melody: [294,330,370,440,494,587,659], bass: [73,98,110,147], pad: [[294,370,440],[261,330,392],[277,349,415],[220,277,330]], percVol: 0.04 },
 boss: { bpm: 140, feel: 'intense', melody: [164,196,220,247,294,330,392], bass: [41,55,65,82], pad: [[164,196,247],[146,185,220],[123,155,185],[110,138,165]], percVol: 0.06 },
 win: { bpm: 100, feel: 'triumphant',melody: [392,440,494,523,587,659,784,880],bass: [98,130,165,196], pad: [[392,494,587],[330,415,494],[349,440,523],[261,329,392]], percVol: 0.025 },
};
const MELODY_PATTERNS = {
 bouncy: [0,2,4,2,3,5,4,2, 0,2,4,6,5,4,3,1],
 urgent: [0,0,2,3,2,4,3,2, 5,4,3,2,4,3,2,0],
 intense: [0,2,4,2,0,5,4,3, 2,4,6,5,4,2,1,0],
 triumphant:[0,2,4,6,7,6,4,2, 3,5,7,5,3,1,0,2],
};
function stopAmbient() { ambientRunning = false; }
function startAmbient() {}
function ambientTransition(mode) {}
function scheduleAmbientBeat(cfg) {}
function scheduleAmbientMelody(cfg) {}
function scheduleAmbientPad(cfg) {}
const FREE_SPEEDS = [1, 2, 4, 6];
const PAID_SPEEDS = [8, 10];
function toggleSpeed() {
 if (itutActive) itutSpeedClicked = true;
 const allSpeeds = shopOwned.speed2x
 ? [...FREE_SPEEDS, ...PAID_SPEEDS]
 : FREE_SPEEDS;
 const idx = allSpeeds.indexOf(gameSpeed);
 gameSpeed = allSpeeds[(idx + 1) % allSpeeds.length];
 updateSpeedBtn();
 sfx.tick();
}
function updateSpeedBtn() {
 const btn = document.getElementById('btn-speed');
 if (!btn) return;
 btn.textContent = gameSpeed + '√ó';
 if (gameSpeed >= 8) {
 btn.className = 'btn-speed ultra';
 } else if (gameSpeed >= 4) {
 btn.className = 'btn-speed fast';
 } else if (gameSpeed >= 2) {
 btn.className = 'btn-speed fast';
 btn.style.borderColor = 'var(--green)';
 btn.style.color = 'var(--green)';
 btn.style.boxShadow = '0 0 10px rgba(57,255,20,0.3)';
 } else {
 btn.className = 'btn-speed';
 btn.style.borderColor = '';
 btn.style.color = '';
 btn.style.boxShadow = '';
 }
}
function getUnlockedSlots() {
 if (shopOwned.slots8) return 20;
 if (shopOwned.slots4) return 16;
 return 12;
}
function isSlotPlayable(i) {
 // Bazowe 12 slot√≥w (FRONT + MID A + MID B) zawsze wolne
 if (i < 12) return true;
 // BACK rzƒÖd (idx 12-15): pierwsze 2 zawsze wolne, pozosta≈Çe wymagajƒÖ slots4
 if (i === 12 || i === 13) return true;
 if (i === 14 || i === 15) return !!(shopOwned.slots4 || shopOwned.slots8);
 // SUPPORT rzƒÖd (idx 16-19): pierwsze 2 zawsze wolne, pozosta≈Çe wymagajƒÖ slots8
 if (i === 16 || i === 17) return true;
 if (i === 18 || i === 19) return !!shopOwned.slots8;
 return false;
}
function applyStarterPack() {
 if (!shopOwned.starter) return;
 const key = 'starterApplied';
 if (localStorage.getItem(key)) return;
 G.gold += 5000;
 G.biomass += 200;
 G.research += 50;
 localStorage.setItem(key, '1');
 updateCurrencies();
}
function applyGoldPack() {
 if (!shopOwned.goldpack) return;
 const key = 'goldpackApplied';
 if (localStorage.getItem(key)) return;
 G.gold += 50000;
 localStorage.setItem(key, '1');
 updateCurrencies();
}
const SHOP_PRICES = {
 noads: 100,
 speed2x: 250,
 skins: 350,
 slots4: 80,
 slots8: 150,
};
function openShop(tab) {
 document.getElementById('shop-overlay').classList.add('open');
 renderShop();
 switchShopTab(tab || 'lab');
 sfx.tick();
}
function closeShop() {
 document.getElementById('shop-overlay').classList.remove('open');
}
function renderShop() {
 const ownedIds = ['noads','speed2x','skins','slots4','slots8'];
 ownedIds.forEach(id => {
 const btn = document.getElementById('btn-shop-' + id);
 if (!btn) return;
 const price = SHOP_PRICES[id] || 0;
 if (shopOwned[id]) {
 btn.textContent = '‚úì OWNED';
 btn.classList.add('owned');
 btn.classList.remove('cant-afford');
 } else if (G.slime < price) {
 btn.classList.add('cant-afford');
 btn.classList.remove('owned');
 } else {
 btn.classList.remove('cant-afford', 'owned');
 }
 });
 const sel = document.getElementById('skin-selector');
 if (sel) sel.style.display = shopOwned.skins ? 'block' : 'none';
 document.querySelectorAll('.skin-btn').forEach(b => {
 b.classList.toggle('active', b.dataset.skin === activeSkin);
 });
 if (shopOwned.slots8) {
 const s4 = document.getElementById('btn-shop-slots4');
 if (s4) { s4.textContent = '‚úì OWNED'; s4.classList.add('owned'); }
 }
 ['shop-slime-balance','shop-lab-balance'].forEach(id => {
 const el = document.getElementById(id);
 if (el) el.textContent = formatNum(G.slime);
 });
 renderGrid();
}
function switchShopTab(tab) {
 document.querySelectorAll('.shop-tab-btn').forEach(b => b.classList.remove('active'));
 document.querySelectorAll('.shop-tab-pane').forEach(p => p.classList.remove('active'));
 const btn = document.getElementById('stab-' + tab);
 const pane = document.getElementById('spane-' + tab);
 if (btn) btn.classList.add('active');
 if (pane) pane.classList.add('active');
}
function shopBuy(id) {
 if (shopOwned[id]) return;
 const price = SHOP_PRICES[id] || 0;
 G.slime = G.slime || 0;
 if (G.slime < price) {
 showNotif(`üß™ Need ${price} Slime! Buy more in the Slime Shop.`, '#5ac8fa');
 switchShopTab('slime');
 return;
 }
 const names = {
 noads: 'No Ads', speed2x: 'Ultra Speed', skins: 'Mutation Skins',
 slots4: '+4 Grid Slots', slots8: 'Full Grid (20 slots)',
 };
 const msgs = {
 noads: 'üö´ Ads removed! Enjoy the lab.',
 speed2x: '‚ö° 8√ó and 10√ó speed unlocked!',
 skins: 'üé® Skin pack unlocked ‚Äî choose a theme!',
 slots4: 'üîì 4 extra slots unlocked (12‚Üí16)!',
 slots8: 'üîì Full grid unlocked (12‚Üí20)!',
 };
 G.slime -= price;
 shopOwned[id] = true;
 if (id === 'slots8') shopOwned.slots4 = true;
 if (id === 'speed2x') updateSpeedBtn();
 updateCurrencies();
 showNotif('üõí ' + msgs[id], 'var(--purple)');
 addLog('Lab Store: ' + names[id] + ' purchased!', 'gold');
 sfx.prestige();
 renderShop();
 if (id === 'slots4' || id === 'slots8') { _lastGridFingerprint = ''; renderGrid(true); }
 saveGame();
}
function buySlimePack(packId) {
 const packs = {
 small: { slime: 100, label: 'Small Vial', price: '$0.99' },
 medium: { slime: 300, label: 'Lab Flask', price: '$2.49' },
 large: { slime: 700, label: 'Mega Barrel', price: '$4.99' },
 mega: { slime: 1600, label: 'MEGA Bundle', price: '$9.99' },
 };
 const pack = packs[packId];
 if (!pack) return;
 G.slime += pack.slime;
 updateCurrencies();
 popCurrency('slime');
 showNotif(`üß™ +${pack.slime} Slime added!`, '#5ac8fa');
 addLog(`Slime Pack: ${pack.label} (+${pack.slime} Slime)`, 'blue');
 sfx.prestige();
 renderShop();
 saveGame();
}
function updatePrestigeBar() {
 const pct = Math.min(100, ((G.wave - 1) / 99) * 100);
 const bar = document.getElementById('prestige-bar');
 const lbl = document.getElementById('prestige-wave-progress');
 if (bar) bar.style.width = pct + '%';
 if (lbl) lbl.textContent = G.wave;
}
function updateX2Banner() {
 const banner = document.getElementById('x2-banner');
 const display = document.getElementById('x2-timer-display');
 if (!banner || !display) return;
 if (x2Active) {
 banner.classList.add('active');
 const m = Math.floor(x2Timer / 60);
 const s = x2Timer % 60;
 display.textContent = `${m}:${s.toString().padStart(2,'0')}`;
 } else {
 banner.classList.remove('active');
 }
}
function showRelicPicker() {
 const shuffled = [...RELICS].sort(() => Math.random()-0.5).slice(0, 3);
 const el = document.getElementById('relic-cards');
 el.innerHTML = '';
 shuffled.forEach(r => {
 const card = document.createElement('div');
 card.className = 'relic-card';
 const _rel = tRelic(RELICS.indexOf(r));
 const _rname = _rel ? _rel.name : r.name;
 const _rdesc = _rel ? _rel.desc : r.desc;
 card.innerHTML = `<div class="relic-card-name">${_rname}</div><div class="relic-card-desc">${_rdesc}</div>`;
 card.onclick = () => { chooseRelic(r.id); };
 el.appendChild(card);
 });
 document.getElementById('relic-overlay').classList.add('open');
}
function chooseRelic(id) {
 G.activeRelic = id;
 G.relicSeen = true;
 G.relicUpgradeLevel = 0;
 setTimeout(renderRelicUpgrade, 300);
 document.getElementById('relic-overlay').classList.remove('open');
 const r = RELICS.find(r => r.id === id);
 showNotif(t('relicChosen', tRelic(RELICS.indexOf(r))?.name || r.name), 'var(--green)');
 addLog(t('logRelic', tRelic(RELICS.indexOf(r))?.name || r.name, tRelic(RELICS.indexOf(r))?.desc || r.desc), 'merge');
 renderGrid();
 updateCurrencies();
 sfx.prestige();
 if (!G.tutorialSeen) {
 setTimeout(itutStart, 800);
 }
}
function showWaveEventPopup() {
 if (G.fighting) return; 
 const shuffled = [...WAVE_EVENTS].sort(() => Math.random()-0.5).slice(0, 3);
 const el = document.getElementById('event-cards');
 el.innerHTML = '';
 shuffled.forEach(ev => {
 const card = document.createElement('div');
 card.className = 'event-card';
 card.dataset.id = ev.id;
 const _ev = tEvent(WAVE_EVENTS.indexOf(ev));
 const durLabel = (() => {
 if (ev.id === 'gold_rain' || ev.id === 'elite' || ev.id === 'regen_pulse') {
 return `<span class="event-duration instant">‚ö° INSTANT</span>`;
 }
 const waveCount = ev.id === 'crit_aura' ? 3 : ev.id === 'overclock' ? 2 : ev.id === 'toxic_field' ? 2 : 1;
 return `<span class="event-duration waves">‚è± ${waveCount} WAVE${waveCount > 1 ? 'S' : ''}</span>`;
 })();
 card.innerHTML = `
 <div class="event-card-name">${_ev ? _ev.name : ev.name}</div>
 <div class="event-card-desc">${_ev ? _ev.desc : ev.desc}</div>
 ${durLabel}
 `;
 card.onclick = () => {
 const evSfx = {
 shield_wave: 'eventShield',
 regen_pulse: 'eventRegen',
 gold_rain: 'eventGold',
 crit_aura: 'eventCrit',
 overclock: 'eventOverclock',
 toxic_field: 'eventToxic',
 elite: 'eventElite',
 meteor: 'eventMeteor',
 };
 const sfxName = evSfx[ev.id];
 if (sfxName && sfx[sfxName]) sfx[sfxName]();
 else sfx.merge(3);
 ev.apply();
 renderActiveBuffs(); 
 closeEventPopup();
 addLog(`Event chosen: ${ev.name}`, 'wave');
 spawnEventVFX(ev.id);
 };
 el.appendChild(card);
 });
 document.getElementById('event-overlay').classList.add('open');
}
function closeEventPopup() {
 document.getElementById('event-overlay').classList.remove('open');
}
function spawnEventVFX(eventId) {
 const vfx = document.getElementById('event-vfx');
 if (!vfx) return;
 const arena = document.getElementById('panel-arena');
 vfx.width = arena.offsetWidth || 600;
 vfx.height = arena.offsetHeight || 400;
 vfx.style.display = 'block';
 const ctx = vfx.getContext('2d');
 const W = vfx.width, H = vfx.height;
 const configs = {
 shield_wave: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const bars = 8;
 for (let i = 0; i < bars; i++) {
 const progress = Math.max(0, Math.min(1, (t - i * 0.06) * 1.8));
 if (progress <= 0) continue;
 const y = (H / bars) * (i + 0.5);
 const w = W * progress;
 const alpha = (1 - progress) * 0.55 + 0.1;
 const grad = ctx.createLinearGradient(0, y, w, y);
 grad.addColorStop(0, `rgba(200,220,255,${alpha * 0.3})`);
 grad.addColorStop(0.7, `rgba(220,235,255,${alpha})`);
 grad.addColorStop(1, `rgba(255,255,255,0)`);
 ctx.fillStyle = grad;
 ctx.fillRect(0, y - 18, w, 36);
 if (progress < 0.98) {
 ctx.fillStyle = `rgba(255,255,255,${(1-progress)*0.9})`;
 ctx.fillRect(w - 4, y - 20, 4, 40);
 }
 }
 if (t > 0.7) {
 const flashA = Math.max(0, (1 - (t-0.7)/0.5) * 0.18);
 ctx.fillStyle = `rgba(180,210,255,${flashA})`;
 ctx.fillRect(0,0,W,H);
 }
 }, dur: 1400
 },
 regen_pulse: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const rings = 5;
 for (let i = 0; i < rings; i++) {
 const phase = (t * 1.4 - i * 0.18);
 if (phase < 0) continue;
 const r = phase * Math.max(W, H) * 0.65;
 const alpha = Math.max(0, 0.5 - phase * 0.5);
 ctx.strokeStyle = `rgba(74,222,128,${alpha})`;
 ctx.lineWidth = 3 - phase * 1.5;
 ctx.shadowColor = '#4ade80';
 ctx.shadowBlur = 14;
 ctx.beginPath();
 ctx.arc(W*0.5, H*0.5, r, 0, Math.PI*2);
 ctx.stroke();
 }
 ctx.shadowBlur = 0;
 const seed = Math.floor(t * 30);
 for (let i = 0; i < 20; i++) {
 const st = (i / 20);
 if (t < st) continue;
 const age = t - st;
 const sx = ((i * 137.5 + 50) % W);
 const sy = H - age * H * 1.1;
 const sa = Math.max(0, 0.7 - age * 1.1);
 ctx.fillStyle = `rgba(74,222,128,${sa})`;
 ctx.shadowColor = '#4ade80'; ctx.shadowBlur = 8;
 ctx.beginPath();
 ctx.arc(sx, sy, 3 + Math.sin(i)*2, 0, Math.PI*2);
 ctx.fill();
 }
 ctx.shadowBlur = 0;
 }, dur: 1600
 },
 gold_rain: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const coins = 28;
 for (let i = 0; i < coins; i++) {
 const delay = (i / coins) * 0.5;
 const age = Math.max(0, t - delay);
 if (age <= 0) continue;
 const x = ((i * 73 + 40) % (W - 40)) + 20;
 const fall = age * age * H * 2.2;
 const y = Math.min(H - 12, fall);
 const alpha = Math.max(0, 1 - Math.max(0, age - 0.7) * 3);
 const size = 6 + (i % 4) * 3;
 ctx.fillStyle = `rgba(251,191,36,${alpha})`;
 ctx.strokeStyle = `rgba(255,220,50,${alpha})`;
 ctx.lineWidth = 1.5;
 ctx.shadowColor = '#fbbf24'; ctx.shadowBlur = 10;
 ctx.beginPath();
 ctx.ellipse(x, y, size, size * 0.72, 0, 0, Math.PI*2);
 ctx.fill(); ctx.stroke();
 ctx.fillStyle = `rgba(255,255,255,${alpha*0.5})`;
 ctx.shadowBlur = 0;
 ctx.beginPath();
 ctx.ellipse(x - size*0.25, y - size*0.2, size*0.28, size*0.15, -0.4, 0, Math.PI*2);
 ctx.fill();
 }
 ctx.shadowBlur = 0;
 const tint = Math.min(t * 2, 1) * Math.max(0, 1 - (t-0.3)*1.5);
 if (tint > 0) {
 ctx.fillStyle = `rgba(251,191,36,${tint * 0.12})`;
 ctx.fillRect(0,0,W,H);
 }
 }, dur: 1800
 },
 crit_aura: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const cx = W*0.5, cy = H*0.5;
 const bolts = 12;
 for (let i = 0; i < bolts; i++) {
 const phase = (t * 2.2 + i * 0.15) % 1.0;
 const angle = (Math.PI*2/bolts)*i + t*0.8;
 const len = (60 + (i%3)*40) * phase;
 const alpha = (1-phase) * 0.8;
 ctx.strokeStyle = `rgba(251,113,133,${alpha})`;
 ctx.lineWidth = 1.5 + (1-phase)*1.5;
 ctx.shadowColor = '#fb7185'; ctx.shadowBlur = 12;
 ctx.beginPath();
 ctx.moveTo(cx, cy);
 let bx = cx, by = cy;
 const segs = 4;
 for (let s = 0; s < segs; s++) {
 const prog = (s+1)/segs;
 const jitter = (Math.random()-0.5)*20*(1-prog);
 bx = cx + Math.cos(angle)*len*prog + jitter;
 by = cy + Math.sin(angle)*len*prog + jitter;
 ctx.lineTo(bx, by);
 }
 ctx.stroke();
 }
 ctx.shadowBlur = 0;
 const coreR = 18 + Math.sin(t*20)*6;
 const coreA = 0.6 * Math.min(1, t*3) * Math.max(0, 1-(t-0.7)*3);
 const cg = ctx.createRadialGradient(cx, cy, 0, cx, cy, coreR*2);
 cg.addColorStop(0, `rgba(255,200,200,${coreA})`);
 cg.addColorStop(0.5, `rgba(251,113,133,${coreA*0.6})`);
 cg.addColorStop(1, 'transparent');
 ctx.fillStyle = cg;
 ctx.beginPath(); ctx.arc(cx, cy, coreR*2, 0, Math.PI*2); ctx.fill();
 }, dur: 1500
 },
 overclock: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const lines = 20;
 for (let i = 0; i < lines; i++) {
 const y = (H/lines) * i + (H/lines)*0.5;
 const speed = 0.6 + (i%3)*0.4;
 const x = ((t * W * speed * 2.5) % (W + 300)) - 150;
 const len = 40 + (i%5)*30;
 const alpha = 0.15 + (i%4)*0.12;
 const grad = ctx.createLinearGradient(x-len, y, x, y);
 grad.addColorStop(0, 'transparent');
 grad.addColorStop(1, `rgba(96,165,250,${alpha})`);
 ctx.fillStyle = grad;
 ctx.fillRect(x-len, y-2, len, 4);
 }
 const cx = W*0.5, cy = H*0.5;
 const teeth = 8, gR = 30 + Math.sin(t*8)*3;
 const spin = t * Math.PI * 4;
 ctx.strokeStyle = `rgba(96,165,250,${0.7 * Math.min(1,t*4) * Math.max(0,1-(t-0.6)*3)})`;
 ctx.lineWidth = 3;
 ctx.shadowColor = '#60a5fa'; ctx.shadowBlur = 18;
 ctx.beginPath();
 for (let k = 0; k < teeth*2; k++) {
 const a = (Math.PI/teeth)*k + spin;
 const r = k%2===0 ? gR : gR*0.7;
 k===0 ? ctx.moveTo(cx+Math.cos(a)*r, cy+Math.sin(a)*r)
 : ctx.lineTo(cx+Math.cos(a)*r, cy+Math.sin(a)*r);
 }
 ctx.closePath(); ctx.stroke();
 ctx.shadowBlur = 0;
 }, dur: 1400
 },
 toxic_field: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const drips = 10;
 for (let i = 0; i < drips; i++) {
 const x = ((i*97 + 30) % (W-40)) + 20;
 const delay = i * 0.08;
 const age = Math.max(0, t - delay);
 const len = age * H * 0.7;
 const alpha = Math.max(0, 0.6 - age*0.4);
 const grad = ctx.createLinearGradient(x, 0, x, len);
 grad.addColorStop(0, `rgba(163,230,53,${alpha})`);
 grad.addColorStop(1, `rgba(163,230,53,0)`);
 ctx.strokeStyle = grad;
 ctx.lineWidth = 2 + (i%3);
 ctx.shadowColor = '#a3e635'; ctx.shadowBlur = 8;
 ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, len); ctx.stroke();
 if (age > 0.1) {
 ctx.fillStyle = `rgba(163,230,53,${alpha*1.4})`;
 ctx.beginPath();
 ctx.arc(x, Math.min(len, H*0.65), 4+i%3, 0, Math.PI*2);
 ctx.fill();
 }
 }
 ctx.shadowBlur = 0;
 for (let i = 0; i < 18; i++) {
 const bx = ((i*83+20) % (W-40)) + 20;
 const bAge = Math.max(0, t - i*0.07);
 const by = H - bAge * H * 0.9;
 const ba = Math.max(0, 0.5 - bAge*0.45);
 const br = 3 + (i%4)*2;
 ctx.fillStyle = `rgba(163,230,53,${ba})`;
 ctx.shadowColor = '#a3e635'; ctx.shadowBlur = 6;
 ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2); ctx.fill();
 }
 ctx.shadowBlur = 0;
 const ta = Math.min(t*2,1)*Math.max(0,1-(t-0.4)*1.8)*0.1;
 ctx.fillStyle = `rgba(100,180,20,${ta})`;
 ctx.fillRect(0,0,W,H);
 }, dur: 1800
 },
 elite: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const cx = W*0.5, cy = H*0.5;
 const rays = 16;
 const maxLen = Math.max(W,H) * 0.75;
 for (let i = 0; i < rays; i++) {
 const angle = (Math.PI*2/rays)*i + t*0.3;
 const prog = Math.min(1, t*2.2);
 const fade = Math.max(0, 1-(t-0.4)*1.6);
 const len = maxLen * prog;
 const alpha = fade * 0.35;
 if (alpha <= 0) continue;
 ctx.strokeStyle = `rgba(251,191,36,${alpha})`;
 ctx.lineWidth = 3 - prog*1.5;
 ctx.shadowColor = '#fbbf24'; ctx.shadowBlur = 14;
 ctx.beginPath();
 ctx.moveTo(cx, cy);
 ctx.lineTo(cx + Math.cos(angle)*len, cy + Math.sin(angle)*len);
 ctx.stroke();
 }
 ctx.shadowBlur = 0;
 const crownY = Math.min(cy, t * cy * 2.5);
 const crownA = Math.min(1, t*3) * Math.max(0, 1-(t-0.65)*3);
 if (crownA > 0) {
 ctx.font = `${48 + Math.sin(t*6)*4}px serif`;
 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
 ctx.globalAlpha = crownA;
 ctx.shadowColor = '#fbbf24'; ctx.shadowBlur = 24;
 ctx.fillText('üëë', cx, crownY);
 ctx.shadowBlur = 0;
 ctx.globalAlpha = 1;
 }
 const ringR = t * Math.max(W,H) * 0.6;
 const ringA = Math.max(0, 0.6 - t*0.8);
 ctx.strokeStyle = `rgba(255,220,80,${ringA})`;
 ctx.lineWidth = 6;
 ctx.shadowColor = '#fbbf24'; ctx.shadowBlur = 20;
 ctx.beginPath(); ctx.arc(cx, cy, ringR, 0, Math.PI*2); ctx.stroke();
 ctx.shadowBlur = 0;
 }, dur: 1600
 },
 meteor: {
 draw(t) {
 ctx.clearRect(0,0,W,H);
 const meteors = 5;
 for (let i = 0; i < meteors; i++) {
 const delay = i * 0.14;
 const age = Math.max(0, t - delay);
 if (age <= 0) continue;
 const startX = W * 0.1 + (i * W*0.18);
 const startY = -60;
 const endX = startX - 80;
 const endY = H + 60;
 const prog = Math.min(1, age * 1.6);
 const mx = startX + (endX-startX)*prog;
 const my = startY + (endY-startY)*prog;
 const alpha = prog < 0.8 ? 1 : 1-(prog-0.8)*5;
 if (alpha <= 0) continue;
 const tLen = 90 + i*20;
 const grad = ctx.createLinearGradient(mx+tLen*0.6, my-tLen*0.6, mx, my);
 grad.addColorStop(0, 'transparent');
 grad.addColorStop(0.6, `rgba(251,146,60,${alpha*0.4})`);
 grad.addColorStop(1, `rgba(255,255,200,${alpha*0.9})`);
 ctx.strokeStyle = grad;
 ctx.lineWidth = 5 + i%3;
 ctx.shadowColor = '#f97316'; ctx.shadowBlur = 18;
 ctx.beginPath();
 ctx.moveTo(mx + tLen*0.6, my - tLen*0.6);
 ctx.lineTo(mx, my);
 ctx.stroke();
 ctx.fillStyle = `rgba(255,230,150,${alpha})`;
 ctx.shadowColor = '#fff'; ctx.shadowBlur = 14;
 ctx.beginPath();
 ctx.arc(mx, my, 7+i%3, 0, Math.PI*2);
 ctx.fill();
 }
 ctx.shadowBlur = 0;
 if (t > 0.75) {
 const fa = Math.max(0, (1 - (t-0.75)/0.4) * 0.22);
 ctx.fillStyle = `rgba(255,140,50,${fa})`;
 ctx.fillRect(0,0,W,H);
 }
 }, dur: 1700
 },
 };
 const cfg = configs[eventId] || configs.elite;
 const startTime = performance.now();
 const dur = cfg.dur;
 function frame(now) {
 const t = Math.min(1, (now - startTime) / dur);
 cfg.draw(t);
 if (t < 1) {
 requestAnimationFrame(frame);
 } else {
 ctx.clearRect(0,0,W,H);
 vfx.style.display = 'none';
 }
 }
 requestAnimationFrame(frame);
}
const LIVES_MAX = 3;
const LIVES_REGEN_MS = 5 * 60 * 1000; // 5 minut

function getLivesState() {
 const now = Date.now();
 // Sprawd≈∫ czy jakie≈õ ≈ºycia siƒô odrodzi≈Çy
 if (!G.livesLastRegen) G.livesLastRegen = [0, 0, 0];
 if (G.lives === undefined) G.lives = LIVES_MAX;
 // Odn√≥w ≈ºycia kt√≥re minƒô≈Çy 20 minut
 while (G.lives < LIVES_MAX) {
  const oldest = G.livesLastRegen.filter(t => t > 0).sort((a,b) => a-b)[0];
  if (oldest && now - oldest >= LIVES_REGEN_MS) {
   G.lives++;
   G.livesLastRegen[G.livesLastRegen.indexOf(oldest)] = 0;
  } else break;
 }
 return G.lives;
}

function consumeLife() {
 if (!G.livesLastRegen) G.livesLastRegen = [0, 0, 0];
 G.lives = Math.max(0, (G.lives ?? LIVES_MAX) - 1);
 // Zapisz timestamp utraty ≈ºycia
 const slot = G.livesLastRegen.indexOf(0);
 if (slot !== -1) G.livesLastRegen[slot] = Date.now();
 saveGame();
}

function updateLivesDisplay() {
 getLivesState(); // od≈õwie≈º regeneracjƒô
 const lives = G.lives ?? LIVES_MAX;
 const now = Date.now();

 // Header serduszka
 const headerLives = document.getElementById('header-lives');
 if (headerLives) {
  headerLives.innerHTML = '';
  for (let i = 0; i < LIVES_MAX; i++) {
   const s = document.createElement('span');
   s.textContent = i < lives ? '‚ù§Ô∏è' : 'üñ§';
   s.style.opacity = i < lives ? '1' : '0.3';
   s.style.fontSize = '13px';
   headerLives.appendChild(s);
  }
 }

 // Lose screen serduszka
 for (let i = 0; i < LIVES_MAX; i++) {
  const el = document.getElementById(`lose-life-${i}`);
  if (!el) continue;
  if (i < lives) {
   el.textContent = '‚ù§Ô∏è'; el.className = 'life-heart';
  } else {
   el.textContent = 'üñ§'; el.className = 'life-heart empty';
  }
 }

 // TRY AGAIN przycisk ‚Äî zawsze aktywny, tekst zale≈ºny od ≈ºyƒá
 const retryBtn = document.getElementById('btn-lose-retry');
 const noLivesMsg = document.getElementById('lose-no-lives-msg');
 if (lives > 0) {
  if (retryBtn) { retryBtn.disabled = false; retryBtn.textContent = `‚Ü∫ CONTINUE (${lives} ‚ù§Ô∏è)`; retryBtn.style.opacity = '1'; }
  if (noLivesMsg) noLivesMsg.style.display = 'none';
 } else {
  if (retryBtn) { retryBtn.disabled = false; retryBtn.textContent = '‚Ü∫ RESET (Wave 1)'; retryBtn.style.opacity = '0.8'; }
  if (noLivesMsg) {
   noLivesMsg.style.display = 'block';
   const timestamps = (G.livesLastRegen || []).filter(t => t > 0).sort((a,b) => a-b);
   if (timestamps.length > 0) {
    const msLeft = Math.max(0, LIVES_REGEN_MS - (now - timestamps[0]));
    const m = Math.floor(msLeft / 60000);
    const s = Math.floor((msLeft % 60000) / 1000);
    const nextEl = document.getElementById('lose-next-regen');
    if (nextEl) nextEl.textContent = `${m}:${String(s).padStart(2,'0')}`;
   }
  }
 }
}

function tickLivesRegen() {
 if (!document.getElementById('lose-screen')?.classList.contains('visible')) return;
 updateLivesDisplay();
}

function triggerLoseScreen() {
 consumeLife();
 document.getElementById('ls-wave').textContent = G.wave;
 document.getElementById('ls-wave-max').textContent = Math.max(G.bestWave || 1, G.wave);
 document.getElementById('ls-kills').textContent = formatNum(G.kills);
 document.getElementById('ls-gold').textContent = formatNum(G.gold);
 document.getElementById('ls-res').textContent = getPrestigeGain();
 const reviveCost = Math.max(10, Math.floor(20 + G.wave * 3));
 const costEl = document.getElementById('lose-revive-cost');
 if (costEl) costEl.textContent = `${reviveCost} SLM`;
 const reviveBtn = document.getElementById('btn-lose-revive');
 if (reviveBtn) reviveBtn.disabled = G.slime < reviveCost;
 updateLivesDisplay();
 document.getElementById('lose-screen').classList.add('visible');
 sfx.waveEnd(false);
 ambientTransition('idle');
 addLog(`‚ïî‚ïê‚ïê WIPEOUT on wave ${G.wave}! All units lost. ‚ïê‚ïê‚ïó`, 'boss');
}
function loseRetry() {
 getLivesState();
 const hasLife = (G.lives ?? LIVES_MAX) > 0;
 document.getElementById('lose-screen').classList.remove('visible');
 G.fighting = false;
 enemies = []; arenaUnits = []; particles = []; floatingDmg = [];
 if (animFrame) cancelAnimationFrame(animFrame);

 if (hasLife) {
  // ‚îÄ‚îÄ CONTINUE ‚Äî zostaje na tej samej fali, grid zachowany ‚îÄ‚îÄ
  const btn = document.getElementById('btn-start');
  btn.textContent = isBossWave(G.wave) ? t('btnBossWave', G.wave) : t('btnWave', G.wave);
  btn.className = 'btn-start' + (isBossWave(G.wave) ? ' boss-wave' : '');
  btn.disabled = false;
  document.getElementById('wave-timer').textContent = '‚Äî';
  document.getElementById('wave-timer').className = 'wave-timer';
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawArena();
  renderGrid();
  updateCurrencies();
  updateLivesDisplay();
  addLog(`‚ù§Ô∏è Continue! Wave ${G.wave} ‚Äî life used (${G.lives} left).`, 'wave');
  sfx.buy();
 } else {
  // ‚îÄ‚îÄ FULL RESET ‚Äî brak ≈ºyƒá ‚îÄ‚îÄ
  const _savedSlime    = G.slime || 0;
  const _savedPrestige = G.prestige || 0;
  const _savedBest     = G.bestWave || 1;
  const _savedBestK    = G.bestKills || 0;
  const _savedRuns     = (G.totalRuns || 0) + 1;
  const _savedLivesRegen = G.livesLastRegen ?? [0,0,0];
  G.gold = 60; G.biomass = 0; G.research = 0;
  G.bioDPS = 0; G.bioHP = 0; G.bioGold = 0;
  G.bioMerge = 0; G.bioSpawn = 0; G.bioElite = 0;
  G.slime = _savedSlime;
  G.wave = 1; G.kills = 0; G.prestige = _savedPrestige;
  G.bestWave = _savedBest; G.bestKills = _savedBestK;
  G.totalRuns = _savedRuns;
  G.lives = 0; G.livesLastRegen = _savedLivesRegen;
  G.activeEffects = []; G.activeRelic = null;
  G.autoMerge = false; G.relicSeen = false;
  G.upgrades = { automerge_unlock:0, merge_luck:0, dps_boost:0, hp_boost:0,
    start_tier:0, idle_gold:0, idle_gold2:0, idle_gold3:0,
    spawn_rate:0, spawn_rate2:0, spawn_rate3:0, offline_earn:0, offline_earn2:0 };
  G.researchBonuses = { spawn_rate_res:0, gold_mult:0, dps_research:0 };
  boughtUpgrades = new Set();
  boughtResearch  = new Set();
  boughtBioShop   = new Set();
  researchQueue   = [];
  activeResearch  = null;
  grid = Array(GRID_SIZE).fill(null);
  grid[0] = { tier: 1, mutant: false };
  grid[1] = { tier: 1, mutant: false };
  document.getElementById('btn-auto').className = 'btn btn-automerge';
  const btn = document.getElementById('btn-start');
  btn.textContent = t('btnWave', 1);
  btn.className = 'btn-start';
  btn.disabled = false;
  document.getElementById('wave-num').textContent = 1;
  document.getElementById('wave-timer').textContent = '‚Äî';
  document.getElementById('wave-timer').className = 'wave-timer';
  document.getElementById('wave-label-full').textContent = t('waveLbl', 1);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawArena();
  renderGrid();
  updateCurrencies();
  updateLivesDisplay();
  addLog('‚Ü∫ No lives left ‚Äî full reset to Wave 1.', 'wave');
  sfx.buy();
 }
}
function losePrestige() {
 document.getElementById('lose-screen').classList.remove('visible');
 doPrestige();
}
function loseRevive() {
 const reviveCost = Math.max(10, Math.floor(20 + G.wave * 3));
 if (G.slime < reviveCost) {
 showNotif(`üß™ Need ${reviveCost} SLM to revive!`, '#5ac8fa');
 openShop('slime');
 return;
 }
 G.slime -= reviveCost;
 document.getElementById('lose-screen').classList.remove('visible');
 G.fighting = false;
 if (animFrame) cancelAnimationFrame(animFrame);
 enemies = []; particles = []; floatingDmg = [];
 if (window._waveStartGrid) {
 grid = window._waveStartGrid.map(u => u ? { ...u } : null);
 arenaUnits = [];
 } else {
 grid = Array(GRID_SIZE).fill(null);
 grid[0] = { tier: 1, mutant: false };
 grid[1] = { tier: 1, mutant: false };
 arenaUnits = [];
 }
 updateCurrencies();
 renderGrid();
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 drawArena();
 const btn = document.getElementById('btn-start');
 btn.textContent = t('btnWave', G.wave);
 btn.className = 'btn-start' + (isNightmareWave(G.wave) ? ' nightmare-wave' : isBossWave(G.wave) ? ' boss-wave' : '');
 btn.disabled = false;
 document.getElementById('wave-timer').textContent = '‚Äî';
 document.getElementById('wave-timer').className = 'wave-timer';
 
 showNotif(`üß™ REVIVED! Wave ${G.wave} ‚Äî go again!`, '#5ac8fa');
 addLog(`Revived with Slime (-${reviveCost} SLM). Re-fight wave ${G.wave}!`, 'blue');
 sfx.prestige();
 saveGame();
}
function closeTutorial() {
 document.getElementById('tutorial-overlay').classList.remove('visible');
 setTimeout(showRelicPicker, 300);
}
let activeSkin = 'neon';
const ALL_SKINS = ['neon','void','toxic','blood','ice','gold','shadow','cyber'];
function applySkin(skin) {
 document.body.classList.remove(...ALL_SKINS.map(s => 'skin-' + s));
 if (skin) document.body.classList.add('skin-' + skin);
 activeSkin = skin;
 document.querySelectorAll('.skin-btn').forEach(b => {
 b.classList.toggle('active', b.dataset.skin === skin);
 });
 _lastGridFingerprint = ''; // blob colors changed, force full rebuild
 if (typeof renderGrid === 'function') renderGrid();
 if (!window.__resetInProgress) saveGame();
}
document.addEventListener('visibilitychange', () => {
 if (document.hidden) {
 if (animFrame) cancelAnimationFrame(animFrame);
 if (!window.__resetInProgress) {
   G.lastSave = Date.now();
   saveGame();
 }
 } else {
 if (G.fighting) {
 lastTime = 0;
 animFrame = requestAnimationFrame(arenaLoop);
 }
 }
});

// ‚îÄ‚îÄ MOBILE TAB SYSTEM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _mobileTab = 'merge';
const MOBILE_PANELS = {
 merge:    () => document.querySelector('.panel-merge'),
 arena:    () => document.getElementById('panel-arena'),
 upgrades: () => document.querySelector('.panel-upgrades'),
};

function switchMobileTab(tab) {
 _mobileTab = tab;
 Object.entries(MOBILE_PANELS).forEach(([name, getEl]) => {
  const el = getEl();
  if (!el) return;
  const active = name === tab;
  el.classList.toggle('mobile-active', active);
  el.style.display = active
   ? (name === 'arena' ? 'flex' : 'flex')
   : 'none';
  if (active && name !== 'arena') el.style.flexDirection = 'column';
 });
 document.querySelectorAll('.mobile-tab').forEach(btn => {
  btn.classList.toggle('active', btn.id === 'mtab-' + tab);
 });
 if (tab === 'arena') setTimeout(() => { resizeCanvas(); drawArena(); }, 50);
}

function initMobile() {
 if (window.innerWidth <= 600) {
  const hdr = document.querySelector('header');
  if (hdr) document.documentElement.style.setProperty('--header-h', hdr.offsetHeight + 'px');
  // Pod≈ÇƒÖcz event listenery na zak≈Çadki (backup dla onclick)
  ['merge','arena','upgrades'].forEach(tab => {
   const btn = document.getElementById('mtab-' + tab);
   if (btn) {
    btn.onclick = null;
    btn.addEventListener('click', () => switchMobileTab(tab), { passive: true });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); switchMobileTab(tab); });
   }
  });
  switchMobileTab(_mobileTab || 'merge');
 } else {
  Object.values(MOBILE_PANELS).forEach(getEl => {
   const el = getEl();
   if (el) { el.style.display = ''; el.classList.remove('mobile-active'); }
  });
 }
}

window.addEventListener('resize', () => { initMobile(); resizeCanvas(); });

window.addEventListener('load', () => {
 resizeCanvas();
 loadGame();
 loadAudioSettings();
 checkIdleEarnings();
 updateCurrencies();
 renderGrid();
 renderUpgrades();
 startIdleLoop();
 drawArena();
 updateLivesDisplay();
 initMobile();
 addLog(t('logInit'), 'wave');
 addLog(t('logBoss'), 'wave');
 updateRewardButtons();
 initHoldPreview();
 renderMergeStreak();
 if (!G.tutorialSeen) {
 document.getElementById('tutorial-overlay').classList.add('visible');
 } else if (!G.relicSeen) {
 setTimeout(showRelicPicker, 500);
 }
 if (!grid.filter(Boolean).length) {
 grid[0] = { tier: 1, mutant: false };
 grid[1] = { tier: 1, mutant: false };
 addLog('Starter T1 √ó2 placed ‚Äî click to merge!', 'merge');
 renderGrid();
 }
 const nextBoss = Math.ceil(G.wave / 10) * 10;
 if (nextBoss <= MAX_WAVE && nextBoss > G.wave) {
 addLog(`Next BOSS: Wave ${nextBoss}. Prepare your army!`, 'boss');
 }
});
window.addEventListener('resize', () => {
 // Podczas walki ‚Äî NIE r√≥b resize (anti-cheat: skalowanie okna nie daje przewagi)
 if (G.fighting) return;
 resizeCanvas();
 drawArena();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STEROWANIE JEDNOSTKAMI MYSZKƒÑ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let _followMouse = false;
let _mouseCanvasX = 0, _mouseCanvasY = 0;

let _arenaZoom = 1.0;
const ZOOM_STEPS = [0.5, 0.65, 0.8, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0];
let _zoomIdx = 3; // default = 1.0
let _zoomPanX = 0, _zoomPanY = 0; // pan offset when zoomed

function arenaZoom(dir) {
 _zoomIdx = Math.max(0, Math.min(ZOOM_STEPS.length - 1, _zoomIdx + dir));
 _arenaZoom = ZOOM_STEPS[_zoomIdx];
 // Re-center pan when resetting to 1.0
 if (_arenaZoom === 1.0) { _zoomPanX = 0; _zoomPanY = 0; }
 const lbl = document.getElementById('arena-zoom-label');
 if (lbl) lbl.textContent = Math.round(_arenaZoom * 100) + '%';
 // Highlight label when not at 100%
 if (lbl) lbl.style.color = _arenaZoom === 1.0 ? 'rgba(255,255,255,0.4)' : 'rgba(90,200,250,0.9)';
}

// Scroll wheel zoom on arena canvas
(function() {
 function onArenaWheel(e) {
  e.preventDefault();
  arenaZoom(e.deltaY < 0 ? 1 : -1);
 }
 window.addEventListener('load', () => {
  const c = document.getElementById('arena-canvas');
  if (c) c.addEventListener('wheel', onArenaWheel, { passive: false });
 });
})();

function toggleFollowMouse() {
 _followMouse = !_followMouse;
 if (itutActive) itutFollowClicked = true;
 const btn = document.getElementById('btn-follow-mouse');
 if (_followMouse) {
  btn.style.background = 'rgba(76,217,100,0.2)';
  btn.style.borderColor = 'rgba(76,217,100,0.6)';
  btn.style.color = '#4cd964';
  btn.textContent = 'üñ± FOLLOW ON';
 } else {
  btn.style.background = 'rgba(255,255,255,0.06)';
  btn.style.borderColor = 'rgba(255,255,255,0.15)';
  btn.style.color = 'rgba(255,255,255,0.45)';
  btn.textContent = 'üñ± FOLLOW';
 }
}

let _dragUnit  = null;
let _dragOffX  = 0;
let _dragOffY  = 0;
let _origX     = 0;
let _origY     = 0;
const DRAG_R   = 18;

(function() {
 function getCanvasPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width  / rect.width;
  const scaleY = canvas.height / rect.height;
  // Raw canvas pixel position
  const rawX = (e.clientX - rect.left) * scaleX;
  const rawY = (e.clientY - rect.top)  * scaleY;
  // Undo zoom transform: same math as drawArena
  const zx = canvas.width  / 2 + _zoomPanX;
  const zy = canvas.height / 2 + _zoomPanY;
  const cx = (rawX - zx) / _arenaZoom + zx;
  const cy = (rawY - zy) / _arenaZoom + zy;
  return { cx, cy };
 }

 function findUnit(cx, cy) {
  // Znajd≈∫ jednostkƒô pod kursorem (od g√≥ry ‚Äî ostatnia rysowana na wierzchu)
  for (let i = arenaUnits.length - 1; i >= 0; i--) {
   const u = arenaUnits[i];
   const r = 16 + u.tier * 3 + DRAG_R;
   if (Math.hypot(cx - u.x, cy - u.y) < r) return u;
  }
  return null;
 }

 canvas.addEventListener('mousedown', e => {
  if (!G.fighting && arenaUnits.length === 0) return;
  const { cx, cy } = getCanvasPos(e);
  const u = findUnit(cx, cy);
  if (!u) return;
  e.preventDefault();
  _dragUnit = u;
  _dragOffX = cx - u.x;
  _dragOffY = cy - u.y;
  _origX = u.x;
  _origY = u.y;
  canvas.style.cursor = 'grabbing';
 });

 canvas.addEventListener('mousemove', e => {
  const { cx, cy } = getCanvasPos(e);
  // Zapisz pozycjƒô myszy dla trybu follow
  _mouseCanvasX = cx;
  _mouseCanvasY = cy;
  if (!_dragUnit) {
   canvas.style.cursor = _followMouse ? 'crosshair' : (findUnit(cx, cy) ? 'grab' : 'default');
   return;
  }
  e.preventDefault();
  const margin = _dragUnit.size + 4;
  _dragUnit.x = Math.max(margin, Math.min(canvas.width  - margin, cx - _dragOffX));
  _dragUnit.y = Math.max(margin, Math.min(canvas.height - margin, cy - _dragOffY));
 });

 function stopDrag() {
  if (!_dragUnit) return;
  canvas.style.cursor = 'default';
  _dragUnit = null;
 }

 canvas.addEventListener('mouseup',    stopDrag);
 canvas.addEventListener('mouseleave', stopDrag);

 // Touch support (mobile)
 canvas.addEventListener('touchstart', e => {
  const t = e.touches[0];
  const { cx, cy } = getCanvasPos(t);
  const u = findUnit(cx, cy);
  if (!u) return;
  e.preventDefault();
  _dragUnit = u;
  _dragOffX = cx - u.x;
  _dragOffY = cy - u.y;
 }, { passive: false });

 canvas.addEventListener('touchmove', e => {
  if (!_dragUnit) return;
  e.preventDefault();
  const t = e.touches[0];
  const { cx, cy } = getCanvasPos(t);
  const margin = _dragUnit.size + 4;
  _dragUnit.x = Math.max(margin, Math.min(canvas.width  - margin, cx - _dragOffX));
  _dragUnit.y = Math.max(margin, Math.min(canvas.height - margin, cy - _dragOffY));
 }, { passive: false });

 canvas.addEventListener('touchend', stopDrag);

 // Escape ‚Äî reset pozycji
 window.addEventListener('keydown', e => {
  if (e.key === 'Escape' && _dragUnit) {
   _dragUnit.x = _origX;
   _dragUnit.y = _origY;
   stopDrag();
  }
 });
})();
window.addEventListener('beforeunload', () => {
 if (window.__resetInProgress) return; 
 G.lastSave = Date.now();
 saveGame();
});
let currentLang = 'en';
const STRINGS = {
 en: {
 waveLbl: w => `WAVE ${w}`, bossWaveLbl: w => `‚ö† BOSS WAVE ${w}`, nightmareLbl: w => `üíÄ NIGHTMARE WAVE ${w}`,
 btnWave: w => `‚ñ∂ WAVE ${w}`, btnBossWave: w => `‚ö† BOSS WAVE ${w}`, btnNightmare: w => `üíÄ NIGHTMARE WAVE ${w}`,
 btnFighting: '‚öî FIGHTING...', btnBossFighting: '‚ö† BOSS WAVE!',
 btnBuy: 'BUY UNIT', btnShop: 'üõí SHOP', btnSfx: 'üîá SFX', btnSfxOn: 'üîä SFX',
 audioOn: 'ON', audioOff: 'OFF', btnRanks: 'üèÜ RANKS', btnReset: '‚ö† RESET SAVE', btnPrestige: '‚ö° PRESTIGE',
 panelMerge: '‚¨° MERGE LAB', panelArena: '‚öî ARENA',
 tabUpgrades: 'üß¨ Upgrades', tabResearch: 'üî¨ Research',
 gridFull: 'GRID FULL!', noUnits: 'NO UNITS! BUY SOME FIRST', unlockAuto: 'UNLOCK AUTO-MERGE FIRST',
 mutation: '‚ö° MUTATION UNLOCKED!', eliteCreated: '‚ö° ELITE CREATED!',
 regenPulse: 'üíö REGEN PULSE ‚Äî units healed!',
 waveCleared: (w, g) => `WAVE ${w} CLEARED! +${g} GOLD`,
 waveIncomplete: 'WAVE INCOMPLETE ‚Äî REVIVE AVAILABLE',
 bossSlain: g => `‚ò† BOSS SLAIN! +${g}g`,
 reachWave5: 'REACH WAVE 5 FIRST',
 needElite: 'Need 2+ units for Elite!',
 saveWiped: 'SAVE WIPED ‚Äî Fresh start!',
 upgradeBought: name => 'UPGRADE: ' + name.toUpperCase(),
 researchBought: name => 'RESEARCH: ' + name.toUpperCase(),
 relicChosen: name => `‚öó RELIC: ${name}`,
 logInit: 'LAB INITIALIZED ‚Äî buy units, merge, fight!',
 logBoss: 'Boss waves every 10. Survive 100 waves!',
 logSaveLoaded: 'Save loaded.', logSaveReset: 'Save reset. Fresh start!',
 logBought: (tier, name, cost) => `Bought T${tier} ${name} [-${cost}g]`,
 logMerged: (tier, name) => `Merged ‚Üí T${tier} ${name}`,
 logMutation: (tier, name) => `‚ö° MUTATION! T${tier} ${name} [MUTANT]`,
 logUnitFell: name => `${name} fell!`,
 logWaveCleared: (w, g, bio, res) => `Wave ${w} CLEARED! +${g}g +${bio} BIO +${res} RES`,
 logWaveTimeout: w => `Wave ${w} timed out. Regroup!`,
 logBossKilled: (name, g) => `‚ò† ${name} KILLED! +${g}g`,
 logNightmare: w => `‚ïî‚ïê‚ïê üíÄ NIGHTMARE WAVE ${w}! ‚ïê‚ïê‚ïó`,
 logBossWave: w => `‚ïî‚ïê‚ïê BOSS WAVE ${w}! ‚ïê‚ïê‚ïó`,
 logWaveStart: w => `--- WAVE ${w} START ---`,
 logMeteor: n => `‚òÑ METEOR SHOWER ‚Äî ${n} meteors incoming!`,
 logElite: name => `Unit sacrificed ‚Üí ${name} became ELITE!`,
 logPrestige: (p, gain) => `‚ïê‚ïê‚ïê PRESTIGE ${p} ‚ïê‚ïê‚ïê +${gain} RES`,
 logRelic: (name, desc) => `Run relic: ${name} ‚Äî ${desc}`,
 logResearch: name => `Research: ${name}`,
 logPurchased: name => `Purchased: ${name}`,
 enemies: n => `ENEMIES: ${n}`, kills: n => `KILLS: ${n}`,
 bossWaveBanner: '‚ö† BOSS WAVE ‚ö†', nightmareBanner: 'üíÄ NIGHTMARE WAVE üíÄ',
 nightmareSubtitle: 'DEBUFF ACTIVE ‚Äî -40% DPS ¬∑ 2√ó ENEMY DMG',
 purchased: 'PURCHASED', permanent: 'PERMANENT',
 lbTitle: 'üèÜ LEADERBOARD', lbSubtitle: 'GLOBAL RANKINGS ¬∑ TOP 50',
 lbLoading: 'Loading‚Ä¶', lbEmpty: 'No entries yet ‚Äî be the first!',
 lbError: 'Could not load leaderboard.', lbNoEntries: 'No entries yet!',
 lbNickPlaceholder: 'Enter your name‚Ä¶', lbSubmit: 'SUBMIT SCORE', lbClose: 'CLOSE',
 lbNickRequired: 'Enter a name first!', lbSubmitting: 'Submitting‚Ä¶',
 lbSubmitOk: score => `Score ${score} submitted! ‚úì`, lbSubmitFail: 'Submit failed ‚Äî try again.',
 nightmareDebuff: 'üíÄ NIGHTMARE: Blobs deal -40% DPS ¬∑ Enemies deal 2√ó damage',
 volMusic: 'üéµ MUS', volSfx: 'üîä SFX', volAudio: 'Audio',
 savesMemOnly: '‚ö† saves in memory only', saved: 'üíæ saved',
 },
};
const UNIT_NAMES = {
 en: ['','BLOB','SPITTER','SPLITTER','MAGNET','REACTOR','ANOMALY','PHANTOM','COLOSSUS','VOIDLING','OMEGA'],
 pl: ['','PLAMA','SPLUWACZ','SPLITER','MAGNES','REAKTOR','ANOMALIA','FANTOM','KOLOS','PUSTKA','OMEGA'],
};
const RELIC_DATA = {
 en: [
 { name: 'üî• BERSERKER CORE', desc: '+40% DPS for all units. Units take 25% more damage.' },
 { name: 'üõ° FORTRESS GRID', desc: 'Units have +80% HP. Only 3 columns usable.' },
 { name: '‚öó MUTATION CATALYST', desc: 'Every merge has 30% mutant chance. Mutants deal 3√ó DPS.' },
 { name: 'üí∞ GOLD RUSH', desc: 'Earn 2√ó gold from waves. Units cost 50% more.' },
 { name: 'üß¨ SYNERGY ENGINE', desc: 'Adjacency bonuses doubled. Synergy thresholds reduced by 1.' },
 { name: 'üí• VOLATILE MASS', desc: 'All units gain Exploder role. Merge costs health.' },
 ],
 pl: [
 { name: 'üî• BERSERKER CORE', desc: '+40% DPS for all units. Units take 25% more damage.' },
 { name: 'üõ° FORTRESS GRID', desc: 'Units have +80% HP. Only 3 columns usable.' },
 { name: '‚öó MUTATION CATALYST', desc: 'Every merge has 30% mutant chance. Mutants deal 3√ó DPS.' },
 { name: 'üí∞ GOLD RUSH', desc: 'Earn 2√ó gold from waves. Units cost 50% more.' },
 { name: 'üß¨ SYNERGY ENGINE', desc: 'Adjacency bonuses doubled. Synergy thresholds reduced by 1.' },
 { name: 'üí• NIESTABILNA MASA', desc: 'Wszystkie jednostki jako Niszczyciele. Merge kosztuje HP.' },
 ],
};
const WAVE_EVENT_DATA = {
 en: [
 { name: '‚ú¶ CRIT AURA', desc: '+25% crit chance for next 3 waves.' },
 { name: '‚òÑ METEOR SHOWER', desc: '5 meteors hit random enemies at wave start.' },
 { name: '‚ö° SACRIFICE ‚Üí ELITE', desc: 'Remove one unit. A random unit becomes Elite (+100% DPS).' },
 { name: 'üí∞ GOLD RAIN', desc: 'Gain 3√ó current wave reward in gold immediately.' },
 { name: 'üõ° BARRIER WAVE', desc: 'All units gain a shield for next wave.' },
 { name: 'üíö REGEN PULSE', desc: 'All units heal 40% max HP.' },
 { name: '‚öô OVERCLOCK', desc: 'Attack speed +50% for next 2 waves.' },
 { name: '‚ò† TOXIC FIELD', desc: 'All enemies take 5 DOT/s for next 2 waves.' },
 ],
 pl: [
 { name: '‚ú¶ AURA KRYTA', desc: '+25% szansa trafienia krytycznego przez 3 fale.' },
 { name: '‚òÑ METEOR SHOWER', desc: '5 meteors strike random enemies at wave start.' },
 { name: '‚ö° SACRIFICE ‚Üí ELITE', desc: 'Remove one unit. A random unit becomes Elite (+100% DPS).' },
 { name: 'üí∞ GOLD RAIN', desc: 'Gain 3√ó current wave reward in gold immediatst.' },
 { name: 'üõ° SHIELD WAVE', desc: 'All units gain a shield for the next wave.' },
 { name: 'üíö REGEN PULSE', desc: 'All units heal 40% of max HP.' },
 { name: '‚öô OVERCLOCK', desc: 'Attack speed +50% for 2 waves.' },
 { name: '‚ò† POISON FIELD', desc: 'All enemies take 5 DOT/s for 2 waves.' },
 ],
};
const UPGRADE_DATA = {
 en: [
 { name: 'Auto-Merge Lab', desc: 'Automatically merges matching units' },
 { name: 'Idle Efficiency I', desc: '+10% idle gold rate' },
 { name: 'Idle Efficiency II', desc: '+10% idle gold rate' },
 { name: 'Idle Efficiency III', desc: '+10% idle gold rate' },
 { name: 'Mutation Serum I', desc: '+3.5% mutation chance' },
 { name: 'Mutation Serum II', desc: '+3.5% mutation chance' },
 { name: 'Mutation Serum III', desc: '+3.5% mutation chance' },
 { name: 'Combat Serum I', desc: '+30% unit DPS' },
 { name: 'Combat Serum II', desc: '+30% unit DPS' },
 { name: 'Combat Serum III', desc: '+30% unit DPS' },
 { name: 'Evolved Spawn', desc: 'Buy units start at T2' },
 ],
 pl: [
 { name: 'Auto-Merge Lab', desc: 'Automatically merges matching blobstki' },
 { name: 'Idle Efficiency I', desc: '+10% idle gold rate' },
 { name: 'Idle Efficiency II', desc: '+10% idle gold rate' },
 { name: 'Idle Efficiency III', desc: '+10% idle gold rate' },
 { name: 'Serum Mutacji I', desc: '+3.5% szansa mutacji' },
 { name: 'Serum Mutacji II', desc: '+3.5% szansa mutacji' },
 { name: 'Serum Mutacji III', desc: '+3.5% szansa mutacji' },
 { name: 'Serum Bojowe I', desc: '+30% DPS jednostek' },
 { name: 'Serum Bojowe II', desc: '+30% DPS jednostek' },
 { name: 'Serum Bojowe III', desc: '+30% DPS jednostek' },
 { name: 'Evolved Spawn', desc: 'Purchased blobs start at T2' },
 ],
};
const RESEARCH_DATA = {
 en: [
 { name: 'Recombination I', desc: '+5% mutation (permanent)' },
 { name: 'Recombination II', desc: '+5% mutation (permanent)' },
 { name: 'Dormant Protocol I', desc: '+10% offline earnings' },
 { name: 'Dormant Protocol II', desc: '+10% offline earnings' },
 { name: 'Chaos Gene I', desc: '+5% mutation (permanent)' },
 { name: 'Enemy Magnet I', desc: 'More enemies, more gold' },
 { name: 'Enemy Magnet II', desc: 'Max spawn density' },
 ],
 pl: [
 { name: 'Rekombinacja I', desc: '+5% mutacji (permanentne)' },
 { name: 'Rekombinacja II', desc: '+5% mutacji (permanentne)' },
 { name: 'Sleep Protocol I', desc: '+10% offline earnings' },
 { name: 'Sleep Protocol II', desc: '+10% offline earnings' },
 { name: 'Gen Chaosu I', desc: '+5% mutacji (permanentne)' },
 { name: 'Enemy Magnet I', desc: 'More enemies, more gold' },
 { name: 'Enemy Magnet II', desc: 'Maximum spawn density' },
 ],
};
function t(key, ...args) {
 const lang = STRINGS[currentLang] || STRINGS.en;
 const val = lang[key] ?? STRINGS.en[key];
 if (val === undefined) return key;
 return typeof val === 'function' ? val(...args) : val;
}
function tUnit(tier) { return (UNIT_NAMES[currentLang] || UNIT_NAMES.en)[tier] || (UNIT_TYPES[tier] && UNIT_TYPES[tier].name) || ''; }
function tRelic(idx) { return (RELIC_DATA[currentLang] || RELIC_DATA.en)[idx]; }
function tEvent(idx) { return (WAVE_EVENT_DATA[currentLang] || WAVE_EVENT_DATA.en)[idx]; }
function tUpgrade(idx) { return (UPGRADE_DATA[currentLang] || UPGRADE_DATA.en)[idx]; }
function tResearch(idx){ return (RESEARCH_DATA[currentLang] || RESEARCH_DATA.en)[idx]; }

function applyLangToStaticHTML() {
 const q = id => document.getElementById(id);
 const pm = q('panel-merge-title'); if (pm) pm.textContent = t('panelMerge');
 const pa = q('panel-arena-title'); if (pa) pa.textContent = t('panelArena');
 document.querySelectorAll('.upgrade-tab').forEach((el, i) => el.textContent = i === 0 ? t('tabUpgrades') : t('tabResearch'));
 const bb = q('btn-buy-label'); if (bb) bb.textContent = t('btnBuy');
 const sb = q('btn-sound'); if (sb) sb.textContent = soundEnabled ? t('btnSfxOn') : t('btnSfx');
 const vt = q('vol-toggle-btn'); if (vt) { vt.textContent = soundEnabled ? t('audioOn') : t('audioOff'); }
 const vla = q('vol-audio-label'); if (vla) vla.textContent = t('volAudio');
 const vlm = q('vol-music-label'); if (vlm) vlm.textContent = t('volMusic');
 const vlsfx = q('vol-sfx-label'); if (vlsfx) vlsfx.textContent = t('volSfx');
 const lbt = q('lb-title-el'); if (lbt) lbt.textContent = t('lbTitle');
 const lbs = q('lb-subtitle-el'); if (lbs) lbs.textContent = t('lbSubtitle');
 const lbn = q('lb-nick'); if (lbn) lbn.placeholder = t('lbNickPlaceholder');
 const lbsb = q('lb-submit-btn'); if (lbsb) lbsb.textContent = t('lbSubmit');
 const lbcb = q('lb-close-btn-el'); if (lbcb) lbcb.textContent = t('lbClose');
 const nd = q('nightmare-debuff-bar'); if (nd) nd.textContent = t('nightmareDebuff');
 const shopb = q('btn-shop-open'); if (shopb) shopb.textContent = t('btnShop');
 const ranksb = q('btn-ranks'); if (ranksb) ranksb.textContent = t('btnRanks');
 const resetb = q('btn-reset-el'); if (resetb) resetb.textContent = t('btnReset');
 const prestb = q('btn-prestige-el'); if (prestb) prestb.textContent = t('btnPrestige');
}

const ITUT_STEPS = [
 {
 id: 'buy1',
 icon: 'üí∞',
 title: 'BUY YOUR FIRST BLOB',
 desc: 'Press the <strong>BUY UNIT</strong> button to place a blob into the Merge Lab grid.',
 hint: 'üëÜ Click BUY UNIT',
 target: 'btn-buy',
 arrow: 'bottom',
 wait: 'blob_bought', 
 },
 {
 id: 'buy2',
 icon: '‚¨°',
 title: 'BUY ONE MORE',
 desc: 'Buy a second blob so you have two of the same tier ‚Äî then you can merge!',
 hint: 'üëÜ Click BUY UNIT again',
 target: 'btn-buy',
 arrow: 'bottom',
 wait: 'two_blobs', 
 },
 {
 id: 'merge',
 icon: 'üîÄ',
 title: 'MERGE THEM!',
 desc: 'Two ways to merge blobs:<br><br>üñ± <strong>Drag & Drop</strong> ‚Äî drag one blob onto another of the same tier.<br><br>üëÜ <strong>Click & Click</strong> ‚Äî click a blob to select it (it glows yellow!), then click another blob of the same tier to fuse them.',
 hint: 'üñ± Drag or click to merge',
 target: 'merge-grid',
 arrow: 'right',
 wait: 'merged', 
 },
 {
 id: 'fight',
 icon: '‚öîÔ∏è',
 title: 'START THE WAVE',
 desc: 'Your blobs are ready to fight! Press the wave button to unleash them on the arena.',
 hint: 'üëÜ Click ‚ñ∂ WAVE 1',
 target: 'btn-start',
 arrow: 'top',
 wait: 'wave_started', 
 },
 {
 id: 'watch',
 icon: 'üëÄ',
 title: 'WATCH THEM FIGHT',
 desc: 'Your blobs fight <strong>automatically</strong>! Defeat all enemies to claim gold and advance to the next wave.',
 hint: '‚è≥ Watching the battle‚Ä¶',
 target: 'panel-arena',
 arrow: 'left',
 wait: 'wave_ended', 
 autoAdvance: 4000,
 },
 {
 id: 'follow',
 icon: 'üñ±',
 title: 'FOLLOW MODE',
 desc: 'Press the <strong>üñ± FOLLOW</strong> button and your blobs will chase your cursor during battle ‚Äî great for directing attacks at tough enemies!',
 hint: 'üëÜ Click FOLLOW to try it',
 target: 'btn-follow-mouse',
 arrow: 'bottom',
 wait: 'follow_clicked',
 },
 {
 id: 'upgrade',
 icon: 'üß¨',
 title: 'CHECK YOUR UPGRADES',
 desc: 'Open the <strong>Upgrades</strong> tab to spend gold boosting your DPS, merge luck, and idle income.',
 hint: 'üëÜ Click the Upgrades tab',
 target: 'upgrade-tab-0',
 arrow: 'left',
 wait: 'upgrade_tab', 
 },
 {
 id: 'speed',
 icon: '‚è©',
 title: 'SPEED UP THE GAME',
 desc: 'Press the <strong>1√ó</strong> button to speed up battles ‚Äî tap it to cycle through <strong>1√ó ‚Üí 2√ó ‚Üí 4√ó</strong> speed. Great for grinding waves faster!<br><br>Unlock even faster speeds in the <strong>Shop</strong>.',
 hint: 'üëÜ Click the 1√ó button to speed up',
 target: 'btn-speed',
 arrow: 'bottom',
 wait: 'speed_clicked',
 },
 {
 id: 'prestige',
 icon: '‚ö°',
 title: 'PRESTIGE ‚Äî THE LOOP',
 desc: '<strong>Prestige</strong> resets your run (blobs, gold, waves) but keeps all your <span class="hi">Research points (RES)</span>.<br><br>The more waves you survive before prestiging, the more <strong>RES</strong> you earn. Spend RES on permanent upgrades in the <strong>Research</strong> tab ‚Äî each run gets stronger!<br><br>üîí Unlocks after <strong>Wave 5</strong>. Your <span class="hi">Best Wave</span> and <span class="hi">Best Kills</span> are saved forever across all runs.',
 hint: null,
 target: 'prestige-section',
 arrow: 'bottom',
 wait: 'prestige_read',
 isPrestigeInfo: true,
 },
 {
 id: 'done',
 icon: 'üèÜ',
 title: "YOU'RE READY!",
 desc: 'Merge blobs, fight waves, upgrade your lab. Reach wave 100 to win!<br><br><span class="hi">Nightmare waves</span> at 25, 50, 75 ‚Äî survive them for bonus score.',
 hint: null,
 target: null,
 wait: null,
 isDone: true,
 },
];
let itutActive = false;
let itutStepIdx = 0;
let itutWasFighting = false;
let itutHighlightEl = null;
let itutCheckInterval = null;
function itutStart() {
 if (G.tutorialSeen) return;
 itutActive = true;
 itutStepIdx = 0;
 itutWasFighting = false;
 itutSpeedClicked = false;
 itutFollowClicked = false;
 itutUpgradeTabClicked = false;
 itutShowStep(0);
 itutCheckInterval = setInterval(itutPoll, 300);
}
function itutShowStep(idx) {
 const step = ITUT_STEPS[idx];
 if (!step) { itutFinish(); return; }
 if (itutHighlightEl) { itutHighlightEl.classList.remove('itut-highlight'); itutHighlightEl = null; }
 const oldNb = document.getElementById('itut-next-btn'); if (oldNb) oldNb.remove();
 const oldDb = document.getElementById('itut-done-btn'); if (oldDb) oldDb.remove();
 const box = document.getElementById('itut-box');
 const inner = document.getElementById('itut-inner');
 const total = ITUT_STEPS.length;
 let dotsHtml = '<div class="itut-dots">';
 ITUT_STEPS.forEach((s, i) => {
 const cls = i < idx ? 'done' : i === idx ? 'active' : '';
 dotsHtml += `<div class="itut-dot ${cls}"></div>`;
 });
 dotsHtml += '</div>';
 document.getElementById('itut-step-indicator').innerHTML = dotsHtml + `STEP ${idx+1} / ${total}`;
 document.getElementById('itut-icon').textContent = step.icon;
 document.getElementById('itut-title').textContent = step.title;
 document.getElementById('itut-desc').innerHTML = step.desc;
 document.getElementById('itut-action-hint').textContent = step.hint || '';
 document.getElementById('itut-action-hint').style.display = step.hint ? 'block' : 'none';
 document.getElementById('itut-skip').style.display = (step.isDone || step.isPrestigeInfo) ? 'none' : 'block';
 // Remove any leftover next/done buttons
 const oldNext = document.getElementById('itut-next-btn');
 if (oldNext) oldNext.remove();
 if (step.isPrestigeInfo) {
 const existing = document.getElementById('itut-next-btn');
 if (!existing) {
 const btn = document.createElement('button');
 btn.id = 'itut-next-btn';
 btn.textContent = 'NEXT ‚Üí';
 btn.style.cssText = `
 display:block;width:100%;margin-top:10px;padding:10px;
 background:linear-gradient(135deg,var(--purple),var(--pink));
 border:none;border-radius:12px;color:#fff;
 font-family:'Fredoka One',sans-serif;font-size:14px;
 cursor:pointer;letter-spacing:1px;
 `;
 btn.onclick = itutNext;
 inner.appendChild(btn);
 }
 }
 if (step.isDone) {
 document.getElementById('itut-skip').textContent = '';
 {
 const btn = document.createElement('button');
 btn.id = 'itut-done-btn';
 btn.textContent = '‚ñ∂ LET\'S GO!';
 btn.style.cssText = `
 display:block;width:100%;margin-top:10px;padding:10px;
 background:linear-gradient(135deg,var(--blue),var(--purple));
 border:none;border-radius:12px;color:#fff;
 font-family:'Fredoka One',sans-serif;font-size:14px;
 cursor:pointer;letter-spacing:1px;
 `;
 btn.onclick = itutFinish;
 inner.appendChild(btn);
 }
 }
 box.style.display = 'block';
 itutPositionBox(step);
 if (step.target) {
 const el = document.getElementById(step.target);
 if (el) { el.classList.add('itut-highlight'); itutHighlightEl = el; }
 }
 if (step.autoAdvance) {
 setTimeout(() => {
 if (itutStepIdx === idx) itutNext();
 }, step.autoAdvance);
 }
}
function itutPositionBox(step) {
 const box = document.getElementById('itut-box');
 const arrow = document.getElementById('itut-arrow');
 if (!step.target) {
 box.style.left = '50%';
 box.style.top = '50%';
 box.style.transform = 'translate(-50%,-50%)';
 arrow.style.display = 'none';
 return;
 }
 arrow.style.display = 'block';
 const el = document.getElementById(step.target);
 if (!el) { box.style.left='50%'; box.style.top='50%'; box.style.transform='translate(-50%,-50%)'; return; }
 box.style.transform = '';
 const r = el.getBoundingClientRect();
 const bw = 290, bh = Math.max(box.offsetHeight || 0, 260);
 const pad = 18;
 const dir = step.arrow || 'bottom';
 let bx, by, ax, ay, arrowStyle;
 if (dir === 'bottom') {
 bx = Math.max(8, Math.min(window.innerWidth - bw - 8, r.left + r.width/2 - bw/2));
 by = r.top - bh - pad;
 if (by < 8) { by = r.bottom + pad; arrowStyle = 'top:-8px;left:50%;transform:translateX(-50%) rotate(45deg);border-color:rgba(90,200,250,0.5) transparent transparent rgba(90,200,250,0.5)'; }
 else arrowStyle = `bottom:-8px;left:${r.left+r.width/2-bx}px;transform:rotate(45deg);border-color:transparent rgba(90,200,250,0.5) rgba(90,200,250,0.5) transparent`;
 } else if (dir === 'top') {
 bx = Math.max(8, Math.min(window.innerWidth - bw - 8, r.left + r.width/2 - bw/2));
 by = r.bottom + pad;
 if (by + bh > window.innerHeight - 8) { by = r.top - bh - pad; }
 if (by < 8) by = 8;
 arrowStyle = `top:-8px;left:${Math.max(20, r.left+r.width/2-bx)}px;transform:rotate(45deg);border-color:rgba(90,200,250,0.5) rgba(90,200,250,0.5) transparent transparent`;
 } else if (dir === 'right') {
 bx = r.left - bw - pad;
 if (bx < 8) bx = r.right + pad;
 by = Math.max(8, Math.min(window.innerHeight - bh - 8, r.top + r.height/2 - bh/2));
 arrowStyle = `right:-8px;top:${r.top+r.height/2-by}px;transform:rotate(45deg);border-color:rgba(90,200,250,0.5) rgba(90,200,250,0.5) transparent transparent`;
 } else { 
 bx = r.right + pad;
 if (bx + bw > window.innerWidth - 8) bx = r.left - bw - pad;
 by = Math.max(8, Math.min(window.innerHeight - bh - 8, r.top + r.height/2 - bh/2));
 arrowStyle = `left:-8px;top:${Math.max(20,r.top+r.height/2-by)}px;transform:rotate(45deg);border-color:transparent transparent rgba(90,200,250,0.5) rgba(90,200,250,0.5)`;
 }
 box.style.left = bx + 'px';
 box.style.top = by + 'px';
 arrow.style.cssText = `position:absolute;width:14px;height:14px;background:rgba(18,12,30,0.98);border:1.5px solid;${arrowStyle}`;
}
function itutPoll() {
 if (!itutActive) return;
 const step = ITUT_STEPS[itutStepIdx];
 if (!step || !step.wait) return;
 let advance = false;
 switch (step.wait) {
 case 'blob_bought': advance = grid.filter(Boolean).length >= 1; break;
 case 'two_blobs': advance = grid.filter(Boolean).length >= 2; break;
 case 'merged': advance = grid.filter(Boolean).some(c => c && c.tier >= 2); break;
 case 'wave_started': advance = G.fighting; break;
 case 'wave_ended':
 if (G.fighting) itutWasFighting = true;
 advance = itutWasFighting && !G.fighting;
 break;
 case 'speed_clicked': advance = itutSpeedClicked; break;
 case 'follow_clicked': advance = itutFollowClicked; break;
 case 'upgrade_tab': advance = itutUpgradeTabClicked; break;
 }
 if (advance) itutNext();
}
let itutSpeedClicked = false;
let itutFollowClicked = false;
let itutUpgradeTabClicked = false;
function itutNext() {
 itutStepIdx++;
 if (itutStepIdx >= ITUT_STEPS.length) { itutFinish(); return; }
 itutShowStep(itutStepIdx);
 setTimeout(() => itutPositionBox(ITUT_STEPS[itutStepIdx]), 50);
}
function itutSkip() {
 if (!confirm('Skip the tutorial?')) return;
 itutFinish();
}
function itutFinish() {
 itutActive = false;
 clearInterval(itutCheckInterval);
 if (itutHighlightEl) { itutHighlightEl.classList.remove('itut-highlight'); itutHighlightEl = null; }
 document.getElementById('itut-box').style.display = 'none';
 document.getElementById('itut-backdrop').style.display = 'none';
 G.tutorialSeen = true;
 saveGame();
 showNotif('üéì Tutorial complete!', 'var(--green)');
}
</script>

<!-- HOLD PREVIEW TOOLTIP -->
<div id="hold-preview-tooltip"></div>

<!-- MERGE LAB MODAL -->
<div id="merge-lab-overlay" onclick="if(event.target===this)closeMergeLab()">
  <div class="merge-lab-modal" onclick="event.stopPropagation()">
    <button class="merge-lab-close" onclick="closeMergeLab()">‚úï CLOSE</button>
    <div class="merge-lab-title">‚öó MERGE LAB</div>
    <div class="merge-lab-sub">SPECIAL CRAFTING RECIPES ¬∑ COMBINE UNITS TO FORGE LEGENDS</div>
    <div id="merge-lab-content"></div>
  </div>
</div>

<audio id="bg-music" loop preload="auto" style="display:none">
  <source src="background-music.mp3" type="audio/mpeg">
</audio>

<!-- LEADERBOARD MODAL -->
<div class="lb-overlay" id="lb-overlay" onclick="if(event.target===this)closeLeaderboard()" style="pointer-events:auto">
  <div class="lb-modal" onclick="event.stopPropagation()">
    <div class="lb-title" id="lb-title-el">üèÜ LEADERBOARD</div>
    <div class="lb-subtitle" id="lb-subtitle-el">GLOBAL RANKINGS ¬∑ TOP 50</div>
    <div class="lb-entry-form">
      <input class="lb-nick-input" id="lb-nick" placeholder="Enter your name‚Ä¶" maxlength="20">
      <button class="lb-submit-btn" id="lb-submit-btn" onclick="submitScore()">SUBMIT SCORE</button>
    </div>
    <div id="lb-status" style="font-size:11px;color:var(--green);text-align:center;min-height:16px;margin-bottom:8px"></div>
    <ul class="lb-list" id="lb-list"><li class="lb-loading">Loading‚Ä¶</li></ul>
    <button class="lb-close-btn" id="lb-close-btn-el" onclick="closeLeaderboard()">CLOSE</button>
  </div>
</div>

  <!-- CHEAT PANEL -->
  <div id="cheat-panel">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;">
      <div class="cheat-title" style="margin-bottom:0">‚ö° DEV CHEATS</div>
      <button onclick="document.getElementById('cheat-panel').classList.remove('open')" style="background:none;border:1px solid rgba(255,255,255,0.2);color:rgba(255,255,255,0.5);font-size:14px;cursor:pointer;line-height:1;padding:2px 7px;border-radius:6px;flex-shrink:0;" onmouseover="this.style.color='#fff';this.style.borderColor='rgba(255,255,255,0.5)'" onmouseout="this.style.color='rgba(255,255,255,0.5)';this.style.borderColor='rgba(255,255,255,0.2)'">‚úï</button>
    </div>
    <div class="cheat-row">
      <label>üí∞ Gold</label>
      <div class="cheat-btns">
        <button class="cheat-btn gold" onclick="cheatGold(1000)">+1K</button>
        <button class="cheat-btn gold" onclick="cheatGold(10000)">+10K</button>
        <button class="cheat-btn gold" onclick="cheatGold(100000)">+100K</button>
      </div>
    </div>
    <div class="cheat-row">
      <label>üß™ Slime</label>
      <div class="cheat-btns">
        <button class="cheat-btn slime" onclick="G.slime+=100;updateCurrencies();renderShop()">+100</button>
        <button class="cheat-btn slime" onclick="G.slime+=500;updateCurrencies();renderShop()">+500</button>
        <button class="cheat-btn slime" onclick="G.slime+=2000;updateCurrencies();renderShop()">+2K</button>
      </div>
    </div>
    <div class="cheat-row">
      <label>üß¨ Biomass</label>
      <div class="cheat-btns">
        <button class="cheat-btn bio" onclick="cheatBio(100)">+100</button>
        <button class="cheat-btn bio" onclick="cheatBio(500)">+500</button>
      </div>
    </div>
    <div class="cheat-row">
      <label>üî¨ Research</label>
      <div class="cheat-btns">
        <button class="cheat-btn res" onclick="cheatRes(100)">+100</button>
        <button class="cheat-btn res" onclick="cheatRes(500)">+500</button>
      </div>
    </div>
    <div class="cheat-row">
      <label>‚ò† God Mode</label>
      <div class="cheat-btns">
        <button class="cheat-btn" id="cheat-god-btn" onclick="cheatGodMode()" style="background:rgba(255,68,68,0.2);border:1px solid rgba(255,68,68,0.5);color:#ff8888;">GOD OFF</button>
      </div>
    </div>
    <hr class="cheat-sep">
    <div class="cheat-row">
      <label>‚è≠ Skip wave</label>
      <div class="cheat-btns">
        <button class="cheat-btn wave" onclick="cheatSkipWave()">SKIP +1</button>
        <button class="cheat-btn wave" onclick="cheatSkipWave(5)">SKIP +5</button>
      </div>
    </div>
    <div class="cheat-row">
      <label>üêô Fill grid T1</label>
      <div class="cheat-btns">
        <button class="cheat-btn fill" onclick="cheatFillGrid()">FILL</button>
      </div>
    </div>
    <div class="cheat-row">
      <label>üíé Max everything</label>
      <div class="cheat-btns">
        <button class="cheat-btn full" onclick="cheatMaxAll()">MAX OUT</button>
      </div>
    </div>
  </div>

<script>
(function() {
  const COLORS = ['#4cd964','#5ac8fa','#bf5af2','#ff9f0a','#ff453a','#ffd60a'];
  const EMOJIS = ['üü¢','üîµ','üü£','üü°'];
  let slimes = [];
  let _titleRaf = null;

  function initTitleSlimes() {
    const cvs = document.getElementById('title-slime-canvas');
    if (!cvs) return;
    const titleEl = cvs.parentElement;
    const W = titleEl.offsetWidth + 120;
    const H = 64;
    cvs.width = W;
    cvs.height = H;
    cvs.style.width = W + 'px';
    cvs.style.height = H + 'px';
    cvs.style.left = '50%';
    cvs.style.top = '50%';
    cvs.style.transform = 'translate(-50%,-50%)';

    slimes = [];
    scheduleTitleSlime(W, H, 400);
    scheduleTitleSlime(W, H, 2500);
    scheduleTitleSlime(W, H, 4800);

    if (_titleRaf) cancelAnimationFrame(_titleRaf);
    animateTitleSlimes(cvs, W, H);
  }

  function scheduleTitleSlime(W, H, delay) {
    setTimeout(() => {
      spawnTitleSlime(W, H);
      setTimeout(function loop() {
        if (slimes.length < 3) spawnTitleSlime(W, H);
        setTimeout(loop, 6000 + Math.random() * 4000);
      }, 6000 + Math.random() * 4000);
    }, delay);
  }

  function spawnTitleSlime(W, H) {
    const goRight = Math.random() < 0.5;
    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
    const r = 7 + Math.random() * 5;
    const speed = 28 + Math.random() * 22;
    const y = H * 0.3 + Math.random() * H * 0.4;
    slimes.push({
      x: goRight ? -r * 2 : W + r * 2,
      y,
      r,
      color,
      vx: goRight ? speed : -speed,
      vy: 0,
      phase: Math.random() * Math.PI * 2,
      wobble: 0.8 + Math.random() * 0.5,
      dead: false,
      trail: [],
      goRight,
      W, H,
    });
  }

  let _lastTitleT = 0;
  function animateTitleSlimes(cvs, W, H) {
    const ctx = cvs.getContext('2d');
    function frame(ts) {
      const dt = Math.min((ts - _lastTitleT) / 1000, 0.05);
      _lastTitleT = ts;
      ctx.clearRect(0, 0, W, H);

      slimes = slimes.filter(s => !s.dead);
      slimes.forEach(s => {
        // Movement
        s.x += s.vx * dt;
        s.phase += dt * 6;
        s.y += Math.sin(s.phase * s.wobble) * 18 * dt;
        // Clamp vertical
        s.y = Math.max(s.r + 2, Math.min(H - s.r - 2, s.y));

        // Trail
        s.trail.push({ x: s.x, y: s.y, a: 0.35 });
        if (s.trail.length > 10) s.trail.shift();

        // Kill when off screen
        if (s.goRight && s.x > W + s.r * 3) s.dead = true;
        if (!s.goRight && s.x < -s.r * 3) s.dead = true;

        // Draw trail
        s.trail.forEach((p, i) => {
          const prog = i / s.trail.length;
          ctx.save();
          ctx.globalAlpha = prog * p.a;
          ctx.fillStyle = s.color;
          ctx.shadowColor = s.color;
          ctx.shadowBlur = 6;
          ctx.beginPath();
          ctx.arc(p.x, p.y, s.r * (0.3 + prog * 0.5), 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });

        // Squish based on velocity direction
        const squishX = 1 + 0.18 * Math.abs(Math.sin(s.phase));
        const squishY = 1 / squishX;

        // Draw body
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.scale(squishX, squishY);
        ctx.globalAlpha = 0.92;

        // Glow
        ctx.shadowColor = s.color;
        ctx.shadowBlur = 12;
        const grad = ctx.createRadialGradient(-s.r*0.25, -s.r*0.3, 0, 0, 0, s.r);
        grad.addColorStop(0, s.color + 'ff');
        grad.addColorStop(0.6, s.color + 'cc');
        grad.addColorStop(1, s.color + '44');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, s.r, 0, Math.PI * 2);
        ctx.fill();

        // Shine
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(-s.r * 0.28, -s.r * 0.32, s.r * 0.22, 0, Math.PI * 2);
        ctx.fill();

        // Eye (direction aware)
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#000';
        const eyeX = s.goRight ? s.r * 0.25 : -s.r * 0.25;
        ctx.beginPath();
        ctx.arc(eyeX, -s.r * 0.1, s.r * 0.18, 0, Math.PI * 2);
        ctx.fill();
        // Pupil shine
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(eyeX + s.r*0.07, -s.r*0.17, s.r*0.07, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
      });

      _titleRaf = requestAnimationFrame(frame);
    }
    _titleRaf = requestAnimationFrame(frame);
  }

  // Init after DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => setTimeout(initTitleSlimes, 300));
  } else {
    setTimeout(initTitleSlimes, 300);
  }

  // Reinit on resize
  window.addEventListener('resize', () => {
    clearTimeout(window._titleResizeT);
    window._titleResizeT = setTimeout(initTitleSlimes, 200);
  });
})();
</script>
</body>
</html>
